<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">

    
  <url>
    <loc>http://blog.tinyxd.me/2014/10/26/octopress%E8%BF%81%E7%A7%BBhexo/</loc>
    <lastmod>2014-10-28T14:25:57.000Z</lastmod>
    <data>
        <display>
        <title>octopress迁移Hexo</title>
        <pubTime>2014-10-26T13:22:03.000Z</pubTime>
        
        <tag>hexo </tag>
         
        <tag>octopress </tag>
         
         <content><![CDATA[<p>Octopress generate太慢，配置环境依赖得花费好长时间搞定，加之老机器太旧；趁着最近更新了机器，无奈把博客迁移到Hexo，继续码博客吧。<br>Hexo官网:<a href="http://hexo.io" target="_blank" rel="external">Link</a></p>
<h2 id="安装">安装</h2>
<ol>
<li>Mac下首先安装Node.js，直接到<a href="http://nodejs.org/" target="_blank" rel="external">这里</a>下载安装即可，安装完毕后在.bash_profile中添加:</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> PATH=<span class="string">"/usr/local/bin/:<span class="variable">$PATH</span>"</span></div></pre></td></tr></table></figure>

<p><a id="more"></a></p>
<ol>
<li>Mac自带git，不过得先安装好xCode才可以使用git</li>
<li>新建文件夹hexo执行命令，安装hexo：</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>npm install -g hexo</div></pre></td></tr></table></figure>

<ol>
<li>执行如下命令，初始化hexo</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>hexo init &lt;folder&gt;</div><div class="line"><span class="variable">$ </span>cd &lt;folder&gt;</div><div class="line"><span class="variable">$ </span>npm install</div></pre></td></tr></table></figure>

<ol>
<li>如果是从octopress迁移的可以需要修改<code>_config.yml</code></li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ <span class="keyword">cp</span> &lt;octopress&gt;/<span class="keyword">source</span>/_post/* &lt;hexo&gt;/<span class="keyword">source</span>/_post/</div></pre></td></tr></table></figure>



<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">new_post_name:</span> <span class="symbol">:year-</span><span class="symbol">:month-</span><span class="symbol">:day-</span><span class="symbol">:title</span>.md</div></pre></td></tr></table></figure>

<p>如果想要保留RSS，可以安装<code>hexo-migrator-rss</code>插件</p>
<h2 id="主题和插件">主题和插件</h2>
<p>Hexo提供了丰富的<a href="https://github.com/tommy351/hexo/wiki/Plugins" target="_blank" rel="external">插件</a>和<a href="https://github.com/tommy351/hexo/wiki/Themes" target="_blank" rel="external">主题</a>:<br>安装方法：</p>
<ol>
<li>插件</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="input"><span class="prompt">$ npm install &lt;plugin-name&gt;</span> --save</span></div></pre></td></tr></table></figure>

<ol>
<li>主题</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="input"><span class="prompt">$ git clone &lt;repository&gt;</span> themes/&lt;theme-name&gt;</span></div></pre></td></tr></table></figure>

<p>注意需要在<code>_config.yml</code>中修改<code>plugins</code>和<code>theme</code>的值来启用。</p>
<h2 id="调试">调试</h2>
<p>执行下面命令实时查看<code>http://localhost:4000</code>：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>hexo server</div></pre></td></tr></table></figure>

<h2 id="部署git_pages">部署git pages</h2>
<p>修改<code>_config.yml</code>:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  type: github</div><div class="line">  repository: git@<span class="filename">github.com</span>:XXX/<span class="filename">XXX.github.com.git</span></div><div class="line">  branch: master</div></pre></td></tr></table></figure>

<p>注意：为项目制作网页需要讲<code>branch</code>改为<code>gh-pages</code>,如果需要自定义域名需要添加CNAME文件，参考<a href="http://zespia.tw/hexo/docs/deployment.html" target="_blank" rel="external">Hexo</a><br>之后deploy：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>hexo clean</div><div class="line"><span class="variable">$ </span>hexo generate</div><div class="line"><span class="variable">$ </span>hexo deploy</div></pre></td></tr></table></figure>

]]></content>
         
         
           
             
              <breadCrumb title="hexo" url="http://blog.tinyxd.me/categories/hexo/"/>
          
        </display>
    </data>
    </url>

    
    
    
    
    
  <url>
    <loc>http://blog.tinyxd.me/2012/05/27/arch-linuxxia-java-sdkde-an-zhuang-yu-pei-zhi/</loc>
    <lastmod>2014-10-26T03:25:08.000Z</lastmod>
    <data>
        <display>
        <title>arch linux下java SDK的安装与配置</title>
        <pubTime>2012-05-27T11:58:00.000Z</pubTime>
        
        <tag>archlinux </tag>
         
        <tag>java </tag>
         
        <tag>SDK </tag>
         
         <content><![CDATA[<p>为了节省以后查资料的时间，故而转到自己的blog做个备份。<br>转自：<br><a href="http://www.cnblogs.com/heart-runner/archive/2011/11/30/2269640.html" target="_blank" rel="external">Arch Linux中Java SDK的安装与配置</a></p>
<p>因为版权和公司对开源软件的态度，Oracle Java SDK已经不再包含于Arch Linux默认的Repository。</p>
<p>不过对于有开发需要，又不得不使用Oracle公司的产品的民工们，还好有AUR中提供的相应支持，让我们能方便地用安装脚本来处理Oracle Java SDK的安装和配置。</p>
<p>下面就简单地记录下的JDK的安装方法。</p>
<p>安装环境如下：</p>
<p>archbang 3.3.6-1-ARCH<br>Oracle Java SDK 7 update 1</p>
<h2 id="安装"><strong>安装</strong></h2>
<ul>
<li><p>jre<br>这里先安装JDK，虽然据说openjdk的jre也能兼容Oracle Java SDK，但还是有点担心它们的兼容性。<br>先在<a href="https://aur.archlinux.org/" target="_blank" rel="external">Arch Linux AUR</a>中找到<a href="https://aur.archlinux.org/packages.php?ID=51908" target="_blank" rel="external">JRE</a>。<br><a id="more"></a><br>制作安装包   </p>
<p>$ wget —no-check-certificate -c <a href="https://aur.archlinux.org/packages/jr/jre/jre.tar.gz" target="_blank" rel="external">https://aur.archlinux.org/packages/jr/jre/jre.tar.gz</a><br>$ tar -zxvf jre.tar.gz<br>$ cd  jre<br>$ makepkg    </p>
</li>
</ul>
<p>处理依赖条件，开始安装    </p>
<pre><code>$ sudo pacman -S desktop-<span class="keyword">file</span>-utils libxtst <span class="keyword">shared</span>-mime-info xdg-utils
[zzz@archbang jre]$ sudo pacman -U ./jre-<span class="number">7.4</span>-<span class="number">1</span>-i686.pkg.tar.xz 
loading packages...
resolving dependencies...
looking <span class="keyword">for</span> inter-conflicts...

Targets (<span class="number">1</span>): jre-<span class="number">7.4</span>-<span class="number">1</span>

Total Installed Size:   <span class="number">92.30</span> MiB

Proceed <span class="keyword">with</span> installation? [Y/n] 
(<span class="number">1</span>/<span class="number">1</span>) checking <span class="keyword">package</span> integrity                   [<span class="comment">----------------------] 100%</span>
(<span class="number">1</span>/<span class="number">1</span>) loading <span class="keyword">package</span> files                        [<span class="comment">----------------------] 100%</span>
(<span class="number">1</span>/<span class="number">1</span>) checking <span class="keyword">for</span> <span class="keyword">file</span> conflicts                  [<span class="comment">----------------------] 100%</span>
(<span class="number">1</span>/<span class="number">1</span>) checking available disk space                [<span class="comment">----------------------] 100%</span>
(<span class="number">1</span>/<span class="number">1</span>) installing jre                               [<span class="comment">----------------------] 100%</span>
The jre <span class="keyword">package</span> <span class="keyword">is</span> licensed software.
You MUST read <span class="keyword">and</span> agree <span class="keyword">to</span> the license stored <span class="keyword">in</span>
/usr/share/licenses/jre/LICENSE before using it.
Please relogin <span class="keyword">to</span> include jre <span class="keyword">in</span> your PATH.

Optional dependencies <span class="keyword">for</span> jre
alsa-lib: sound support
ttf-dejavu: fonts
</code></pre><p>Arch Linux中，Java SDK默认的安装位置是/opt/java</p>
<pre><code>$ <span class="keyword">pwd</span> 
/<span class="keyword">opt</span>/java
$ <span class="keyword">ls</span>
jre
</code></pre><h2 id="至此，JRE成功安装。">至此，JRE成功安装。</h2>
<ul>
<li><p>JDK<br>JDK的安装过程与JRE类似。   </p>
<p>$ wget -c —no-check-certificate <a href="https://aur.archlinux.org/packages/jd/jdk/jdk.tar.gz" target="_blank" rel="external">https://aur.archlinux.org/packages/jd/jdk/jdk.tar.gz</a><br>$ tar -zxvf jdk.tar.gz<br>$ cd jdk<br>$ makepkg<br>$ sudo pacman -U ./jdk-7.4-1-i686.pkg.tar.xz<br>loading packages…<br>resolving dependencies…<br>looking for inter-conflicts…   </p>
<p>Targets (1): jdk-7.4-1   </p>
<p>Total Installed Size:   86.05 MiB   </p>
<p>Proceed with installation? [Y/n]<br>(1/1) checking package integrity                   [———————————] 100%<br>(1/1) loading package files                        [———————————] 100%<br>(1/1) checking for file conflicts                  [———————————] 100%<br>(1/1) checking available disk space                [———————————] 100%<br>(1/1) installing jdk                               [———————————] 100%   </p>
<p>The jdk package is licensed software.<br>You MUST read and agree to the license stored in<br>/usr/share/licenses/jdk/LICENSE before using it.<br>Please relogin to include jdk in your PATH.   </p>
</li>
</ul>
<p>配置<br>安装之后打开/etc/environment文件编辑，添加如下内容：</p>
<pre><code><span class="comment">#Java SDK </span>
<span class="comment">#</span>
<span class="constant">CLASSPATH</span>=.<span class="symbol">:/opt/java/lib</span>
<span class="constant">JAVA_HOME</span>=<span class="regexp">/opt/java</span>
</code></pre><p>添加之后就可以使用java和javac命令了</p>
<pre><code>$ java -<span class="keyword">version</span>
java <span class="keyword">version</span> <span class="string">"1.7.0_01"</span>
Java(TM) SE Runtime Environment (build <span class="number">1.7</span>.<span class="number">0</span>_01-b08)
Java HotSpot(TM) Client VM (build <span class="number">21.1</span>-b02, mixed <span class="built_in">mode</span>)
$ javac -<span class="keyword">version</span>
javac <span class="number">1.7</span>.<span class="number">0</span>_01   
</code></pre><p>更详细的内容可参考<a href="http://sillydong.com/myjava/arch-linux%E5%BF%AB%E9%80%9F%E9%85%8D%E7%BD%AEjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.html" target="_blank" rel="external">傻东の学习笔记</a><br>3、解决中文乱码问题，还是用超级用户，进入/usr/share/fonts/wenquanyi，将wqy-zenhei文件夹复制到/opt/java/jre/lib/fonts下，改名为fallback，进入fallback文件夹，终端执行</p>
<pre><code><span class="preprocessor"># mkfontdir</span>
和
<span class="preprocessor"># mkfontscale</span>
</code></pre><p>4、安装eclipse，只需要打开终端执行pacman -S eclipse就可以安装eclipse最新的英文版   </p>
<p>5、执行jar文件的办法。在Arch中，jar文件默认是使用归档文件管理器打开的，也就相当于解压缩，而我们需要的是执行这个jar程序，跟我做：在目标jar文件上右击，选择“属性”，找到“打开方式”的标签，选择“添加”，打开“使用自定义命令”，向其中加入下面的命令：   </p>
<pre><code><span class="title">java</span> -jar
</code></pre><p>输完之后选择“添加”，这时候在打开方式标签下有两个选择，一种就是原来就有的“归档文件管理器”，还有就是“java”，勾选上“java”，然后关闭，这时候双击jar文件就是执行它了。</p>
]]></content>
         
         
           
             
              <breadCrumb title="java" url="http://blog.tinyxd.me/categories/java/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/05/26/bang-nin-kuai-su-ru-men-tide-codec-engine-zhuan-zai/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>帮您快速入门TI的Codec Engine</title>
        <pubTime>2012-05-25T22:18:00.000Z</pubTime>
        
        <tag>davinci </tag>
         
        <tag>codec engine </tag>
         
        <tag>ti </tag>
         
        <tag>embedded </tag>
         
         <content><![CDATA[<p>转自TI官网：<br>德州仪器半导体技术（上海）有限公司 通用DSP 技术应用工程师 崔晶   </p>
<p>德州仪器（TI）的第一颗达芬奇（DaVinci）芯片（处理器）DM6446已经问世快三年了。继DM644x之后，TI又陆续推出了DM643x，DM35x，DM6467，OMAP353x等一系列ARM＋DSP或ARM＋视频协处理器的多媒体处理器平台。很多有很强DSP开发经验或ARM开发经验的工程师都转到达芬奇或通用OMAP（OMAP353x）平台上开发视频监控、视频会议及便携式多媒体终端等产品。大家都面临着同一个问题，那就是如何实现ARM和DSP或协处理器的通信和协同工作？TI的数字视频软件开发包（DVSDK）提供了Codec Engine这样一个软件模块来实现ARM和DSP或协处理器的协同工作。有很多工程师反馈这个软件模块非常好用，节省了很多开发时间，也有工程师认为TI提供的资料太多，不知如何快速上手。本文将从一个第一次接触Codec Engine的工程师角度出发，归纳TI提供的相关资源（文档，例程和网络资源）并介绍相关开发调试方法帮您快速入门Codec Engine。<br>1．Codec Engine概述<br>Codec Engine是连接ARM和DSP或协处理器的桥梁，是介于应用层（ARM侧的应用程序）和信号处理层（DSP侧的算法）之间的软件模块。ARM应用程序调用Codec Engine的VISA （Video, Image, Speech, Audio）API，如图1中VIDENC_process(a, b, c )。Codec Engine的stub （ARM侧）会把参数a, b, c以及要调用DSP侧process这个信息打包，通过消息队列（message queue）传递到DSP。Codec Engine的skeleton（DSP侧）会解开这个参数包，把参数a, b, c转换成DSP侧对应的参数x, y, z（比如ARM侧传递的是虚拟地址，而DSP只能认物理地址），DSP侧的server（优先级较低，负责和ARM通信的任务）会根据process这一信息创建一个DSP侧的process(x, y, x)任务最终实现VIDENC_process(a, b, c)的操作。<br>2．Codec Engine入门第一步，从Codec Engine发布说明文档(release notes)开始<br>3．Codec Engine入门第二步，了解Codec Engine的运行环境及依赖的软件模块和工具   </p>
<p>点击Codec Engine的发布说明文档 的Validation Info，我们可以知道Codec Engine 1.20需要和以下软件模块和工具配合使用：   </p>
<pre><code>Framework Components <span class="number">1.20</span><span class="number">.02</span>   
xDAIS <span class="number">5.21</span>   
XDC Tools <span class="number">2.93</span><span class="number">.01</span>   
DSP/BIOS Link <span class="number">1.40</span><span class="number">.05</span>, configured <span class="keyword">for</span> <span class="operator">the</span> DM6446 EVM   
C6x Code Generation Tools <span class="built_in">version</span> <span class="number">6.0</span><span class="number">.8</span>   
DSP/BIOS <span class="number">5.31</span><span class="number">.05</span>   
MontaVista Linux v4<span class="number">.0</span>   
Red Hat Enterprise Linux <span class="number">3</span> (SMP)    
</code></pre><p>因此，我们需要在该Codec Engine安装的DVSDK文件包下面检查上面提到的软件模块和工具是否安装，版本是否正确。否则，可能会编译不过 Codec Engine的例子。那么，什么是 Framework Components，什么是xDAIS，什么又是XDC Tools呢？你可以分别到它们的根目录下浏览它们各自的发布说明文档，做一个总体的了解。<br><a id="more"></a><br>这里我们简单介绍一下，可以帮助大家尽快找到和自己相关的重点及资源。   </p>
<p>1） Framework Components是TI提供的一个软件模块，负责DSP侧的memory 和DMA资源管理。因此，DSP算法工程师需要了解这个软件模块。<br><a href="http://tiexpressdsp.com/wiki/index.php?title=Framework_Components_FAQ" target="_blank" rel="external">http://tiexpressdsp.com/wiki/index.php?title=Framework_Components_FAQ</a><br>2） xDAIS 是一个标准，它定义了TI DSP算法接口的标准。这样大大提高了DSP算法软件的通用性。DSP算法工程师要写出能被ARM通过Codec Engine调用的算法，必须保证自己的算法接口符合这个标准。因此，DSP算法工程师也必须了解这个软件模块。   </p>
<p><a href="http://tiexpressdsp.com/wiki/index.php?title=Category:XDAIS" target="_blank" rel="external">http://tiexpressdsp.com/wiki/index.php?title=Category:XDAIS</a>   </p>
<p>3） XDC Tools和gmake类似，是一个工具。XDC根据用户定义的一套build指令，通过调用用户指定的ARM 工具链（Tool Chain）和DSP编译器（C6x Code Generation Tools ）build出ARM侧和DSP侧的可执行文件。可以先不必细究这个工具，只需通过编Codec Engine的例子，知道如何设置build指令就可以了。   </p>
<p>4） DSP/BIOS Link是实现ARM和DSP之间通信的底层软件，Codec Engine就是建立在这个底层软件之上。在修改系统内存分配（缺省是256MB的DDR2）时，DSP/BIOS Link 1.38版本的用户需要修改DSP/BIOS Link的配置文件，并重新build DSP/BIOS Link。而DSP/BIOS Link 1.40版本以后的用户就无需此操作。   </p>
<p><a href="http://tiexpressdsp.com/wiki/index.php?title=DSPLink_Overview" target="_blank" rel="external">http://tiexpressdsp.com/wiki/index.php?title=DSPLink_Overview</a><br><a href="http://wiki.davincidsp.com/index.php?title=Changing_the_DVEVM_memory_map" target="_blank" rel="external">http://wiki.davincidsp.com/index.php?title=Changing_the_DVEVM_memory_map</a>   </p>
<p>5） C6x Code Generation Tools是Linux环境下C6000系列DSP的编译器。我们用CCS开发DSP时都是用的Windows环境下的DSP编译器。   </p>
<p>6） DSP/BIOS是TI 免费提供的DSP实时操作系统。和上面C6x Code Generation Tools一样，这里的DSP/BIOS也是Linux环境下的版本。DSP系统工程师需要了解这个操作系统。   </p>
<p><a href="http://tiexpressdsp.com/wiki/index.php?title=Category:DSPBIOS" target="_blank" rel="external">http://tiexpressdsp.com/wiki/index.php?title=Category:DSPBIOS</a>   </p>
<p>4．Codec Engine入门第三步，根据自己的角色参考相关的文档和例子进行开发   </p>
<p>开发ARM＋DSP平台需要三类工程师：ARM应用程序工程师、DSP算法工程师和DSP系统工程师。而开发ARM＋协处理器平台只需要ARM应用程序工程师。下面就让我们针对这三类工程师做分别介绍。如果您使用的是TI或TI第三方的编解码算法，就不需要关注DSP算法工程师的部分。如果使用ARM＋协处理器平台，就只需关心ARM应用工程师的部分。   </p>
<p>4．1 DSP算法工程师应该如何着手？<br>这里我们不讨论如何开发DSP算法，只讨论DSP算法工程师怎样让自己的算法可以被ARM通过Codec Engine调用。（参考<a href="http://www.ti.com/litv/pdf/sprued6c，这个文档会讲到codec" target="_blank" rel="external">http://www.ti.com/litv/pdf/sprued6c，这个文档会讲到codec</a> package及相关的.xs和.xdc文件，Codec Engine1.20及以上版本的用户可以先不细究这些内容，后面会介绍工具帮您自动生成这些文件。）   </p>
<p>1） 熟悉xDAIS和xDM标准。<br>xDM只是xDAIS的扩展，因此，需要先了解xDAIS。在xDAIS 软件包根目录下的发布说明文档里，可以很快找到关于xDAIS和xDM的文档链接。<br><a href="http://focus.ti.com/lit/ug/spruec8b/spruec8b.pdf" target="_blank" rel="external">http://focus.ti.com/lit/ug/spruec8b/spruec8b.pdf</a><br>在xDAIS安装路径下的examples/ti/xdais/dm/examples/g711有一个g711_sun_internal.c，这个算法不符合xDAIS标准。在同一个路径下的g711dec_sun_ialg.c (decoder)和g711enc_sun_ialg.c (encoder)是封装成符合xDM标准之后的编解码算法。可以通过这个例子学习和了解如何把自己算法封装成符合xDM标准的算法。<br>xDAIS 6.10及其以后的版本，包含了一个工具QualiTI，可以检查您的DSP算法是否满足xDAIS标准（但不会检查是否满足xDM）。具体请参考：<br><a href="http://tiexpressdsp.com/wiki/index.php?title=QualiTI_XDAIS_Compliance_Tool" target="_blank" rel="external">http://tiexpressdsp.com/wiki/index.php?title=QualiTI_XDAIS_Compliance_Tool</a>   </p>
<p>2） 熟悉Framework Components。 Framework Components主要包括两个模块DSKT2和DMAN3，它们分别负责DSP侧的memory 和EDMA资源管理。DSP算法使用的memory必须是先向DSKT2提出申请并由DSKT2分配得到的。同样DSP算法使用的EDMA通道也是向DMAN3申请并由DMAN3分配得到的。而关于QDMA的操作，是通过ACPY3这个模块实现的。这样的好处是很容易对DSP侧不同的算法做整合，不同的算法之间不用担心资源（Memory和EDMA）的冲突问题。<br>在Framework Components 软件包根目录下的发布说明文档里，可以很快找到相关文档的链接。在Framework Components安装路径下packages\ti\sdo\fc\dman3\examples有一个Fast Copy的例子，可以帮您理解如何基于Framework Components的ACPY3模块实现QDMA的操作。<br>另外，有些用户DSP侧的算法比较简单，在确保不和ARM侧EDMA资源冲突的前提下在算法里直接操作EDMA不使用DMAN3也是可以的。这样做的弊端是和其它算法做整合时会遇到资源使用冲突的问题。</p>
<p>4．2 DSP系统工程师应该如何着手？<br>通常DSP算法工程师都会把自己的符合xDM标准算法编成一个.lib文件（或 .a64P），供DSP系统工程师调用。DSP系统工程师最终build出一个DSP Server（也就是DSP的可执行程序.x64P，和CCS下编译生成的.out类似）。（参考<a href="http://focus.ti.com/lit/ug/sprued5b/sprued5b.pdf，这个文档会讲到.xdc和.bld等文件，Codec" target="_blank" rel="external">http://focus.ti.com/lit/ug/sprued5b/sprued5b.pdf，这个文档会讲到.xdc和.bld等文件，Codec</a> Engine1.20及以上版本的用户可以先不细究，后面介绍工具帮您自动生成这些文件。）   </p>
<p>1） 如果现在有一个.lib文件（或 .a64P）（算法必须符合xDM标准），如何生成自己的DSP Server呢？下面URL有详细的关于RTSC Codec and Server Package Wizard工具介绍，教您如何把一个.lib文件封装成RTSC Codec 包和RTSC DSP Server包，并最终build出DSP的可执行程序.x64P。<br><a href="http://wiki.davincidsp.com/index.php?title=RTSC_Codec_And_Server_Package_Wizards" target="_blank" rel="external">http://wiki.davincidsp.com/index.php?title=RTSC_Codec_And_Server_Package_Wizards</a><br><a href="http://wiki.davincidsp.com/index.php?title=I_just_want_my_video_codec_to_work_with_the_DVSDK" target="_blank" rel="external">http://wiki.davincidsp.com/index.php?title=I_just_want_my_video_codec_to_work_with_the_DVSDK</a>   </p>
<p>2） 如果您使用的是Codec Engine 1.20以前的版本，请参考Codec Engine安装路径下examples/servers/video_copy这个例子。这时就需要搞清楚sprued6c.pdf和sprued5b.pdf中提到的.xdc和.xs等文件的功能，也可以在video_copy中的相关文件的基础上修改手动创建出自己的RTSC Codec包和RTSC DSP server包。   </p>
<p>3） 创建好RTSC Codec 和RTSC DSP Server包之后，就是如何build出.x64P的问题了。点击图2所示的Examples，就可以找到build Codec Engine例子的说明文档的链接。按照这个文档做一遍后，就可以对如何build Codec Server有一个清楚的了解。其中关键是修改user.bld和xdcpaths.mak文件，设置Codec Engine依赖的其它软件模块和工具的正确路径。   </p>
<p>4） 如果自己的硬件DDR2大小和例子中的256Mbytes不一致，需要修改DSP的.tcf文件和其他配置。还有些工程师不清楚如何分配memory及如何决定具体段，如：DDRALGHEAP和DDR的大小，以及如何配置./loadmodules里的参数都请参考： <a href="http://wiki.davincidsp.com/index.php?title=Changing_the_DVEVM_memory_map。" target="_blank" rel="external">http://wiki.davincidsp.com/index.php?title=Changing_the_DVEVM_memory_map。</a>   </p>
<p>4．3 ARM应用程序工程师应该如何着手？<br>ARM应用工程师需要调用Codec Engine的VISA API，最终编出ARM侧的可执行程序，因此，必须根据自己的应用学习相关的VISA API、如何创建应用侧Codec Engine的package及配置文件。（参考<a href="http://focus.ti.com/lit/ug/sprue67d/sprue67d.pdf，这个文档也涉及到如何调试Codec" target="_blank" rel="external">http://focus.ti.com/lit/ug/sprue67d/sprue67d.pdf，这个文档也涉及到如何调试Codec</a> Engine的内容）。</p>
<p>1）了解ARM应用程序调用Codec Engine的流程、VISA API和其他Codec Engine API。可以参考Codec Engine安装路径下examples/apps/video_copy的例子（较简单）或者DVSDK安装路径下demos里的encode/decode/encodedecode例子（较复杂）。<br><a href="http://wiki.davincidsp.com/index.php?title=Configuring_Codec_Engine_in_Arm_apps_with_createFromServer" target="_blank" rel="external">http://wiki.davincidsp.com/index.php?title=Configuring_Codec_Engine_in_Arm_apps_with_createFromServer</a><br>2） 了解ceapp.cfg文件。sprue67d.pdf有相关介绍，可以先读懂<br>examples/apps/video_copy/ceapp.cfg。   </p>
<p>3） 用4.2 3)中提到的方法学习如何build ARM侧的可执行程序。   </p>
<p>4） 如何在多线程中调用codec engine，参考：<br><a href="http://wiki.davincidsp.com/index.php?title=Multiple_Threads_using_Codec_Engine_Handle" target="_blank" rel="external">http://wiki.davincidsp.com/index.php?title=Multiple_Threads_using_Codec_Engine_Handle</a>   </p>
<p>5）还可以参考以下三个文档了解更多TI demo的ARM应用程序的结构、线程调度等具体的问题。   </p>
<p>EncodeDecode Demo for the DaVinci DVEVM/DVSDK 1.2 (Rev. A) (spraah0a.htm, 8 KB)<br>27 Jun 2007 Abstract  </p>
<p>Encode Demo for the DaVinci DVEVM/DVSDK 1.2 (Rev. A) (spraa96a.htm, 8 KB)<br>27 Jun 2007 Abstract  </p>
<p>Decode Demo for the DaVinci DVEVM/DVSDK 1.2 (Rev. A) (spraag9a.htm, 8 KB)<br>27 Jun 2007 Abstract  </p>
<p>5．使用中常碰到的问题  </p>
<p>1）如果遇到问题可以先访问 <a href="http://wiki.davincidsp.com/index.php?title=Codec_Engine_FAQ。" target="_blank" rel="external">http://wiki.davincidsp.com/index.php?title=Codec_Engine_FAQ。</a><br>2）有些工程师没有DSP开发经验，或者暂时没有仿真器通过JTAG调试DSP。可以参考下面网页的内容，先做一个“Hello World”的例程对ARM和DSP如何协同工作有个感性认识。   </p>
<p><a href="http://wiki.davincidsp.com/index.php?title=How_to_build_an_ARM/DSP_Hello_World_program_on_the_DaVinci_EVM" target="_blank" rel="external">http://wiki.davincidsp.com/index.php?title=How_to_build_an_ARM/DSP_Hello_World_program_on_the_DaVinci_EVM</a>   </p>
<p>3） 很多工程师都是参考video_copy的例子，在它的基础上把自己的算法加进去。因为有源代码，这样比较容易。但肯定要根据自己算法的需要修改ARM和DSP之间传递的buffer和参数，重要的是先保证ARM侧的应用程序可以把buffer和参数正确传递到DSP，DSP可以把处理之后的buffer正确的传到ARM侧的应用程序。把这个通路打通之后，就比较容易定位问题是出在ARM应用程序还是DSP侧的算法。另外，参考video_copy例子时注意代码的注释，以便清楚哪一句代码可以删掉哪一句必须要修改或保留。   </p>
<p>如果要扩展xDM的数据结构请参考：   </p>
<p><a href="http://wiki.davincidsp.com/index.php?title=Extending_data_structures_in_xDM。" target="_blank" rel="external">http://wiki.davincidsp.com/index.php?title=Extending_data_structures_in_xDM。</a>   </p>
<p>4） Codec Engine DSP侧会涉及到Cache一致性的问题。请参考：<br><a href="http://wiki.davincidsp.com/index.php?title=Cache_Management" target="_blank" rel="external">http://wiki.davincidsp.com/index.php?title=Cache_Management</a>   </p>
<p>5） 关于Codec Engine系统调试，有以下几种方法：   </p>
<pre><code>    A. 打开Codec Engine <span class="keyword">trace</span>，通过打印信息看问题出在什么地方。比如engine_open失败，DSP侧不能创建codec 等等。   

        a) Codec Engine <span class="number">2.0</span>及以上版本，请参考： http:<span class="comment">//wiki.davincidsp.com/index.php?title=Easy_CE_Debugging_Feature_in_CE_2.0   </span>

        b) Codec Engine <span class="number">1.</span>x版本，请参考： http:<span class="comment">//wiki.davincidsp.com/index.php?title=TraceUtil   </span>

    B. ARM应用程序跑起来后，用仿真器连上CCS调试DSP侧程序，参考： http:<span class="comment">//wiki.davincidsp.com/index.php?title=Debugging_the_DSP_side_of_a_CE_application_on_DaVinci_using_CCS   </span>

    C. 用Soc Analyzer可以做系统调试之外，还可以统计具体函数运行（ARM和DSP侧）时间（benchmark）。请参考： http:<span class="comment">//tiexpressdsp.com/wiki/index.php?title=SoC_Analyzer    </span>
</code></pre><p>6） 因为Codec Engine是介于ARM 应用程序和编解码算法中间的软件模块，很多工程师非常想知道它的开销(overhead)，请参考：<br><a href="http://wiki.davincidsp.com/index.php?title=Codec_Engine_Overhead" target="_blank" rel="external">http://wiki.davincidsp.com/index.php?title=Codec_Engine_Overhead</a>   </p>
<p>7）如何在Linux环境下编DSP的汇编或线性汇编程序？<br>在Codec Engine安装路径下/packages/config.bld文件里<br>var C64P = xdc.useModule(‘ti.targets.C64P’);<br>之后添加：<br>    C64P.extensions[“.sa”] = {<br>    suf: “.sa”, typ: “asm:-fl”<br>    }<br>或<br>    C64P.extensions[“.asm”] = {<br>    suf: “.asm”, typ: “asm:-fa”<br>    }<br>8）DSP侧如何统计具体函数运行时间？<br>TI DSPC64x+内核有一个64位的硬件定时器（Time Stamp Counter），它的频率和CPU频率一致。<br>最简单的办法是使用TSC的低32位TSCL。注意在DM644x中，TSCH用于ARM。   </p>
<pre><code><span class="comment">#include void main (){</span>
…
<span class="variable">TSCL=</span><span class="number">0</span>;
…
<span class="variable">t1=</span>TSCL;
my_code_to_benchmark();
<span class="variable">t2=</span>TSCL;
printf(“<span class="comment"># cycles == %d\n”, (t2-t1));</span>
}
</code></pre><p>6．结语   </p>
<p>以上针对如何上手TI的Codec Engine做了简单的归纳，还有很多具体细节的问题没有涉及到。还请各位工程师从自己要用的软件模块发布说明文档开始找到相关的文档并研究。经常访问TI的网页，<a href="http://wiki.davincidsp.com和http://tiexpressdsp.com/wiki找到最新的信息和资料。也非常欢迎您在wiki上提问。" target="_blank" rel="external">http://wiki.davincidsp.com和http://tiexpressdsp.com/wiki找到最新的信息和资料。也非常欢迎您在wiki上提问。</a>   </p>
]]></content>
         
         
           
             
              <breadCrumb title="davinci" url="http://blog.tinyxd.me/categories/davinci/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/05/23/octopress-xin-shou-jiao-cheng/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>Octopress:新手教程</title>
        <pubTime>2012-05-23T12:55:00.000Z</pubTime>
        
         <content><![CDATA[<p><em>转载自：</em><br><a href="http://geekontheway.github.com/blog/2011/12/03/octopress-for-freshman/" target="_blank" rel="external">http://geekontheway.github.com/blog/2011/12/03/octopress-for-freshman/</a><br>Octopress基于jekyll，刚开始使用起来也比较复杂：<br>    Octopress会有两个分支：source（编写博客）和master（生成好的博客），就像这样：</p>
<pre><code>git <span class="comment">remote -v</span>

octopress git://github.com/imathis/octopress.git (fetch)
octopress git://github.com/imathis/octopress.git (push)
origin    git@github.com:geekontheway/geekontheway.github.com.git (fetch)
origin    git@github.com:geekontheway/geekontheway.github.com.git (push)


git branch -a

* source
  <span class="comment">remotes/octopress/HEAD -&gt; octopress/master</span>
  <span class="comment">remotes/octopress/compass</span>
  <span class="comment">remotes/octopress/configuration</span>
  <span class="comment">remotes/octopress/edge</span>
  <span class="comment">remotes/octopress/generate_environment</span>
  <span class="comment">remotes/octopress/gh-pages</span>
  <span class="comment">remotes/octopress/master</span>
  <span class="comment">remotes/octopress/move_rakefile_configs</span>
  <span class="comment">remotes/octopress/post_names</span>
  <span class="comment">remotes/octopress/rake_minify_js</span>
  <span class="comment">remotes/octopress/refactor_code_highlight</span>
  <span class="comment">remotes/octopress/refactor_deployment</span>
  <span class="comment">remotes/octopress/refactor_js</span>
  <span class="comment">remotes/octopress/site</span>
  <span class="comment">remotes/octopress/site-deploy-test</span>
  <span class="comment">remotes/octopress/subdir</span>
<span class="comment">remotes/octopress/thor</span>
</code></pre><p>其中只有origin仓库和source分支是必须的，其余分支或仓库建议删掉。<br><a id="more"></a><br>我们来看一下source分支都有什么：</p>
<pre><code>CHANGELOG.markdown  
config.ru   
<span class="code"> _deploy  部署文件夹，在.gitignore中被设置了</span>
<span class="title">.DS_Store 文件夹显示属性，在.gitignore中被设置了</span>
Gemfile.lock  
<span class="title">.gitignore  </span>
plugins  
<span class="title">.pygments-cache   </span>
<span class="title">.rbenv-version Ruby版本有特殊要求 这个文件在.gitignore中被设置了   </span>
<span class="title">.rvmrc   Ruby版本有特殊要求</span>
<span class="title">.sass-cache  </span>
source
config.rb           
<span class="emphasis">_config.yml  
Gemfile  
.git          
.idea   Rubymine设置文件，在.gitignore中被设置了    
public  在.gitignore中被设置了  
Rakefile         
README.markdown  
sass    
.slugignore  
.themes</span>
</code></pre><p>其中_deploy,source,public这三个文件夹很有趣：</p>
<pre><code>如果你是和别人合作博客，或者自己同时在好几个电脑上写博客，每次开始之前，git pull origin source获得最新的文件,rake generate生成新的页面

我们在source分支做了博客的发布，或者改变了博客的设置之后，rake generate生成网站

rake watch+pow 或者rake review+<span class="method">http:</span>//<span class="method">localhost:</span><span class="number">4000</span>就可以看到我们所做的变化

确认无误后，rake deploy文章就发布到了博客中

当然，不要忘了更新项目 git push origin source

特别的，如果你克隆了博客，记得在git checkout source，然后rake setup_github_pages执行初始化，当然，在那之前也需要bundle install，然后rake generate就生成页面了.

如果是新建的<span class="class">Repo</span> ，记得


<span class="char">$ </span>mkdir yourrepo
<span class="char">$ </span>cd yourrepo
<span class="char">$ </span>git init
# 其实这这时如果你多新建一个index.html文件的话，github会为你生成一个jekyll博客。
<span class="char">$ </span>touch <span class="class">README</span>
<span class="char">$ </span>git add .
<span class="char">$ </span>git commit -m <span class="string">'first commit'</span>
<span class="char">$ </span>git remote add origin git@github.<span class="method">com:</span>username/yourname.github.com.git
<span class="char">$ </span>git push origin master
</code></pre><p>对于新手有几个提醒:<br>1.时常git status,git log避免误操作<br>2.不要在github上直接编辑文件<br>3.想清楚了再下手<br>4.github pages的 username 大小写敏感。如果用户名和username不一致的话,默认会生成这个Repo的project pages。   </p>
]]></content>
         
         
           
             
              <breadCrumb title="octopress" url="http://blog.tinyxd.me/categories/octopress/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/05/31/cache--zhi-xing-wen-ti-zong-jie/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>cache一致性问题总结</title>
        <pubTime>2012-05-31T12:59:00.000Z</pubTime>
        
        <tag>embedded </tag>
         
        <tag>cache </tag>
         
        <tag>dsp </tag>
         
         <content><![CDATA[<h2 id="1-现代并行机中，为了提高处理器的速度，处理器往往带有Cache。">1.现代并行机中，为了提高处理器的速度，处理器往往带有Cache。</h2>
<p>一个数据在整个系统内可能有多份拷贝，这就引发了Cache一致性问题。<br>例如下图中的2个处理器和共享内存构成的系统。初始时刻，处理机P1和P2都将变量X从共享内存装入了私有Cache。<br>这时，两个Cache中和共享内存中的变量X的值是一样的。在程序运行的某一时刻，处理机P1把X的值修改为X’，并更新了私有Cache中 的值。<br>此时无论P1采用写直达（write-through），还是写回（write-back）策略，都不会修改P2私有Cache中X的值。这时如果P2需要读取X，则它得到的是过时的值。   </p>
<p><img src="/images/cache.gif"><br><a id="more"></a><br>　　Cache一致性问题是指在含有多个Cache的并行系统中，数据的多个副本（因为没有同步更新）而造成的不一致问题。以上的例子是由于多个处理器共享一个可写变量<br>造成的Cache不一致。还有其它原因也会造成Cache一致性问题，比如进程迁移和某些I/O操作等。</p>
<h2 id="2-c64x+与cache一致性问题（http://focus-ti-com-cn/cn/general/docs/gencontent-tsp?contentId=64183）">2.c64x+与cache一致性问题（<a href="http://focus.ti.com.cn/cn/general/docs/gencontent.tsp?contentId=64183）" target="_blank" rel="external">http://focus.ti.com.cn/cn/general/docs/gencontent.tsp?contentId=64183）</a></h2>
<p>在各种数字信号处理系统中，CACHE被广泛用于弥补Core与存储器之间的速度差异。在CACHE的使用过程中，存在不同类型存储器之间数据是否一致的问题。<br>本文着重分析TI高性能C64x+ DSP系列中各级CACHE之间数据一致性问题以及如何进行一致性维护。CACHE作为Core和低速存储器之间的桥梁，基于代码和<br>数据的时间和空间相关性，以块为单位由硬件控制器自动加载Core所需要的代码和数据。如果所有程序和数据的存取都由Core完成，基于CACHE的运行机制，<br>Core始终能够得到存储器中最新的数据。但是当有其它可以更改存储器内容的部件存在时，例如不需要Core干预的直接数据存取（DMA）引擎，就可能出现<br>由于CACHE的存在而导致Core或者DMA不能够得到最新数据的现象，也就是CACHE一致性的问题。 C64x+ 存储器组织结构：TI对高性能C64x核进行了改进，<br>使其性能大大提升，称之为C64x+DSP核。基于C64x+核开发的DSP芯片，所有部件都以交换网络（SCR）为核心连接起来。SCR上的部件分为两类：Master和Slave。<br>Master包括Core、EDMA以及串行高速IO（sRIO），EMAC等外设。Master可以直接通过SCR发起到Slave的数据传输。Slave包括每一个Core的内存，DDR2外存以及<br>其它不能直接发起数据传输的外设，Slave之间的数据传输，需要通过DMA协助完成。各款基于C64x+DSP的数据手册上详细描述了SCR的配置和Master、Slave的情况。</p>
<h2 id="3-DMA与cache一致性问题">3.DMA与cache一致性问题</h2>
<p>　Cache数据与主存数据不一致是指：在采用Cache的系统中，同样一个数据可能既存在于Cache中，也存在于主存中，两者数据相同则具有一致性，<br>数据不相同就叫做不一致性。如果不能保证数据的一致性，那么，后续程序的运行就要出现问题。假设DMA针对内存的目的地址与Cache缓存的对象<br>没有重叠区域，DMA和Cache之间将相安无事。但是如果DMA的目的地址与Cache所缓冲的内存地址访问有重叠，经过DMA操作Cache缓冲所对应的内存数据已经被修改，<br>而CPU本身并不知道，它仍然认为Cache中的数据就是内存中的数据，以后访问Cache映射的内存时，它仍然使用陈旧的Cache数据。这样就发生Cache与内存之间数据“<br>不一致性”的错误。</p>
]]></content>
         
         
           
             
              <breadCrumb title="embedded" url="http://blog.tinyxd.me/categories/embedded/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/06/04/linuxxia-shi-yong-lftpde-xiao-jie/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>linux下使用lftp的小结</title>
        <pubTime>2012-06-03T23:08:00.000Z</pubTime>
        
        <tag>linux </tag>
         
        <tag>lftp </tag>
         
         <content><![CDATA[<p>lftp的功能比较强大，相比原来用ftp，方便了很多。</p>
<p>1、登陆：</p>
<p>lftp ftp://yourname@site   </p>
<p>pwd:<strong>*</strong>   </p>
<p>或 open ftp://yourname@site   </p>
<p><a id="more"></a><br>2、基本操作（转）<br>lftp使用介绍   </p>
<p>lftp 是一个功能强大的下载工具，它支持访问文件的协议: ftp, ftps, http, https, hftp, fish.(其中ftps和https需要在编译的时候包含openssl库)。llftp的界面非常想一个shell: 有命令补全，历史记录，允许多个后台任务执行等功能，使用起来非常方便。它还有书签、排队、镜像、断点续传、多进程下载等功能。<br>命令行语法<br>要看lftp的命令行语法，只要在shell中输入lftp —help<br>lftp [OPTS]<br>‘lftp’是在 rc 文件执行后 lftp 执行的第一个命令<br>-f 执行文件中的命令后退出<br>-c 执行命令后退出<br>—help 显示帮助信息后退出<br>—version 显示 lftp 版本后退出<br>其他的选项同 ‘open’ 命令<br>-e 在选择后执行命令<br>-u [,] 使用指定的用户名/口令进行验证<br>-p 连接指定的端口<br>主机名, URL 或书签的名字<br>如果在命令行中输入的站点名称，lftp将直接登录站点，比如<br>ftp ftp://………….<br>如果在命令行不输入站点名称，则必须在进入到lftp界面后用open命令打开<br>[yhj@ccse-yhj yhj]$ lftp<br>lftp :~&gt; open ftp://……………….<br>常用命令   </p>
<ul>
<li>下载单个文件和一组文件，断点续传用-c参数<br>lftp …………….:/&gt; get -c ls-lR.txt<br>lftp ……………:/&gt; mget *.txt   </li>
<li>镜像(反镜像即上传)一个目录，可以用多个线程并行镜像一个目录(—parallel=N)<br>lftp …………….:/&gt; mirror incoming local_name<br>lftp …………….:/&gt; mirror -R local_name<br>lftp …………….:/&gt; mirror —parallel=3 incoming local_name   </li>
<li>多线程下载，类似网络蚂蚁的功能;缺省是5个线程<br>lftp …………….:/&gt; pget -n 4 ls-lR.txt   </li>
<li>后台任务管理<br>缺省情况下，按 Ctrl+z,正在执行的任务将转为后台执行，也可以在命令行末尾加&amp;符号使任务在后台执行。用jobs命令可以查看所有的后台进程。用queue命令可以排队新的任务。如果退出lftp是还有任务在后台执行，lftp将转为后台执行。   </li>
<li>其它用法<br>lftp支持类似bash的管道操作，例如用下面的命令可以将ftp服务器上的特定目录下(也可以是整个站点)所有文件的大小存到本地的文件ls.txt中<br>lftp …………….:/&gt; du incoming &gt; ls.txt<br>相关文件<br>/etc/lftp.conf<br>全局配置文件，实际位置依赖系统配置文件目录，可能在/etc，也可能在/usr/local/etc<br>~/.lftp/rc, ~/.lftprc<br>用户配置文件，将在/etc/lftp.conf之后执行，所以这里面的设置会覆盖/etc/lftp.conf中的设置。<br>lftp 缺省不会显示 ftp 服务器的欢迎信息和错误信息，这在很多时候不方便，因为你有可能想知道这个服务器到底是因为没开机连不上，还是连接数已满。如果是这样，你可以在 ~/.lftprc 里写入一行<br>debug 3<br>就可以看到出错信息了。<br>更多的配置选项请查man手册或在lftp界面内用命令 set -a 获得。<br>~/.lftp/log<br>当lftp转为后台非挂起模式执行时，输出将重定向到这里<br>~/.lftp/bookmarks<br>这是lftp存储书签的地方，可以lftp查看bookmark命令<br>~/.lftp/cwd_history<br>这个文件用来存储访问过的站点的工作目录   </li>
</ul>
<p>~/.lftprc<br>在用lftp访问国内一些ftp服务器时，往往看到的中文是乱码<br>^_^不用慌，这是由于服务器和本地编码不一致造成的。我们只要在主目录下新建一个文件~/.lftprc或者~/.lftp/rc<br>并在其中加入以下内容：<br>debug 3set ftp:charset GBKset file:charset UTF-8#set ftp:passtive-mode no#alias utf8 “ set ftp:charset UTF-8”#alias gbk “ set ftp:charset GBK”<br>登录ftp服务器<br>言归正传，我们先来看看怎么登录ftp服务器<br>lftp ftp://user:password@site:port<br>lftp user:password@site:port<br>lftp site -p port -u user,password<br>lftp site:port -u user,password<br>上面的几种方式都能正常工作，不过密码都是明文，这样好像不太安全哦。没关系<br>lftp user@site:port<br>系统会提示输入password，密码就回显为<strong>**</strong>了<br>不过每次都输入这么多，好麻烦哦。 如果有类似leapftp的站点管理器就好了，其实lftp早就给我们想好了： 这就是bookmark。后面我们将会看到。<br>常用命令<br>在终端运行<br>man lftp<br>或登录ftp后输入<br>help<br>就可以看到命令列表<br>下面我们看一下lftp常用的命令：<br>ls<br>显示远端文件列表(!ls 显示本地文件列表)。<br>cd<br>切换远端目录(lcd 切换本地目录)。<br>get<br>下载远端文件。<br>mget<br>下载远端文件(可以用通配符也就是 *)。<br>pget<br>使用多个线程来下载远端文件, 预设为五个。<br>mirror<br>下载/上传(mirror -R)/同步 整个目录。<br>put<br>上传文件。<br>mput<br>上传多个文件(支持通配符)。<br>mv<br>移动远端文件(远端文件改名)。<br>rm<br>删除远端文件。<br>mrm<br>删除多个远端文件(支持通配符)。<br>mkdir<br>建立远端目录。<br>rmdir<br>删除远端目录。<br>pwd<br>显示目前远端所在目录(lpwd 显示本地目录)。<br>du<br>计算远端目录的大小<br>!<br>执行本地 shell的命令(由于lftp 没有 lls, 故可用 !ls 来替代)<br>lcd<br>切换本地目录<br>lpwd<br>显示本地目录<br>alias<br>定义别名<br>bookmark<br>设定书签。<br>exit<br>退出ftp<br>快捷书签<br>补充作者：aBiNg<br>ftp中的bookmark命令，是将配置写到~/.lftp/bookmarks文件中；我们可以直接修改此文件，快速登陆ftp服务器。   </p>
<p>3、mirror 同步镜像，备份服务器文件</p>
<p>今天主要的问题是解决如何备份服务器端文件的问题。了解了mirror指令的用法后，发现比较适合而且好用。</p>
<p>基本使用方法：</p>
<p>1）、下载服务器端文件：</p>
<p> mirror –vn RCD LCD   //RCD为远程路径，LCD为本地路径</p>
<p>2）、上传文件：</p>
<p> mirror –R LCD RCD</p>
<p>下附一个自动同步的脚本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="shebang">#!bin/bash</span></div><div class="line"><span class="built_in">echo</span> “script start at  `date ”+%Y-%m-%d %H:%M:%S”</div><div class="line">HOST=”hostname”</div><div class="line">USER=”yourname”</div><div class="line">PASS=”password”</div><div class="line">LCD=”LocalePath”</div><div class="line">RCD=”RemotePath”</div><div class="line">/usr/sbin/lftp &lt;&lt; EOF</div><div class="line">open ftp://<span class="variable">$USER</span>:<span class="variable">$PASS</span>@<span class="variable">$HOST</span></div><div class="line">mirror <span class="variable">$RCD</span> <span class="variable">$LCD</span></div><div class="line">EOF</div><div class="line"><span class="built_in">echo</span> “script end at “ `date ”+%Y-%m-%d %H:%M:%S”</div></pre></td></tr></table></figure>

]]></content>
         
         
           
             
              <breadCrumb title="linux" url="http://blog.tinyxd.me/categories/linux/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/06/05/cannot-find-libpython/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>解决pygments.rb (RubyPython) 找不到libpython的问题(archlinux下)</title>
        <pubTime>2012-06-05T00:01:00.000Z</pubTime>
        
        <tag>ruby </tag>
         
        <tag>archlinux </tag>
         
         <content><![CDATA[<p>本文章转自：<a href="http://ruby-china.org/topics/289" target="_blank" rel="external">Ruby China 论坛</a><br>如果找不到python，或者系统默认得python是3.x (比如Arch Linux)，手动制定下路径   </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="filename">RubyPython.configure python_exe</span>: <span class="string">'/usr/bin/python2.7'</span></div></pre></td></tr></table></figure>

<p>对于rails项目比如ruby-china，可以把这行代码丢到config/initializers下。   </p>
<p>不过RubyPython仍然可能找不到libpython而提示lib.so not found。这是由于RubyPython确定正确libpython的规则和你的系统不兼容，可以通过手动加些symbol links来解决 (目前RubyPython的git最新代码相对当前稳定版本0.5.3改动非常大，希望新版本能解决这个问题，就先不去提交fixing了)。   </p>
<p>可以参考 PythonExec initialize 方法中的规则来建symbol link.<br><a id="more"></a><br>首先运行该python，得到版本号x.y，以python2.7为例   </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>python2.<span class="number">7</span> -c <span class="string">"import sys;print '%d.%d' % sys.version_info[:2]"</span></div><div class="line"><span class="output"><span class="status"></span></span></div><div class="line">=&gt; <span class="number">2.7</span></div></pre></td></tr></table></figure>

<p>找到该python对应得libpython，可以用工具ldd:   </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ ldd /usr/lib/python2.<span class="number">7</span> | <span class="keyword">grep</span> <span class="keyword">python</span></div><div class="line"></div><div class="line">=&gt; libpython2.<span class="number">7</span>.<span class="keyword">so</span>.<span class="number">1.0</span> =&gt; /usr/lib/libpython2.<span class="number">7</span>.<span class="keyword">so</span>.<span class="number">1.0</span></div></pre></td></tr></table></figure>

<p>为找到的这个文件创建链接。下面用#{exe_base}表示通过RubyPython.configure指定的python可执行程序的文件名部分，#{x}和#{y}是通过运行这个python找到得版本号，#{libpython}是该python对应得libpython库文件路径。   </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo ln -s #{<span class="ruby">libpython}</span> /usr/lib/lib#{<span class="ruby">exe_base}</span>#{<span class="ruby">x}</span>#{<span class="ruby">y}</span>.so</div><div class="line">sudo ln -s #{<span class="ruby">libpython}</span> /usr/lib/lib#{<span class="ruby">exe_base}</span>#{<span class="ruby">x}</span>.#{<span class="ruby">y}</span>.so</div></pre></td></tr></table></figure>

<p>以我的环境(Arch Linux)为例，exe_base是python2.7，版本号x.y是2.7，libpython是/usr/lib/libpython2.7.so.1.0，   </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo <span class="keyword">ln</span> -<span class="keyword">s</span> /usr/lib/libpython2.<span class="number">7</span>.<span class="keyword">so</span>.<span class="number">1.0</span> /usr/lib/libpython2.<span class="number">727</span>.<span class="keyword">so</span></div><div class="line">sudo <span class="keyword">ln</span> -<span class="keyword">s</span> /usr/lib/libpython2.<span class="number">7</span>.<span class="keyword">so</span>.<span class="number">1.0</span> /usr/lib/libpython2.<span class="number">72.7</span>.<span class="keyword">so</span></div></pre></td></tr></table></figure>

]]></content>
         
         
           
             
              <breadCrumb title="ruby" url="http://blog.tinyxd.me/categories/ruby/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/06/08/c-plus-plus-ju-bing-lei/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>读C++ Primer 之句柄类</title>
        <pubTime>2012-06-08T12:28:00.000Z</pubTime>
        
        <tag>c++ </tag>
         
        <tag>handle </tag>
         
         <content><![CDATA[<p>转自Linux社区 作者：xizero00：<a href="http://www.linuxidc.com/Linux/2011-08/40175.htm" target="_blank" rel="external">http://www.linuxidc.com/Linux/2011-08/40175.htm</a></p>
<p>我们知道C++中最令人头疼的当属指针，如果您申请了对象却没有释放它，时间一长就会造成系统崩溃，大量的内存溢出使得您的程序的健壮性出现问题</p>
<p>而句柄类就是为了能够解决这一问题而出现的，句柄类有点类似于智能指针。</p>
<p>好了，废话不多说，我们来看代码<br><a id="more"></a><br>首先我们来看 sample.h文件的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">* author:xizero00</div><div class="line">* mail:xizero00@163.com</div><div class="line">* date:2011-08-07 20:11:24</div><div class="line">* Handle Class Sample  句柄类示例</div><div class="line">*/  </div><div class="line"></div><div class="line"><span class="preprocessor">#ifndef SAMPLE_H</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> SAMPLE_H   </span></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdexcept&gt;</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </div><div class="line"></div><div class="line"><span class="comment">//基类</span></div><div class="line"><span class="keyword">class</span> Item_base</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">//基类的虚函数,用于智能地复制对象</span></div><div class="line">    <span class="keyword">virtual</span> Item_base* clone() <span class="keyword">const</span></div><div class="line">    {</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Item_base( *<span class="keyword">this</span> );</div><div class="line">    }</div><div class="line">};  </div><div class="line"></div><div class="line"><span class="comment">//子类</span></div><div class="line"><span class="keyword">class</span> Bulk_item: <span class="keyword">public</span> Item_base</div><div class="line">{</div><div class="line">    <span class="comment">//子类的虚函数的重载,用于智能地复制对象</span></div><div class="line">    <span class="keyword">virtual</span> Bulk_item* clone() <span class="keyword">const</span></div><div class="line">    {</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Bulk_item( *<span class="keyword">this</span> );</div><div class="line">    }</div><div class="line">};  </div><div class="line"></div><div class="line"><span class="comment">//子类的子类</span></div><div class="line"><span class="keyword">class</span> Sales_item: <span class="keyword">public</span> Bulk_item</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">//默认构造函数,用来初始化一个引用计数器</span></div><div class="line">    Sales_item(): p( <span class="number">0</span> ) , use( <span class="keyword">new</span> size_t( <span class="number">1</span> ) ) { <span class="built_in">cout</span> &lt;&lt; <span class="string">"Sales_item的引用计数器初始化为1"</span> &lt;&lt; endl; }  </div><div class="line"></div><div class="line">    <span class="comment">//带有一个参数的,且该参数为基类引用的构造函数</span></div><div class="line">    Sales_item( <span class="keyword">const</span> Item_base& );  </div><div class="line"></div><div class="line">    <span class="comment">//复制构造函数,需要注意的是，每复制一次就需要增加引用计数一次</span></div><div class="line">    Sales_item( <span class="keyword">const</span> Sales_item &i ): p( i.p ) , use( i.use ) { ++*use; <span class="built_in">cout</span> &lt;&lt; <span class="string">"由于采用了复制构造函数,Sales_item类型的对象引用计数为:"</span> &lt;&lt; *use &lt;&lt; endl;} <span class="comment">//也可以这样写</span></div><div class="line">    <span class="comment">//Sales_item( const Sales_item &i ): p( i.clone() ) , use( new size_t( 1 ) ) { ++*use; }   </span></div><div class="line"></div><div class="line">    <span class="comment">//析构函数,析构的时候会判断是否能够释放指针所指向的数据</span></div><div class="line">    ~Sales_item() { <span class="built_in">cout</span> &lt;&lt; <span class="string">"在析构函数中:"</span>; decr_use(); }  </div><div class="line"></div><div class="line">    <span class="comment">//赋值操作符重载</span></div><div class="line">    Sales_item& <span class="keyword">operator</span>= ( <span class="keyword">const</span> Sales_item& );  </div><div class="line"></div><div class="line">    <span class="comment">//访问操作符重载</span></div><div class="line">    <span class="keyword">const</span> Item_base* <span class="keyword">operator</span>-&gt; () <span class="keyword">const</span></div><div class="line">    {</div><div class="line">        <span class="keyword">if</span>( p )</div><div class="line">        {</div><div class="line">            <span class="keyword">return</span> p;</div><div class="line">        }</div><div class="line">        <span class="keyword">else</span></div><div class="line">        {</div><div class="line">            <span class="keyword">throw</span> logic_error( <span class="string">"p指针错误"</span> );</div><div class="line">        }</div><div class="line">    }  </div><div class="line"></div><div class="line">    <span class="comment">//解引用操作符重载</span></div><div class="line">    <span class="keyword">const</span> Item_base& <span class="keyword">operator</span>* () <span class="keyword">const</span></div><div class="line">    {</div><div class="line">        <span class="keyword">if</span>( p )</div><div class="line">        {</div><div class="line">            <span class="keyword">return</span> *p;</div><div class="line">        }</div><div class="line">        <span class="keyword">else</span></div><div class="line">        {<span class="comment">//重载虚函数,用于智能地复制对象</span></div><div class="line">            <span class="keyword">throw</span> logic_error( <span class="string">"p指针错误"</span> );</div><div class="line">        }</div><div class="line">    }  </div><div class="line"></div><div class="line">    <span class="comment">//重载虚函数,用于智能地复制对象</span></div><div class="line">    <span class="comment">/*</span></div><div class="line">    virtual Sales_item* clone() const</div><div class="line">    {</div><div class="line">        return new Sales_item( *this );</div><div class="line">    }</div><div class="line">    */  </div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="comment">//两个指针存储着引用计数器以及数据的指针</span></div><div class="line">    Item_base *p;</div><div class="line">    size_t *use;  </div><div class="line"></div><div class="line">    <span class="comment">//减少引用</span></div><div class="line">    <span class="keyword">void</span> decr_use()</div><div class="line">    {</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"在 dec_use函数中引用计数减少了,当前计数值为:"</span> &lt;&lt; *use - <span class="number">1</span> &lt;&lt; endl;</div><div class="line">        <span class="keyword">if</span>( --*use == <span class="number">0</span> )</div><div class="line">        {</div><div class="line">            <span class="keyword">delete</span> p;</div><div class="line">            <span class="keyword">delete</span> use;</div><div class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"在 dec_use函数中计数器减为0,释放对象"</span> &lt;&lt; endl;</div><div class="line">        }  </div><div class="line"></div><div class="line">    }</div><div class="line">};  </div><div class="line"></div><div class="line"><span class="comment">//赋值操作符重载,每次复制都会增加引用计数</span></div><div class="line">Sales_item& Sales_item::<span class="keyword">operator</span>= ( <span class="keyword">const</span> Sales_item &si )</div><div class="line">{</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"由于采用类赋值操作,"</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"被赋值的对象的引用计数为:"</span> &lt;&lt; *si.use ;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"即将被赋值的对象的引用计数为:"</span> &lt;&lt; *use &lt;&lt; endl;</div><div class="line">    <span class="comment">//这里需要特别注意的就是待复制的对象的计数器需要加1而被赋值的对象需要减1     </span></div><div class="line"></div><div class="line">    <span class="comment">//增加被复制对象的引用计数</span></div><div class="line">    ++*si.use;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"被赋值的对象的赋值之后的引用计数为:"</span> &lt;&lt; *si.use &lt;&lt; endl;</div><div class="line">    <span class="comment">//将即将被赋值的对象的引用计数减1</span></div><div class="line">    decr_use();</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" 即将被赋值的对象赋值之后的引用计数为:"</span> &lt;&lt; *use &lt;&lt; endl;  </div><div class="line"></div><div class="line">    <span class="comment">//复制指针</span></div><div class="line">    p = si.p;</div><div class="line">    use = si.use;  </div><div class="line"></div><div class="line">    <span class="comment">//返回</span></div><div class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">}  </div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">endif</span> <span class="comment">//SAMPLE_H</span></span></div><div class="line"></div><div class="line">接下来我们来看sample.cc的代码：</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">* author:xizero00</div><div class="line">* mail:xizero00@163.com</div><div class="line">* date:2011-08-07 20:11:24</div><div class="line">*/</div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> "sample.h"</span></div><div class="line"><span class="keyword">int</span> main( <span class="keyword">int</span> argc , <span class="keyword">char</span> **argv )</div><div class="line">{</div><div class="line">    <span class="comment">//重点关注i1和i2的引用计数</span></div><div class="line">    Sales_item i1 , i2;<span class="comment">//i1和i2的引用计数分别为1</span></div><div class="line">    Sales_item i3( i1 );<span class="comment">//i1的引用计数变为2</span></div><div class="line">    Sales_item i4 = i1;<span class="comment">//i1的引用计数变为3,因为这样还是调用的复制构造函数</span></div><div class="line">    i4 = i2; <span class="comment">// i2的引用计数变为2   </span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>下面给出编译所需的Makefile</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor"># author:xizero00</span></div><div class="line"><span class="preprocessor"># mail:xizero00@163.com</span></div><div class="line"><span class="preprocessor"># date:2011-08-08 00:51:25</span></div><div class="line">install:</div><div class="line">    g++ <span class="keyword">sample</span>.cc -g -o <span class="keyword">sample</span></div><div class="line">    ls -al <span class="keyword">sample</span>*</div><div class="line">    ./<span class="keyword">sample</span></div><div class="line">clean:</div><div class="line">    rm -f <span class="keyword">sample</span></div><div class="line">    ls -al <span class="keyword">sample</span>*</div></pre></td></tr></table></figure>

<p>注意：代码是在linux下编译，您只需要将三个文件放在同一个目录，然后在当前目录打开终端，输入make，就可以查看到结果。</p>
<p>如果您想清理生成的文件 输入make clean即可</p>
<p>下面是我执行的结果：</p>
<pre><code><span class="tag">Sales_item</span>的引用计数器初始化为1
<span class="tag">Sales_item</span>的引用计数器初始化为1
由于采用了复制构造函数,<span class="tag">Sales_item</span>类型的对象引用计数为<span class="pseudo">:2</span>
由于采用了复制构造函数,<span class="tag">Sales_item</span>类型的对象引用计数为<span class="pseudo">:3</span>
由于采用类赋值操作,被赋值的对象的引用计数为<span class="pseudo">:1</span>即将被赋值的对象的引用计数为<span class="pseudo">:3</span>
被赋值的对象的赋值之后的引用计数为<span class="pseudo">:2</span>
在 <span class="tag">dec_use</span>函数中引用计数减少了,当前计数值为<span class="pseudo">:2</span>
 即将被赋值的对象赋值之后的引用计数为<span class="pseudo">:2</span>
在析构函数中:在 <span class="tag">dec_use</span>函数中引用计数减少了,当前计数值为<span class="pseudo">:1</span>
在析构函数中:在 <span class="tag">dec_use</span>函数中引用计数减少了,当前计数值为<span class="pseudo">:1</span>
在析构函数中:在 <span class="tag">dec_use</span>函数中引用计数减少了,当前计数值为<span class="pseudo">:0</span>
在 <span class="tag">dec_use</span>函数中计数器减为0,释放对象
在析构函数中:在 <span class="tag">dec_use</span>函数中引用计数减少了,当前计数值为<span class="pseudo">:0</span>
在 <span class="tag">dec_use</span>函数中计数器减为0,释放对象
</code></pre><p>结论：我们可以看到，句柄类能够很方便并且能够很安全地释放内存，不会导致内存的泄露。</p>
]]></content>
         
         
           
             
              <breadCrumb title="software" url="http://blog.tinyxd.me/categories/software/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/06/08/dui-he-zhan-de-qu-bie/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>堆和栈的区别</title>
        <pubTime>2012-06-07T22:59:00.000Z</pubTime>
        
        <tag>heap </tag>
         
        <tag>stack </tag>
         
         <content><![CDATA[<p>出自: <a href="http://www.cnitexam.com" target="_blank" rel="external">http://www.cnitexam.com</a><br>一、预备知识—程序的内存分配</p>
<p>一个由c/C++编译的程序占用的内存分为以下几个部分</p>
<p>1、栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</p>
<p>2、堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。</p>
<p>3、全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 – 程序结束后有系统释放</p>
<p>4、文字常量区 —常量字符串就是放在这里的。 程序结束后由系统释放</p>
<p>5、程序代码区—存放函数体的二进制代码。<br><a id="more"></a></p>
<p>二、例子程序</p>
<p>这是一个前辈写的，非常详细</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//main.cpp</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdlib.h&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string.h&gt;</span></div><div class="line"><span class="keyword">int</span> a = <span class="number">0</span>;<span class="comment">// 全局初始化区</span></div><div class="line"></div><div class="line"><span class="keyword">char</span> *p1;<span class="comment">// 全局未初始化区</span></div><div class="line"></div><div class="line">main()</div><div class="line"></div><div class="line">{</div><div class="line"></div><div class="line"><span class="keyword">int</span> b;<span class="comment">// 栈</span></div><div class="line"></div><div class="line"><span class="keyword">char</span> s[] = <span class="string">"abc"</span>; <span class="comment">//栈</span></div><div class="line"></div><div class="line"><span class="keyword">char</span> *p2;<span class="comment">// 栈</span></div><div class="line"></div><div class="line"><span class="keyword">char</span> *p3 = <span class="string">"123456"</span>; <span class="comment">//123456\0在常量区，p3在栈上。</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> c =<span class="number">0</span>；<span class="comment">// 全局（静态）初始化区</span></div><div class="line"></div><div class="line">p1 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>);</div><div class="line"></div><div class="line">p2 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">20</span>);<span class="comment">//分配得来得10和20字节的区域就在堆区。</span></div><div class="line"></div><div class="line"><span class="built_in">strcpy</span>(p1, <span class="string">"123456"</span>); <span class="comment">//123456\0放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方。</span></div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>二、堆和栈的理论知识</p>
<p>2.1申请方式</p>
<p>stack:</p>
<p>由系统自动分配。 例如，声明在函数中一个局部变量 int b; 系统自动在栈中为b开辟空间</p>
<p>heap:</p>
<p>需要程序员自己申请，并指明大小，在c中malloc函数</p>
<p>如p1 = (char *)malloc(10);</p>
<p>在C++中用new运算符</p>
<p>如char *p2 =new char[10];</p>
<p>但是注意p1、p2本身是在栈中的。</p>
<p>2.2 申请后系统的响应</p>
<p>栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。</p>
<p>堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，</p>
<p>会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。</p>
<p>2.3申请大小的限制</p>
<p>栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。</p>
<p>堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</p>
<p>2.4申请效率的比较：</p>
<p>栈由系统自动分配，速度较快。但程序员是无法控制的。</p>
<p>堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.</p>
<p>另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是直接在进程的地址空间中保留一快内存，虽然用起来最不方便。但是速度快，也最灵活</p>
<p>2.5堆和栈中的存储内容</p>
<p>栈： 在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。</p>
<p>当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。</p>
<p>堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。</p>
<p>2.6存取效率的比较</p>
<p>char s1[] = “aaaaaaaaaaaaaaa”;</p>
<p>char *s2 = “bbbbbbbbbbbbbbbbb”;</p>
<p>aaaaaaaaaaa是在运行时刻赋值的；</p>
<p>而bbbbbbbbbbb是在编译时就确定的；</p>
<p>但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。</p>
<p>比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdlib.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">void</span> main()</div><div class="line"></div><div class="line">{</div><div class="line"></div><div class="line"><span class="keyword">char</span> a = <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="keyword">char</span> c[] = <span class="string">"1234567890"</span>;</div><div class="line"></div><div class="line"><span class="keyword">char</span> *p =<span class="string">"1234567890"</span>;</div><div class="line"></div><div class="line">a = c[<span class="number">1</span>];</div><div class="line"></div><div class="line">a = p[<span class="number">1</span>];</div><div class="line"></div><div class="line"><span class="keyword">return</span>;</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>对应的汇编代码</p>
<p>10: a = c[1];</p>
<p>004010678A4D F1 mov cl,byte ptr [ebp-0Fh]</p>
<p>0040106A88 4D FC mov byte ptr [ebp-4],cl</p>
<p>11: a = p[1];</p>
<p>0040106D 8B 55 EC mov edx,dword ptr [ebp-14h]</p>
<p>004010708A42 01 mov al,byte ptr [edx+1]</p>
<p>00401073 88 45 FC mov byte ptr [ebp-4],al</p>
<p>第一种在读取时直接就把字符串中的元素读到寄存器cl中，而第二种则要先把指针值读到edx中，在根据edx读取字符，显然慢了。</p>
<p>2.7小结：</p>
<p>堆和栈的区别可以用如下的比喻来看出：</p>
<p>使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。</p>
<p>使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。</p>
<p>堆和栈的区别主要分：</p>
<p>操作系统方面的堆和栈，如上面说的那些，不多说了。</p>
<p>还有就是数据结构方面的堆和栈，这些都是不同的概念。这里的堆实际上指的就是（满足堆性质的）优先队列的一种数据结构，第1个元素有最高的优先权；栈实际上就是满足先进后出的性质的数学或数据结构。</p>
<p>虽然堆栈，堆栈的说法是连起来叫，但是他们还是有很大区别的，连着叫只是由于历史的原因。</p>
]]></content>
         
         
           
             
              <breadCrumb title="software" url="http://blog.tinyxd.me/categories/software/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/06/10/qian-ru-shi-linuxying-yong-cheng-xu-zi-qi-dong/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>嵌入式linux应用程序自启动</title>
        <pubTime>2012-06-10T11:46:00.000Z</pubTime>
        
        <tag>linux </tag>
         
        <tag>embedded </tag>
         
         <content><![CDATA[<p>在很多嵌入式系统中，由于可用资源较少，常常在系统启动后就直接让应用程序自动启动，以减少用户操作和节省资源。如何让自己的应用程序自动启动呢？    在Linux系统中，配置应用程序自动启动的方法有以下三种：<br><a id="more"></a></p>
<h2 id="1-通过/Linuxrc脚本直接启动">1.通过/Linuxrc脚本直接启动</h2>
<p>Linux内核一旦开始执行，它将通过驱动程序来初始化所有硬件设备，这个初始化过程可以在启动时的PC显示器上看到，每个驱动程序都打印一些相关信息。初始化完成后，通常调用的是init，通过loader调用init内的init=/app_program语句（通过loader向核心传入init=/program可以定制首先运行的程序）。<br>比如在桌面Linux系统中，init进程会读取/etc/inittab文件，来决定执行级别和哪些脚本和命令。嵌入式应用开发中，可以根据实际情况决定是否使用标准的init执行方式，也许这个init是个静态程序，它能够完成我们的嵌入应用的特定任务，那完全不用考虑inittab了，在这里可以采用比较灵活的措施。   </p>
<h2 id="2-在/etc/init-d下添加启动脚本">2.在/etc/init.d下添加启动脚本</h2>
<p>一般情况下，大多数的Linux操作系统使用/etc/init.d/(或/etc/rc.d/init.d)下的脚本来配置应用程序的自动启动。<br>例如，在某些Linux系统中，corn程序通过/etc/init.d/corn脚本启动，Apache通过/etc/init.d/httpd启动，syslogd通过/etc/init.d/syslogd启动，而sshd则通过/etc/init.d/sshd脚本启动。<br>通常这些脚本通过来自特定rc.d目录的符号链接运行。为了配置从哪个rc.d目录运行脚本，Linux系统提供了许多不同的工具，同时也可以手工进行配置。Linux系统有一个包含所有实际启动脚本文件的目录。它可能是/etc/init.d，也可能是/etc/rc.d/rc.d。同时对应每个运行级别（runlevel）又有一个另外的目录，它们可能是/etc/rc2.d，也可能是/etc/rc.d/rc2.d。这些目录中的文件通常是指向实际脚本文件的符号链接。   </p>
<h2 id="3-直接在/etc/rc-d/rc-local脚本中添加命令">3.直接在/etc/rc.d/rc.local脚本中添加命令</h2>
<p>在Linux系统中，有一个类似Windows系统中autoexec.bat的文件，它就是/etc/rc.d/rc.local，系统开机后自动运行用户的应用程序或启动系统服务的命令保存在开发板根文件系统的这个文件中。因此可以编辑rc.local文件，将要执行的程序（命令）添加到该文件夹中。Linux系统在启动后还未登录前，将自动执行该程序（命令），达到开机自动运行用户的应用程序的目的。<br>下面具体说明：<br>首先解压ramdisk.image.gz文件，然后挂载到系统中。接着创建自己的应用程序文件夹hello，将所要自动运行的应用程序hello复制到该文件夹。<br>然后打开/usr/etc/rc.local文件，在最后一行加入：/Myapp/hello/hello<br>再按上面的顺序将ramdisk.image打包下载到目标板，启动运行，则可以看到用户编写的应用程序一启动就运行起来了。<br>本文参考《基于ARM9的嵌入式Linux开发技术》，李新峰等编著。   </p>
]]></content>
         
         
           
             
              <breadCrumb title="embedded" url="http://blog.tinyxd.me/categories/embedded/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/06/13/han-shu-ya-zhan/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>函数压栈的一些思考</title>
        <pubTime>2012-06-12T23:22:00.000Z</pubTime>
        
        <tag>stack </tag>
         
        <tag>function </tag>
         
         <content><![CDATA[<p>今天，有个同学跑过来问我一个问题fun（i，i++，++i），我立马想到这个是跟函数压栈的顺序有关的，随后去网上查找资料，并开始写了一些测试实验。</p>
<p>先把cu上的一个解释先贴上来：</p>
<p>函数调用约定（Calling Convention）<br><a id="more"></a><br>函数调用约定不仅决定了发生函数调用时函数参数的入栈顺序，还决定了是由调用者函数还是被调用函数负责清除栈中的参数，还原堆栈。函数调用约定有很多方 式，除了常见的__cdecl，__fastcall和__stdcall之外，C++的编译器还支持thiscall方式，不少C/C++编译器还支持 naked call方式。这么多函数调用约定常常令许多程序员很迷惑，到底它们是怎么回事，都是在什么情况下使用呢？下面就分别介绍这几种函数调用约定。<br>&gt;<br> <strong>1、__stdcall调用约定</strong><br>  相当于16位动态库中经常使用的PASCAL调用约定。在32位的VC++5.0中PASCAL调用约定不再被支持（实际上它已被定义为__stdcall。除了__pascal外，__fortran和__syscall也不被支持），取而代之的是__stdcall调用约定。两者实质上是一致的，即函数的参数自右向左通过栈传递，被调用的函数在返回前清理传送参数的内存栈，但不同的是函数名的修饰部分（关于函数名的修饰部分在后面将详细说明）。 <em>stdcall是Pascal程序的缺省调用方式，通常用于Win32   Api中，函数采用从右到左的压栈方式，自己在退出时清空堆栈。VC将函数编译后会在函数名前面加上下划线前缀，在函数名后加上 “@ “和参数的字节数。<br> <strong>2、C调用约定</strong><br>  （即用\</em>_cdecl关键字说明）按从右至左的顺序压参数入栈，由调用者把参数弹出栈。对于传送参数的内存栈是由调用者来维护的（正因为如此，实现可变参数的函数只能使用该调用约定）。另外，在函数名修饰约定方面也有所不同。<br> <em>cdecl是C和C＋＋程序的缺省调用方式。每一个调用它的函数都包含清空堆栈的代码，所以产生的可执行文件大小会比调用_stdcall函数的大。函数采用从右到左的压栈方式。VC将函数编译后会在函数名前面加上下划线前缀。是MFC缺省调用约定。<br>**3、\</em>_fastcall调用约定<strong><br>  是 “人 “如其名，它的主要特点就是快，因为它是通过寄存器来传送参数的（实际上，它用ECX和EDX传送前两个双字（DWORD）或更小的参数，剩下的参数仍旧自右向左压栈传送，被调用的函数在返回前清理传送参数的内存栈），在函数名修饰约定方面，它和前两者均不同。<br> _fastcall方式的函数采用寄存器传递参数，VC将函数编译后会在函数名前面加上 “@ “前缀，在函数名后加上 “@ “和参数的字节数。   
</strong>4、thiscall<strong><br>  仅仅应用于 “C++ “成员函数。this指针存放于CX寄存器，参数从右到左压。thiscall不是关键词，因此不能被程序员指定。   
 </strong>5、naked   call**<br>  采用1-4的调用约定时，如果必要的话，进入函数时编译器会产生代码来保存ESI，EDI，EBX，EBP寄存器，退出函数时则产生代码恢复这些寄存器的内容。<br>naked   call不产生这样的代码。naked   call不是类型修饰符，故必须和<em>declspec共同使用。<br>关键字\</em>_stdcall __cdecl和 __fastcall可以直接加在要输出的函数前，也可以在编译环境的Setting…\C/C++   \Code   Generation项选择。当加在输出函数前的关键字与编译环境中的选择不同时，直接加在输出函数前的关键字有效。它们对应的命令行参数分别为/Gz、/Gd和/Gr。缺省状态为/Gd，即__cdecl。<br>要完全模仿PASCAL调用约定首先必须使用__stdcall调用约定，至于函数名修饰约定，可以通过其它方法模仿。还有一个值得一提的是WINAPI宏，Windows.h支持该宏，它可以将出函数翻译成适当的调用约定，在WIN32中，它被定义为__stdcall。使用WINAPI宏可以创建自己的APIs 。<br>&gt;<br>VC的编译环境默认是使用__cdecl调用约定，也可以在编译环境的Project Setting…菜单－》C/C++ ＝》Code    Generation项选择设置函数调用约定。也可以直接在函数声明前添加关键字__stdcall、__cdecl或__fastcall等单独确定函 数的调用方式。在Windows系统上开发软件常用到WINAPI宏，它可以根据编译设置翻译成适当的函数调用约定，在WIN32中，它被定义为 __stdcall。</p>
<p>下面是华为某年的一个考题，</p>
<p>设</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> arr[]={<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>};</div><div class="line"></div><div class="line"><span class="keyword">int</span> *ptr=arr;</div><div class="line"></div><div class="line">*(ptr++)+=<span class="number">123</span>;</div><div class="line"></div><div class="line"><span class="built_in">printf</span>(＂%d,%d＂,*ptr,*(++ptr));</div></pre></td></tr></table></figure>

<p>答案为什么是：8，8</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">int</span> arr[]={<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>};</div><div class="line"></div><div class="line"><span class="keyword">int</span> *ptr=arr;<span class="comment">//现在ptr指向6</span></div><div class="line"></div><div class="line">*(ptr++)+=<span class="number">123</span>;<span class="comment">//现在ptr指向7,第一个元素变为129</span></div><div class="line"></div><div class="line"><span class="built_in">printf</span>(＂%d,%d＂,*ptr,*(++ptr)); <span class="comment">//考虑从右往左计算，先是*(++ptr)，现在ptr指向8，然后*ptr也是8，输出8，8</span></div></pre></td></tr></table></figure>

<p>嗯 虽然这样解释似乎有些道理，但是有人认为这是和编译器相关的，即，求值顺序是不定的。。也有可能出现7，8的结果。</p>
]]></content>
         
         
           
             
              <breadCrumb title="software" url="http://blog.tinyxd.me/categories/software/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/06/14/yong-newshen-qing-dong-tai-kong-jian-de-wen-ti/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>用new申请动态空间的问题</title>
        <pubTime>2012-06-13T23:27:00.000Z</pubTime>
        
        <tag>software </tag>
         
        <tag>Dynamic space </tag>
         
         <content><![CDATA[<p>先分析一下new的分配：</p>
<p>1.T*   p   =   new   T;  ···   delete   p;<br>等价于<br>T*   p   =   new   T[1]; ··· delete[]   p;</p>
<p>2.int   (*p)[n]   =   new   int[m][n];这种方式是可行的</p>
<p>3.所以new一个3x3的数组，也就是T   =   int[3][3] ，  那么可以这样写：<br>int   (<em>p)[3][3]   =   new   int[1][3][3];     删除时请调用delete[]   p;<br><a id="more"></a><br>4.int*</em> a；很容易造成内存泄漏最好不要用。</p>
<p>下面是自己写的一个test：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">int</span> main()</div><div class="line"></div><div class="line">{</div><div class="line">	size_t m=<span class="number">10</span>;</div><div class="line">	<span class="keyword">int</span> (*p)[<span class="number">10</span>]=<span class="keyword">new</span> <span class="keyword">int</span>[m][<span class="number">10</span>]();</div><div class="line">	<span class="keyword">for</span>(size_t i=<span class="number">0</span>;i!=<span class="number">10</span>;++i)</div><div class="line">		<span class="keyword">for</span>(size_t j=<span class="number">0</span>;j!=<span class="number">10</span>;++j)</div><div class="line">		{</div><div class="line">			<span class="built_in">cout</span>&lt;&lt; p[i]+j &lt;&lt;endl;</div><div class="line"></div><div class="line">		}</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(p)&lt;&lt;endl;</div><div class="line">	<span class="keyword">delete</span>  [] p;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>还有一个问题是 ，c++中new的空间地址是连续的么？？</p>
<p>由于学习过linux内核，经过分析，有些时候是虚拟地址是连续的，而物理地址是不连续的。由于在内核中需要申请连续的物理地址空间的时候，使用类似kmalloc（）的函数，这样的话，如果size比较小的话，申请成功的概率还算高（尤其是刚开机不久），而申请大内存的话就有可能申请失败。申请虚拟地址的时候用vmalloc（），这个只能确保在虚拟地址上是连续的，而不能保证在物理地址是连续的，但是这个可以申请比较大的空间。</p>
<p>而看到网上说不同的操作系统会有不同的内存管理机制，而至于windows是咋样的，还需要进一步查找资料。</p>
<p>下面是转载的如何申请连续的地址空间（c++）（<a href="http://blog.csdn.net/zhongshengjun/article/details/4632156）：" target="_blank" rel="external">http://blog.csdn.net/zhongshengjun/article/details/4632156）：</a></p>
<blockquote>
<p>   地址连续的二维数组在C语言数值计算中有重要意义，很多二维数组的算法是基于一维数组写的。另外，在序列化时或内存复制时，连续空间易于进行整块内存的操作。</p>
<p>   子程序说明：</p>
<p>   1- Array2D和FreeArray2D可实现地址连续的动态二维数组的地址分配和释放。</p>
<p>  2- 作为对照，下面给出了地址不连续的二维数组地址分配与释放的子程序。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建 n X m 的动态数组，该数组的元素地址在内存中是连续的</span></div><div class="line"><span class="comment">// n - 输入参数，数组的行数</span></div><div class="line"><span class="comment">// m - 输入参数，数组的列数</span></div><div class="line"><span class="comment">// 返回，double **，指向指针的指针，用于以二维数组的方式访问一段内存。</span></div><div class="line"><span class="keyword">double</span> **Array2D(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</div><div class="line">{</div><div class="line"> <span class="comment">// 建立数组的存储区，即在内存中分配一片连续的空间，元素个数为 n*m，</span></div><div class="line"> <span class="comment">// 返回指向double的指针。</span></div><div class="line">    <span class="keyword">double</span> *Array1D=<span class="keyword">new</span> <span class="keyword">double</span>[n*m];</div><div class="line"> <span class="comment">// 建立数组的索引区，返回指向 double *的指针（指向指针的指针），长度为 n。</span></div><div class="line">    <span class="keyword">double</span> **Array2D=<span class="keyword">new</span> <span class="keyword">double</span>* [n];</div><div class="line"> <span class="comment">// 将索引区的每个元素指向数据存储区对应元素的地址，Array2D[0] 指向 Array1D[0]，</span></div><div class="line"> <span class="comment">// Array2D[1] 指向 Array1D[m]，其余类推。</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">    {</div><div class="line">     Array2D[i]=&Array1D[i*m];</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> Array2D;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 释放数组的空间，首先释放一维数组占用的n*m个double空间</span></div><div class="line"><span class="comment">// 再释放索引数组（指针数组）占用的n个double*空间</span></div><div class="line"> <span class="keyword">void</span> FreeArray2D(<span class="keyword">double</span> **Array2D)</div><div class="line">{</div><div class="line">  <span class="keyword">delete</span>[] Array2D[<span class="number">0</span>];</div><div class="line">  <span class="keyword">delete</span>[] Array2D;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 二维数组空间分配，地址一般不连续，不是推荐的方法</span></div><div class="line"> <span class="keyword">double</span> **Array2D_A(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</div><div class="line">{</div><div class="line"> <span class="comment">// 建立数组的索引区，返回指向 double *的指针（指向指针的指针），长度为 n。</span></div><div class="line">    <span class="keyword">double</span> **Array2D=<span class="keyword">new</span> <span class="keyword">double</span>* [n];</div><div class="line"></div><div class="line"> <span class="comment">// 建立数组的存储区，对于Array2D的每一个指针元素，分配m个double空间</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">     Array2D[i]=<span class="keyword">new</span> <span class="keyword">double</span>[m];</div><div class="line"></div><div class="line">    <span class="keyword">return</span> Array2D;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 释放数组的空间，与Array2D_A配套使用</span></div><div class="line"></div><div class="line"><span class="comment">// 首先释放n个一维数组（每个占用m个double空间）</span></div><div class="line"><span class="comment">// 再释放索引数组（指针数组）占用的n个double*空间</span></div><div class="line"> <span class="keyword">void</span> FreeArray2D_A(<span class="keyword">double</span> **Array2D,<span class="keyword">int</span> n)</div><div class="line">{</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">    <span class="keyword">delete</span>[] Array2D[i];</div><div class="line">  <span class="keyword">delete</span>[] Array2D;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>&gt;</p>
]]></content>
         
         
           
             
              <breadCrumb title="software" url="http://blog.tinyxd.me/categories/software/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/06/18/debianan-zhuang-nvidiaxian-qia-qu-dong/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>debian安装nvidia显卡驱动</title>
        <pubTime>2012-06-18T12:31:00.000Z</pubTime>
        
        <tag>linux </tag>
         
        <tag>debian </tag>
         
        <tag>nvidia </tag>
         
        <tag>Graphics driver </tag>
         
         <content><![CDATA[<p>在自己的电脑上硬盘安装了Debian.下面介绍一下我是如何安装显卡驱动的.我的显卡是GForce 7100GS的.</p>
<p>1&gt;下载显卡驱动.</p>
<p>这个可以到Nvidia的官网上去找,找到自己对应的版本就可以了。</p>
<p>2&gt;安装gcc并设置版本.  </p>
<p>#apt-get install gcc 这样安装的是gcc-4.4,如果在安装过程中提示您安装的gcc版本有问题,你可以再安装一下gcc-4.3并将gcc版本设置为4.3,具体做法:</p>
<p>#apt-get install gcc-4.3</p>
<p>#ln -sf /usr/bin/gcc-4.3 /usr/bin/gcc 这一句用来将gcc的版本设置为4.3</p>
<p>#ls -l /usr/bin/gcc* 这一句用来查看当前使用的gcc版本<br><a id="more"></a><br>3&gt;安装make</p>
<p>#apt-get install make</p>
<p>4&gt;安装编译头文件</p>
<p>#apt-get install build-essential linux-headers-$(uname -r)</p>
<p>5&gt;编辑 /boot/gurb/grub.cfg</p>
<p>在linux /vmlinuz -2.6.32-5………quite 后面加上 nomodeset  (作用是将原来普适的显卡驱动禁用)</p>
<p>6&gt;进入字符界面 Ctrl+Alt+F1</p>
<p>7&gt;停用X-Server:</p>
<p>#/etc/init.d/gdm3 stop</p>
<p>8&gt;安装显卡驱动:</p>
<p> # sh …. (省略号部分为你下载的显卡驱动的名称) 你将会看到安装的进度条.</p>
<p>9&gt;#startx</p>
]]></content>
         
         
           
             
              <breadCrumb title="linux" url="http://blog.tinyxd.me/categories/linux/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/06/19/learn-php/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>php初学</title>
        <pubTime>2012-06-19T12:28:00.000Z</pubTime>
        
        <tag>php </tag>
         
         <content><![CDATA[<p>1.搭建学习环境 采用简单的打包好的：lamp.<br><a href="https://help.ubuntu.com/community/ApacheMySQLPHP#Run.2C_Stop.2C_Test.2C_And_Restart_Apache" target="_blank" rel="external">help web sites</a></p>
<p>2.PHP中文手册<br><a href="http://www.phpchina.com/resource/manual/phpnew/" target="_blank" rel="external">http://www.phpchina.com/resource/manual/phpnew/</a><br><a id="more"></a><br>example：<br>第一个 PHP 脚本：hello.php   </p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line"> &lt;head&gt;</div><div class="line">  &lt;title&gt;PHP 测试&lt;/title&gt;</div><div class="line"> &lt;/head&gt;</div><div class="line"> &lt;body&gt;</div><div class="line"> <span class="preprocessor">&lt;?php</span> <span class="keyword">echo</span> <span class="string">'&lt;p&gt;Hello World</span></div><div class="line">'; <span class="preprocessor">?&gt;</span></div><div class="line"> &lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>

<p>PHP基本语法：   </p>
<p>四种标量类型：   </p>
<ul>
<li>boolean （布尔型）</li>
<li>integer （整型）</li>
<li>float （浮点型, 也称作 double)</li>
<li>string （字符串） </li>
</ul>
<p>两种复合类型：</p>
<ul>
<li>array （数组）</li>
<li>object （对象） </li>
</ul>
<p>最后是两种特殊类型：</p>
<ul>
<li>resource　（资源）</li>
<li>NULL　（NULL） </li>
</ul>
<p>为了确保代码的易读性，本手册还介绍了一些伪类型：</p>
<ul>
<li>mixed</li>
<li>number</li>
<li>callback </li>
</ul>
]]></content>
         
         
           
             
              <breadCrumb title="php" url="http://blog.tinyxd.me/categories/php/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/06/19/seo-meta-octopress/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>给octopress添加关键字和网站描述</title>
        <pubTime>2012-06-19T13:10:00.000Z</pubTime>
        
        <tag>octopress </tag>
         
        <tag>meta </tag>
         
        <tag>seo </tag>
         
         <content><![CDATA[<p>给octopress添加keywords和description。   </p>
<p>1.修改source/_includes/head.html   </p>
<script src="https://gist.github.com/2460469.js?file="></script><br>2.在_config.yml中添加如下内容<br><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">description</span>: <span class="string">Keen on the software programming and Embedded development.（专注软件编程及嵌入式技术。）</span></div><div class="line"><span class="attribute">keywords</span>: <span class="string">ruby , linux , archlinux , debian , software ,programming , embedded ,gem,web development ,ubuntu , java</span></div></pre></td></tr></table></figure>

<p>3.这样在主页代码中也会出现keywords和description信息。每个post也会出现。方便被搜索网站索引。这个涉及到了SEO。<br>以上文章参考自<a href="http://www.yatishmehta.in/seo-for-octopress" target="_blank" rel="external">这里</a>。</p>
]]></content>
         
         
           
             
              <breadCrumb title="octopress" url="http://blog.tinyxd.me/categories/octopress/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/06/25/octopress-add-tag-cloud/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>octopress博客添加标签云</title>
        <pubTime>2012-06-24T16:35:00.000Z</pubTime>
        
        <tag>octopress </tag>
         
        <tag>tag cloud </tag>
         
         <content><![CDATA[<p>折腾了好久，终于弄好了。我基本是follow这篇文章的：<a href="http://log4d.com/2012/05/tag-cloud/" target="_blank" rel="external">给 Octopress 加上标签功能</a><br>官方只提供了category的云显示，和列表显示，这是其<a href="https://github.com/tokkonopapa/octopress-tagcloud" target="_blank" rel="external">github地址</a>，其实官方提供的这个第三方插件并没有给文章加入tag的概念。（category和tag分别代表日志分类和标签）<br><a id="more"></a><br>现在我还对ruby不是很熟悉，但是看到了<a href="http://log4d.com/2012/05/tag-cloud/" target="_blank" rel="external">这篇文章</a>，找到了<a href="https://github.com/robbyedwards/octopress-tag-pages" target="_blank" rel="external">robbyedwards / octopress-tag-pages</a>和<a href="https://github.com/robbyedwards/octopress-tag-cloud" target="_blank" rel="external">robbyedwards / octopress-tag-cloud</a>。前者采集文章的tag，后者是标签云的显示。<br>这两个使用方法相同，把文件放到相应的目录即可。而第二个插件<code>octopress-tag-cloud</code> 会和官方的有冲突，直接用<a href="https://github.com/alswl/octopress-category-list" target="_blank" rel="external">这个</a>就好。<br>还有最后一点非常重要，得修改两个地方：<br>一个是sass/custom/_styles.scss</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="id">#content</span> <span class="tag">article</span> <span class="class">.cloud</span> <span class="tag">li</span><span class="rules">{</span></div><div class="line">  <span class="rule"><span class="attribute">display</span>:<span class="value"> inline</span></span>;</div><div class="line">  <span class="rule"><span class="attribute">list-style</span>:<span class="value"> none outside none</span></span>;</div><div class="line">  <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">0</span> <span class="number">4px</span></span></span>;</div><div class="line"><span class="rule">}</span></div></pre></td></tr></table></figure>


<p>然后把显示tagcloud的页面 class改为cloud(class=”cloud”)。<br>大功告成，tag cloud页面请点击<a href="http://tinyxd.me/tags/index.html" target="_blank" rel="external">这里</a>。</p>
]]></content>
         
         
           
             
              <breadCrumb title="octopress" url="http://blog.tinyxd.me/categories/octopress/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/06/27/straight-insertion-sort/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>排序算法总结（一）</title>
        <pubTime>2012-06-27T00:00:00.000Z</pubTime>
        
        <tag>c++ </tag>
         
        <tag>software </tag>
         
        <tag>sort </tag>
         
         <content><![CDATA[<p>排序算法是在学习数据结构的过程中，必须熟练掌握的。而由于其算法种类比较多，所以总结一下还是有必要的。今天先把插入排序总结下。<br>插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n^2)。是稳定的排序方法。   </p>
<h2 id="直接插入排序(straight_insertion_sort)">直接插入排序(straight insertion sort)</h2>
<p>每次从无序表中取出第一个元素，把它插入到有序表的合适位置，使有序表仍然有序。<br>C/C++代码实现直接插入排序：    </p>
<figure class="highlight c++"><figcaption><span>插入排序代码(straight insertion sort)</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> insert_sort(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</div><div class="line">{</div><div class="line">	<span class="keyword">int</span> i, j, temp;</div><div class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; ++i)</div><div class="line">	{</div><div class="line">		temp = a[i];</div><div class="line">		<span class="keyword">for</span> (j = i; j&gt;<span class="number">0</span> && temp &lt; a[j - <span class="number">1</span>]; --j)</div><div class="line">		{</div><div class="line">			a[j] = a[j - <span class="number">1</span>];</div><div class="line">		}</div><div class="line">		a[j] = temp;</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p><a id="more"></a></p>
<h2 id="希尔排序_(shell_sort)">希尔排序 (shell sort)</h2>
<p>概念：先取一个小于n（待排序的数据个数）的整数d1作为第一个增量，把文件的全部记录分成d1个组。把所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序，然后，取第二个增量d2&lt;d1重复上述的分组和排序，直至所取的增量dt=1（dt&lt;dt-1&lt;…&lt;d2&lt;d1），即所有记录放在同一组中进行直接插入排序为止。该方法实质上是一种分组直接插入方法。    </p>
<figure class="highlight c++"><figcaption><span>希尔排序(shell sort)</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//希尔排序</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> LEN 8</span></div><div class="line"><span class="keyword">void</span> main (<span class="keyword">void</span>)</div><div class="line">{</div><div class="line">	<span class="keyword">int</span> d=LEN;</div><div class="line">	<span class="keyword">int</span> R[LEN]={<span class="number">76</span>,<span class="number">81</span>,<span class="number">50</span>,<span class="number">22</span>,<span class="number">98</span>,<span class="number">33</span>,<span class="number">12</span>,<span class="number">79</span>};</div><div class="line">	<span class="keyword">int</span> i,j,t=<span class="number">1</span>,temp;</div><div class="line">	<span class="keyword">while</span>(d&gt;<span class="number">0</span>)</div><div class="line">	{</div><div class="line">	d/=<span class="number">2</span>;</div><div class="line">	<span class="keyword">if</span>(d&gt;<span class="number">0</span>)</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>;y&lt;d ;y++)</div><div class="line">	{</div><div class="line">		<span class="keyword">for</span>(i=(d+y);i&lt;LEN;i=(i+d))</div><div class="line">		{</div><div class="line">			<span class="keyword">if</span>(R[i]&lt;R[i-d])</div><div class="line">			{</div><div class="line">				temp=R[i];</div><div class="line">				j=i-d;</div><div class="line">				<span class="keyword">do</span>{</div><div class="line">					<span class="built_in">printf</span>(<span class="string">"%d -&gt; %d,"</span>,R[j],R[j+d]);</div><div class="line">					R[j+d]=R[j];</div><div class="line">					j=j-d;</div><div class="line">				}<span class="keyword">while</span>(j&gt;=<span class="number">0</span> && temp &lt;R[j]);</div><div class="line">				<span class="built_in">printf</span>(<span class="string">"%d -&gt; %d"</span>,temp,R[j+d]);</div><div class="line">				R[j+d] = temp;</div><div class="line">			}</div><div class="line">			<span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">0</span>;a&lt;LEN;a++)</div><div class="line">			{</div><div class="line">				<span class="built_in">printf</span>(<span class="string">"%d"</span>,R[a]);</div><div class="line">			}</div><div class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,y+<span class="number">1</span>);</div><div class="line">			<span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">			}</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>


<p>下一节更新交换排序。   </p>
]]></content>
         
         
           
             
              <breadCrumb title="software" url="http://blog.tinyxd.me/categories/software/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/06/27/swap-sort/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>排序算法总结（二）</title>
        <pubTime>2012-06-27T12:50:00.000Z</pubTime>
        
        <tag>c++ </tag>
         
        <tag>software </tag>
         
        <tag>sort </tag>
         
         <content><![CDATA[<p>昨天总结了插入排序，今天总结交换排序。<br>交换排序是一种主要以交换的方式对序列进行排序的方法。排序的基本方法或手段主要就是比较和交换，像选择法等都借助了交换的手段，但都不是主要以交换为手段，如在直接选择排序的时候，一轮比较就能确定最大元素的位置，最后再进行交换。交换排序被公认为“稳定”的排序方法。    </p>
<h2 id="冒泡排序">冒泡排序</h2>
<p>冒泡排序，是指计算机的一种排序方法，它的时间复杂度为O（ n^2 ），虽然不及堆排序、快速排序的O（nlog n，底数为2），但是有两个优点：<br><a id="more"></a> </p>
<ol>
<li>“编程复杂度”很低，很容易写出代码；   </li>
<li>具有稳定性，这里的稳定性是指原序列中相同元素的相对顺序仍然保持到排序后的序列，而堆排序、快速排序均不具有稳定性。不过，一路、二路归并排序、不平衡二叉树排序的速度均比冒泡排序快，且具有稳定性，但速度不及堆排序、快速排序。<br>冒泡排序（BubbleSort）的基本概念是：依次比较相邻的两个数，将小数放在前面，大数放在后面。即在第一趟：首先比较第1个和第2个数，将小数放前，大数放后。然后比较第2个数和第3个数，将小数放前，大数放后，如此继续，直至比较最后两个数，将小数放前，大数放后。至此第一趟结束，将最大的数放到了最后。在第二趟：仍从第一对数开始比较（因为可能由于第2个数和第3个数的交换，使得第1个数不再小于第2个数），将小数放前，大数放后，一直比较到倒数第二个数（倒数第一的位置上已经是<br>最大的），第二趟结束，在倒数第二的位置上得到一个新的最大数（其实在整个数列中是第二大的数）。如此下去，重复以上过程，直至最终完成排序。<br>由于在排序过程中总是小数往前放，大数往后放，相当于气泡往上升，所以称作冒泡排序。<br>若记录序列的初始状态为”正序”，则冒泡排序过程只需进行一趟排序，在排序过程中只需进行n-1次比较，且不移动记录；反之，若记录序列的初始状态为”逆序”，则需进行n(n-1）/2次比较和记录移动。因此冒泡排序总的时间复杂度为O(n*n)。    <h2 id="快速排序（不稳定）">快速排序（不稳定）</h2>
快速排序（Quicksort）是对冒泡排序的一种改进。由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。    </li>
</ol>
<figure class="highlight c++"><figcaption><span>C++，快速排续</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//C++，快速排序</span></div><div class="line"></div><div class="line"><span class="keyword">void</span> sort(<span class="keyword">int</span> *a,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</div><div class="line">{</div><div class="line">	<span class="keyword">int</span> i=left,j=right;</div><div class="line">	<span class="keyword">int</span> k=a[left];</div><div class="line">	<span class="keyword">if</span>(left&gt;=right) <span class="keyword">return</span> ;</div><div class="line">	<span class="keyword">while</span>(i!=j)</div><div class="line">	{</div><div class="line">		<span class="keyword">while</span>(i&lt;j&& a[j]&gt;=k) j--;</div><div class="line">		a[i]=a[j];</div><div class="line">		<span class="keyword">while</span>(i&lt;j&& a[i]&lt;=k) i++;</div><div class="line">		a[j]=a[i];</div><div class="line">	}</div><div class="line">	a[i]=k;</div><div class="line">	sort(a,left,i-<span class="number">1</span>);</div><div class="line">	sort(a,i+<span class="number">1</span>,right);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>下一节更新选择排序。   </p>
]]></content>
         
         
           
             
              <breadCrumb title="software" url="http://blog.tinyxd.me/categories/software/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/06/28/select-sort/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>排序算法总结（三）</title>
        <pubTime>2012-06-28T04:38:00.000Z</pubTime>
        
        <tag>c++ </tag>
         
        <tag>software </tag>
         
        <tag>sort </tag>
         
         <content><![CDATA[<p>选择排序是指在每次排序时，选择最大或者最小项，将其放入适当的位置上，反复操作，直到所有数据排序完成为止。选择排序是一类比较常见的排序，现实生活中也比较常见，比如一个班级的学生排队，先将最高的学生排到队首，然后在其他学生中再挑出最高的一个，排在第二的位置，以此类推，直到全部排完。  </p>
<p>选择排序的交换操作介于 0 和 ( n - 1 ) 次之间。选择排序的比较操作为 n ( n - 1 ) / 2 次之间。选择排序的赋值操作介于 0 和 3 ( n - 1 ) 次之间。 比较次数O（  n^2 ）,比较次数与关键字的初始状态无关，总的比较次数N=(n-1)+(n-2)+…+1=n*(n-1)/2。 交换次数O(n),最好情况是，已经有序，交换0次；最坏情况是，逆序，交换n-1次。 交换次数比冒泡排序少多了，由于交换所需CPU时间比比较所需的CPU时间多，n值较小时，选择排序比冒泡排序快。    </p>
<h2 id="直接选择排序（不稳定）">直接选择排序（不稳定）</h2>
<figure class="highlight c++"><figcaption><span>直接选择排序</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> SelectSort(elemtype R[], <span class="keyword">int</span> n)</div><div class="line">{</div><div class="line">	<span class="keyword">int</span> i, j, m;</div><div class="line">	elemtype t;</div><div class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n-<span class="number">1</span>; i++)</div><div class="line">	{</div><div class="line">		m = i;</div><div class="line">		<span class="keyword">for</span>(j = i+<span class="number">1</span>; j &lt; n; j++)</div><div class="line">		{</div><div class="line">			<span class="keyword">if</span>(R[j] &lt; R[m])</div><div class="line">			m = j;</div><div class="line">		}</div><div class="line">		<span class="keyword">if</span>(m != i)</div><div class="line">		{</div><div class="line">			t = R[i];</div><div class="line">			R[i] = R[m];</div><div class="line">			R[m] = t;</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p><a id="more"></a></p>
<h2 id="堆排序(Heapsort)">堆排序(Heapsort)</h2>
<h3 id="“堆”定义">“堆”定义</h3>
<p>树中任一非叶结点的关键字均不大于（或不小于）其左右孩子（若存在）结点的关键字。   </p>
<h3 id="堆的高度">堆的高度</h3>
<p>堆可以被看成是一棵树，结点在堆中的高度可以被定义为从本结点到叶子结点的最长简单下降路径上边的数目；定义堆的高度为树根的高度。我们将看到，堆结构上的一些基本操作的运行时间至多是与树的高度成正比，为O（lgn）。   </p>
<h3 id="堆排序思想">堆排序思想</h3>
<p>堆排序利用了大根堆（或小根堆）堆顶记录的关键字最大（或最小）这一特征，使得在当前无序区中选取最大（或最小）关键字的记录变得简单。<br>（1）用大根堆排序的基本思想<br>① 先将初始文件R[1..n]建成一个大根堆，此堆为初始的无序区<br>② 再将关键字最大的记录R[1]（即堆顶）和无序区的最后一个记录R[n]交换，由此得到新的无序区R[1..n-1]和有序区R[n]，且满足R[1..n-1].keys≤R[n].key<br>③由于交换后新的根R[1]可能违反堆性质，故应将当前无序区R[1..n-1]调整为堆。然后再次将R[1..n-1]中关键字最大的记录R[1]和该区间的最后一个记录R[n-1]交换，由此得到新的无序区R[1..n-2]和有序区R[n-1..n]，且仍满足关系R[1..n-2].keys≤R[n-1..n].keys，同样要将R[1..n-2]调整为堆。<br>……</p>
<p>直到无序区只有一个元素为止。<br>（2）大根堆排序算法的基本操作：<br>① 初始化操作：将R[1..n]构造为初始堆；<br>② 每一趟排序的基本操作：将当前无序区的堆顶记录R[1]和该区间的最后一个记录交换，然后将新的无序区调整为堆（亦称重建堆）。<br>注意：<br>①只需做n-1趟排序，选出较大的n-1个关键字即可以使得文件递增有序。 ②用小根堆排序与利用大根堆类似，只不过其排序结果是递减有序的。堆排序和直接选择排序相反：在任何时刻堆排序中无序区总是在有序区之前，且有序区是在原向量的尾部由后往前逐步扩大至整个向量为止。   </p>
<h3 id="特点">特点</h3>
<p>堆排序（HeapSort）是一树形选择排序。堆排序的特点是：在排序过程中，将R[l..n]看成是一棵完全二叉树的顺序存储结构，利用完全二叉树中双亲结点和孩子结点之间的内在关系（参见二叉树的顺序存储结构），在当前无序区中选择关键字最大（或最小）的记录   </p>
<h3 id="堆排序与直接选择排序的区别">堆排序与直接选择排序的区别</h3>
<p>直接选择排序中，为了从R[1..n]中选出关键字最小的记录，必须进行n-1次比较，然后在R[2..n]中选出关键字最小的记录，又需要做n-2次比较。事实上，后面的n-2次比较中，有许多比较可能在前面的n-1次比较中已经做过，但由于前一趟排序时未保留这些比较结果，所以后一趟排序时又重复执行了这些比较操作。<br>堆排序可通过树形结构保存部分比较结果，可减少比较次数。   </p>
<h3 id="算法分析">算法分析</h3>
<p>堆排序的时间，主要由建立初始堆和反复重建堆这两部分的时间开销构成，它们均是通过调用Heapify实现的。堆排序的最坏时间复杂度为O(nlogn)。堆序的平均性能较接近于最坏性能。由于建初始堆所需的比较次数较多，所以堆排序不适宜于记录数较少的文件。堆排序是就地排序，辅助空间为O(1），它是<strong>不稳定</strong>的排序方法。   </p>
<figure class="highlight c"><figcaption><span>堆排序c语言实现</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//C语言描述</span></div><div class="line"><span class="comment">// array是待调整的堆数组，i是待调整的数组元素的位置，nlength是数组的长度</span></div><div class="line"><span class="keyword">void</span> HeapAdjust(<span class="keyword">int</span> <span class="built_in">array</span>[],<span class="keyword">int</span> i,<span class="keyword">int</span> nLength)<span class="comment">//本函数功能是：根据数组array构建大根堆</span></div><div class="line">{</div><div class="line">	<span class="keyword">int</span> nChild;</div><div class="line">	<span class="keyword">int</span> nTemp;</div><div class="line">	<span class="keyword">for</span> (nTemp = <span class="built_in">array</span>[i]; <span class="number">2</span> * i + <span class="number">1</span> &lt; nLength; i = nChild)</div><div class="line">	{</div><div class="line">		<span class="comment">// 子结点的位置=2*（父结点位置）+ 1</span></div><div class="line">		nChild = <span class="number">2</span> * i + <span class="number">1</span>;</div><div class="line">		<span class="comment">// 得到子结点中较大的结点</span></div><div class="line">		<span class="keyword">if</span> (nChild &lt; nLength - <span class="number">1</span> && <span class="built_in">array</span>[nChild + <span class="number">1</span>] &gt; <span class="built_in">array</span>[nChild])</div><div class="line">		++nChild;</div><div class="line">		<span class="comment">// 如果较大的子结点大于父结点那么把较大的子结点往上移动，替换它的父结点</span></div><div class="line">		<span class="keyword">if</span> (nTemp &lt; <span class="built_in">array</span>[nChild])</div><div class="line">		{</div><div class="line">		<span class="built_in">array</span>[i]= <span class="built_in">array</span>[nChild];</div><div class="line">		}</div><div class="line">		<span class="keyword">else</span> <span class="comment">// 否则退出循环</span></div><div class="line">		{</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">		}</div><div class="line">		<span class="comment">// 最后把需要调整的元素值放到合适的位置</span></div><div class="line">		<span class="built_in">array</span>[nChild]= nTemp;</div><div class="line">	}</div><div class="line">}</div><div class="line">	<span class="comment">// 堆排序算法</span></div><div class="line"><span class="keyword">void</span> HeapSort(<span class="keyword">int</span> <span class="built_in">array</span>[],<span class="keyword">int</span> length)</div><div class="line">{</div><div class="line">	<span class="comment">// 调整序列的前半部分元素，调整完之后第一个元素是序列的最大的元素</span></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</div><div class="line">	{</div><div class="line">	HeapAdjust(<span class="built_in">array</span>,i,length);</div><div class="line">	}</div><div class="line">	<span class="comment">// 从最后一个元素开始对序列进行调整，不断的缩小调整的范围直到第一个元素</span></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i)</div><div class="line">	{</div><div class="line">	<span class="comment">// 把第一个元素和当前的最后一个元素交换，</span></div><div class="line">	<span class="comment">// 保证当前的最后一个位置的元素都是在现在的这个序列之中最大的</span></div><div class="line">	Swap(&<span class="built_in">array</span>[<span class="number">0</span>],&<span class="built_in">array</span>[i]);</div><div class="line">	<span class="comment">// 不断缩小调整heap的范围，每一次调整完毕保证第一个元素是当前序列的最大值</span></div><div class="line">	HeapAdjust(<span class="built_in">array</span>,<span class="number">0</span>,i);</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>



<figure class="highlight c++"><figcaption><span>堆排序算法（c++描述）</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//堆排序算法（C++描述）</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> MAX 100<span class="comment">//数据元素的最大个数</span></span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></div><div class="line">{</div><div class="line">	<span class="keyword">int</span> r[MAX];</div><div class="line">	<span class="keyword">int</span> length;</div><div class="line">}SqList;<span class="comment">//定义一个线性表用于存放数据元素</span></div><div class="line"><span class="keyword">void</span> HeapAdjust(SqList &L,<span class="keyword">int</span> s,<span class="keyword">int</span> m)</div><div class="line">{</div><div class="line">	<span class="comment">//已知L.r[s...m]中记录除L.r[s]外均满足堆的定义，本函数用于使L.r[s...m]成为一个大顶堆</span></div><div class="line">	<span class="keyword">int</span> j;</div><div class="line">	<span class="keyword">int</span> e=L.r[s];</div><div class="line">	<span class="keyword">for</span>(j=<span class="number">2</span>*s;j&lt;=m;j*=<span class="number">2</span>)</div><div class="line">	{</div><div class="line">		<span class="keyword">if</span>(j&lt;M&&L.R[J]&lt;L.R[J+<span class="number">1</span>]) ++j;</div><div class="line">		<span class="keyword">if</span>(e&gt;=L.r[j]) <span class="keyword">break</span>;</div><div class="line">		L.r[s]=L.r[j];</div><div class="line">		s=j;</div><div class="line">	}</div><div class="line">	L.r[s]=e;</div><div class="line">}</div><div class="line"><span class="keyword">void</span> HeapSort(SqList &L)</div><div class="line">{</div><div class="line">	<span class="comment">//对顺序表L进行堆排序</span></div><div class="line">	<span class="keyword">int</span> i,e;</div><div class="line">	<span class="keyword">for</span>(i=L.length/<span class="number">2</span>;i&gt;<span class="number">0</span>;i--)</div><div class="line">	HeapAdjust(L,i,L.length);</div><div class="line">	<span class="keyword">for</span>(i=L.length;i&gt;<span class="number">1</span>;i--)</div><div class="line">	{</div><div class="line">		<span class="comment">//将大顶堆的顶记录和最后一个记录相互交换</span></div><div class="line">		e=L.r[<span class="number">1</span>];</div><div class="line">		L.r[<span class="number">1</span>]=L.r[i];</div><div class="line">		L.r[i]=e;</div><div class="line">		HeapAdjust(L,<span class="number">1</span>,i-<span class="number">1</span>);</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>


<p>下一节更新基数排序。   </p>
]]></content>
         
         
           
             
              <breadCrumb title="software" url="http://blog.tinyxd.me/categories/software/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/06/29/radix-sort/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>排序算法总结（四）</title>
        <pubTime>2012-06-29T15:28:00.000Z</pubTime>
        
        <tag>c++ </tag>
         
        <tag>software </tag>
         
        <tag>sort </tag>
         
         <content><![CDATA[<p>“基数排序法”属于“分配式排序”（distribution sort），基数排序法又称“桶子法”（bucket sort）或bin sort ，它是通过键值的部分资讯，将要排序的元素分配至某些“桶”中，借以达到排序的作用。基数排序法是属于稳定性的排序，其时间复杂度为O（nlog(r)m），其中r为所采用的基数，而m为堆数。在某些时候，基数排序法的效率高于其他的比较性排序。<br>什么是基数排序： 基数排序也称桶排序，是一种当关键字为整数类型时的一种非常高效的排序方法。基数排序算法进出桶中的数据元素序列满足先进先出的原则（桶实际就是队列）。<br><a id="more"></a></p>
<h3 id="c语言实现基数排序">c语言实现基数排序</h3>
<figure class="highlight c"><figcaption><span>c语言实现基数排序</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdlib.h&gt;</span></div><div class="line"><span class="keyword">int</span> main()</div><div class="line">{</div><div class="line">	<span class="keyword">int</span> data[<span class="number">10</span>]={<span class="number">73</span>,<span class="number">22</span>,<span class="number">93</span>,<span class="number">43</span>,<span class="number">55</span>,<span class="number">14</span>,<span class="number">28</span>,<span class="number">65</span>,<span class="number">39</span>,<span class="number">81</span>};</div><div class="line">	<span class="keyword">int</span> temp[<span class="number">10</span>][<span class="number">10</span>]={<span class="number">0</span>};</div><div class="line">	<span class="keyword">int</span> order[<span class="number">10</span>]={<span class="number">0</span>};</div><div class="line">	<span class="keyword">int</span> i,j,k,n,lsd;</div><div class="line">	k=<span class="number">0</span>;n=<span class="number">1</span>;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"\n排序前: "</span>);</div><div class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,data[i]);</div><div class="line">	<span class="built_in">putchar</span>(<span class="string">'\n'</span>);</div><div class="line">	<span class="keyword">while</span> (n&lt;=<span class="number">10</span>)</div><div class="line">	{</div><div class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++){</div><div class="line">		lsd=((data[i]/n)%<span class="number">10</span>);</div><div class="line">		temp[lsd][order[lsd]]=data[i];</div><div class="line">		order[lsd]++;</div><div class="line">		}</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"\n重新排列: "</span>);</div><div class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++){</div><div class="line">			<span class="keyword">if</span>(order[i]!=<span class="number">0</span>)</div><div class="line">			<span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;order[i];j++){</div><div class="line">				data[k]=temp[i][j];</div><div class="line">				<span class="built_in">printf</span>(<span class="string">"%d "</span>,data[k]);</div><div class="line">				k++;</div><div class="line">			}</div><div class="line">			order[i]=<span class="number">0</span>;</div><div class="line">		}</div><div class="line">		n*=<span class="number">10</span>;</div><div class="line">		k=<span class="number">0</span>;</div><div class="line">	}</div><div class="line">	<span class="built_in">putchar</span>(<span class="string">'\n'</span>);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"\n排序后: "</span>);</div><div class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,data[i]);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>


<h3 id="c++实现基数排序">c++实现基数排序</h3>
<figure class="highlight c++"><figcaption><span>c++实现基数排序</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> maxbit(<span class="keyword">int</span> data[],<span class="keyword">int</span> n) <span class="comment">//辅助函数，求数据的最大位数</span></div><div class="line">{</div><div class="line">	<span class="keyword">int</span> d = <span class="number">1</span>; <span class="comment">//保存最大的位数</span></div><div class="line">	<span class="keyword">int</span> p =<span class="number">10</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; ++i)</div><div class="line">	{</div><div class="line">		<span class="keyword">while</span>(data[i] &gt;= p)</div><div class="line">		{</div><div class="line">		p *= <span class="number">10</span>;</div><div class="line">		++d;</div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> d;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> radixsort(<span class="keyword">int</span> data[],<span class="keyword">int</span> n) <span class="comment">//基数排序</span></div><div class="line">{</div><div class="line">	<span class="keyword">int</span> d = maxbit(data,n);</div><div class="line">	<span class="keyword">int</span> * tmp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</div><div class="line">	<span class="keyword">int</span> * count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; <span class="comment">//计数器</span></div><div class="line">	<span class="keyword">int</span> i,j,k;</div><div class="line">	<span class="keyword">int</span> radix = <span class="number">1</span>;</div><div class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; i&lt;= d;i++) <span class="comment">//进行d次排序</span></div><div class="line">	{</div><div class="line">		<span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; <span class="number">10</span>;j++)</div><div class="line">		count[j] = <span class="number">0</span>; <span class="comment">//每次分配前清空计数器</span></div><div class="line">		<span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; n; j++)</div><div class="line">		{</div><div class="line">			k = (data[j]/radix)%<span class="number">10</span>; <span class="comment">//统计每个桶中的记录数</span></div><div class="line">			count[k]++;</div><div class="line">		}</div><div class="line">		<span class="keyword">for</span>(j = <span class="number">1</span>;j &lt; <span class="number">10</span>;j++)</div><div class="line">			count[j] = count[j-<span class="number">1</span>] + count[j]; <span class="comment">//将tmp中的位置依次分配给每个桶</span></div><div class="line">		<span class="keyword">for</span>(j = n-<span class="number">1</span>;j &gt;= <span class="number">0</span>;j--) <span class="comment">//将所有桶中记录依次收集到tmp中</span></div><div class="line">		{</div><div class="line">		k = (data[j]/radix)%<span class="number">10</span>;</div><div class="line">		mp[count[k]] = data[j];</div><div class="line">		tcount[k]--;</div><div class="line">		} </div><div class="line">		<span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; n;j++) <span class="comment">//将临时数组的内容复制到data中</span></div><div class="line">			data[j] = tmp[j];</div><div class="line">		radix = radix*<span class="number">10</span>;</div><div class="line">	}</div><div class="line">	<span class="keyword">delete</span> [] tmp;</div><div class="line">	<span class="keyword">delete</span> [] count;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>实现基数排序算法时，有基于顺序队列和基于链式队列两种不同的实现方法。基于链式队列的实现中可以把桶设计成一个队列数组QueueArray，数组的每个元素中有两个域，一个队首指针（front）和一个队尾指针（rear）。 </p>
<p>下一节更新归并排序。   </p>
]]></content>
         
         
           
             
              <breadCrumb title="software" url="http://blog.tinyxd.me/categories/software/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/06/30/debian-ntfs-filesysterm/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>让Debian支持ntfs文件系统读写</title>
        <pubTime>2012-06-30T07:45:00.000Z</pubTime>
        
        <tag>debian </tag>
         
        <tag>ntfs </tag>
         
        <tag>linux </tag>
         
         <content><![CDATA[<p>刚装好debian发现在debian下往windows盘下拷贝不过去资料，上网查了些资料发现是因为不知道ntfs的读写。<br>查看我的版本号6.0.5   </p>
<pre><code><span class="preprocessor">#more /etc/debian_version   </span>
<span class="number">6.0</span><span class="number">.5</span>   
</code></pre><p>我的Debian系统: 6.0.5<br>要是用的软件使用软件:ntfs-3g<br>1.修改默认源<br>因为我们学校有自己的源，故而修改成我们学校的源，而后进行更新<br>    apt-get update<br><a id="more"></a><br>2.执行安装<br>执行命令:<br>    apt-get install ntfs-3g<br>3.使用<br>直接使用执行命令:<br>    mount -t ntfs-3g /dev/hdax /mnt/windows<br>这里的/dev/hdax 请改为你自己的windows磁盘分区，可利用fdisk -l 查看。<br>如下：   </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">debian:/mnt<span class="preprocessor"># fdisk -l</span></div><div class="line">Disk /dev/sda: <span class="number">500.1</span> GB, <span class="number">500107862016</span> bytes</div><div class="line"><span class="number">255</span> heads, <span class="number">63</span> sectors/track, <span class="number">60801</span> cylinders</div><div class="line">Units = cylinders <span class="keyword">of</span> <span class="number">16065</span> * <span class="number">512</span> = <span class="number">8225280</span> bytes</div><div class="line">Sector size (logical/physical): <span class="number">512</span> bytes / <span class="number">512</span> bytes</div><div class="line">I/O size (minimum/optimal): <span class="number">512</span> bytes / <span class="number">512</span> bytes</div><div class="line">Disk identifier: <span class="number">0x559ed1e5</span></div><div class="line"></div><div class="line">  Device Boot      Start         <span class="keyword">End</span>      Blocks   Id  System</div><div class="line">/dev/sda1               <span class="number">1</span>        <span class="number">6528</span>    <span class="number">52436128</span>+   <span class="number">7</span>  HPFS/NTFS</div><div class="line">/dev/sda2            <span class="number">6529</span>       <span class="number">60802</span>   <span class="number">435949345</span>+   f  W95 Ext<span class="comment">'d (LBA)</span></div><div class="line">/dev/sda5            <span class="number">6529</span>       <span class="number">24543</span>   <span class="number">144705456</span>    <span class="number">7</span>  HPFS/NTFS</div><div class="line">/dev/sda6           <span class="number">24544</span>       <span class="number">42558</span>   <span class="number">144705456</span>    <span class="number">7</span>  HPFS/NTFS</div><div class="line">/dev/sda7           <span class="number">42559</span>       <span class="number">53060</span>    <span class="number">84357283</span>+   <span class="number">7</span>  HPFS/NTFS</div><div class="line">/dev/sda8           <span class="number">53061</span>       <span class="number">53321</span>     <span class="number">2096451</span>    b  W95 FAT32</div><div class="line">/dev/sda9   *       <span class="number">53322</span>       <span class="number">53346</span>      <span class="number">194560</span>   <span class="number">83</span>  Linux</div><div class="line">/dev/sda10          <span class="number">53346</span>       <span class="number">53589</span>     <span class="number">1951744</span>   <span class="number">82</span>  Linux swap / Solaris</div><div class="line">/dev/sda11          <span class="number">53589</span>       <span class="number">55413</span>    <span class="number">14647296</span>   <span class="number">83</span>  Linux</div><div class="line">/dev/sda12          <span class="number">55413</span>       <span class="number">60802</span>    <span class="number">43287552</span>   <span class="number">83</span>  Linux</div></pre></td></tr></table></figure>

<p>如果是加入开机自动映射的话，编辑/etc/fstab,加入如下内容就可以了。<br>    /dev/hdax /mnt/windows ntfs-3g defaults 0 0<br>下面是我的系统加载NTFS文件系统的相关命令：<br>    mount -t ntfs-3g /dev/sda6 /mnt/D<br>    mount -t ntfs-3g /dev/sda7 /mnt/E   </p>
]]></content>
         
         
           
             
              <breadCrumb title="linux" url="http://blog.tinyxd.me/categories/linux/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/07/01/merge-sort/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>排序算法总结（五）</title>
        <pubTime>2012-07-01T15:45:00.000Z</pubTime>
        
        <tag>c </tag>
         
        <tag>software </tag>
         
        <tag>sort </tag>
         
         <content><![CDATA[<p>归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。<br>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。<br>将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。<br>与快速排序比较：归并排序是稳定的排序.即相等的元素的顺序不会改变。如输入记录 1(1) 3(2) 2(3) 2(4) 5(5) (括号中是记录的关键字)时输出的 1(1) 2(3) 2(4) 3(2) 5(5) 中的2 和 2 是按输入的顺序。这对要排序数据包含多个信息而要按其中的某一个信息排序，要求其它信息尽量按输入的顺序排列时很重要。这也是它比快速排序优势的地方.。<br><a id="more"></a><br>用途：<br>1、排序<br>速度仅次于快速排序，但较稳定。<br>2、求逆序对数<br>具体思路是，在归并的过程中计算每个小区间的逆序对数，进而计算出大区间的逆序对数（也可以用树状数组来求解）。<br>c语言实现<br>输入参数中，需要排序的数组为array[],起始索引为first，终止索引为last。调用完成后，array[]中从first到last处于升序排列。    </p>
<figure class="highlight c"><figcaption><span>归并算法（Merge sort）</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> MergeSort(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> first, <span class="keyword">int</span> last)</div><div class="line">{</div><div class="line">	<span class="keyword">int</span> mid = <span class="number">0</span>;</div><div class="line">	<span class="keyword">if</span>(first&lt;last)</div><div class="line">	{</div><div class="line">		mid = (first+last)/<span class="number">2</span>;</div><div class="line">		MergeSort(<span class="built_in">array</span>, first, mid);</div><div class="line">		MergeSort(<span class="built_in">array</span>, mid+<span class="number">1</span>,last);</div><div class="line">		Merge(<span class="built_in">array</span>,first,mid,last);</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>




]]></content>
         
         
           
             
              <breadCrumb title="software" url="http://blog.tinyxd.me/categories/software/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/07/02/add-flickr-aside-in-octopress/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>octopress博客添加flickr侧边栏</title>
        <pubTime>2012-07-02T03:14:00.000Z</pubTime>
        
        <tag>octopress </tag>
         
        <tag>flickr </tag>
         
         <content><![CDATA[<p>octopress添加侧边栏：<br>1.新建 <code>source/_includes/custom/asides/flickr.html</code>，代码如下：</p>
<script src="https://gist.github.com/1421792.js?file="></script><br><a id="more"></a><br>2.在_config.yml添加<br><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Flick Badges</span></div><div class="line"><span class="comment"># Find your user id here: http://idgettr.com/ It should be something like "81221217<span class="yardoctag">@N</span>08".</span></div><div class="line"><span class="symbol">flickr_user:</span> <span class="number">81221217</span><span class="variable">@N08</span></div><div class="line"><span class="symbol">flickr_count:</span> <span class="number">6</span></div></pre></td></tr></table></figure>


<p>记住要把 flickr_user 换成你自己的 id。<br>ID在这个<a href="http://idgettr.com/" target="_blank" rel="external">网址</a>获取，只需把username换成自己的，然后点find。<br>3.在<code>_config_yml</code>中<code>default_asides</code>添加<code>custom/asides/flickr.html</code>。<br>4.大功告成。<br>本文参考了：<a href="http://lucifr.com/2011/12/02/add-flickr-aside-to-octopress/" target="_blank" rel="external">Lucifr</a>和<a href="http://melandri.net/2012/01/10/octopress-flickr-aside/" target="_blank" rel="external">melandri</a>。</p>
]]></content>
         
         
           
             
              <breadCrumb title="octopress" url="http://blog.tinyxd.me/categories/octopress/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/07/03/vc-debug-release/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>vc debug 变 release</title>
        <pubTime>2012-07-03T04:23:00.000Z</pubTime>
        
        <tag>c++ </tag>
         
        <tag>software </tag>
         
        <tag>vc </tag>
         
         <content><![CDATA[<p>今天遇到将debug改为release版本出现好多问题，最后一一解决，现将方法贴到下面<br>生成release版的步骤：<br>1.首先修改<code>project-setting-general-using mfc in a static libraryproject-setting</code>右键点击菜单空白处——选择“组建”——选择“Win32 Release“——重新编译链接。<br>2.然后<code>project-setting -c++ -precompiled Headers- not using</code><br>最后出现这个错误<br>    nafxcwd.lib(afxmem.obj) : error LNK2005: “void __cdecl operator delete(void *)” (??3@YAXPAX@Z) already defined in LIBCMTD.lib(dbgdel.obj)<br>关于静态库引发 nafxcw.lib LNK2005 错误的解决方法<br><a id="more"></a><br>解决方法，进入vc6 选择菜单：<br>    project -&gt; settings -&gt; link -&gt; Category : input   -&gt; Object/library modeules ,<br>输入：nafxcw.lib 即可。<br>原因：必须先编译这个库，才能避免函数名字重复引用。<br><br><br>Note：记住rebuiled<br><br><br>附：debug版本和release版本的区别：<br>Debug 通常称为调试版本，它包含调试信息，并且不作任何优化，便于程序员调试程序。Release 称为发布版本，它往往是进行了各种优化，使得程序在代码大小和运行速度上都是最优的，以便用户很好地使用。Debug 和 Release 的真正秘密，在于一组编译选项。下面列出了分别针对二者的选项<br><br><br>Debug 版本：</p>
<blockquote>

<p>/MDd /MLd 或 /MTd 使用 Debug runtime library(调试版本的运行时刻函数库)<br>/Od 关闭优化开关<br>/D “_DEBUG” 相当于 #define _DEBUG,打开编译调试代码开关(主要针对assert函数)<br>/ZI 创建 Edit and continue(编辑继续)数据库，这样在调试过程中如果修改了源代码不需重新编译<br>/GZ 可以帮助捕获内存错误<br>/Gm 打开最小化重链接开关，减少链接时间</p>
</blockquote>

<p><br><br>Release 版本：   </p>
<blockquote>

<p>/MD /ML 或 /MT 使用发布版本的运行时刻函数库<br>/O1 或 /O2 优化开关，使程序最小或最快<br>/D “NDEBUG” 关闭条件编译调试代码开关(即不编译assert函数)<br>/GF 合并重复的字符串，并将字符串常量放到只读内存，防止 被修改</p>
</blockquote>

<p><br><br> 实际上，Debug 和 Release 并没有本质的界限，他们只是一组编译选项的集合，编译器只是按照预定的选项行动。事实上，我们甚至可以修改这些选项，从而得到优化过的调试版本或是带跟踪语句的发布版本。</p>
]]></content>
         
         
           
             
              <breadCrumb title="software" url="http://blog.tinyxd.me/categories/software/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/07/05/linux-mirrors-china/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>中国大陆linux源镜像地址</title>
        <pubTime>2012-07-05T01:39:00.000Z</pubTime>
        
        <tag>linux </tag>
         
        <tag>mirror </tag>
         
         <content><![CDATA[<p>1.企业<br>搜狐开源镜像站：<br>    <a href="http://mirrors.sohu.com/" target="_blank" rel="external">http://mirrors.sohu.com/</a><br>网易开源镜像站：<br>    <a href="http://mirrors.163.com/" target="_blank" rel="external">http://mirrors.163.com/</a><br>2.大学<br>西安电子科技大学：<br>    <a href="http://ftp.xdlinux.info/" target="_blank" rel="external">http://ftp.xdlinux.info/</a>  (IPv4+IPv6)<br>    ftp://linux.xidian.edu.cn/<br>中国科学技术大学：<br>    <a href="http://mirrors.ustc.edu.cn/" target="_blank" rel="external">http://mirrors.ustc.edu.cn/</a> (IPv4+IPv6)<br>    <a href="http://mirrors4.ustc.edu.cn/" target="_blank" rel="external">http://mirrors4.ustc.edu.cn/</a><br>    <a href="http://mirrors6.ustc.edu.cn/" target="_blank" rel="external">http://mirrors6.ustc.edu.cn/</a><br><a id="more"></a><br>上海交通大学：<br>    <a href="http://ftp.sjtu.edu.cn/" target="_blank" rel="external">http://ftp.sjtu.edu.cn/</a> (IPv4 only)<br>    <a href="http://ftp6.sjtu.edu.cn" target="_blank" rel="external">http://ftp6.sjtu.edu.cn</a> (IPv6 only)<br>清华大学：<br>    <a href="http://mirrors.tuna.tsinghua.edu.cn/" target="_blank" rel="external">http://mirrors.tuna.tsinghua.edu.cn/</a> (IPv4+IPv6)<br>    <a href="http://mirrors.6.tuna.tsinghua.edu.cn/" target="_blank" rel="external">http://mirrors.6.tuna.tsinghua.edu.cn/</a> (IPv6 only)<br>    <a href="http://mirrors.4.tuna.tsinghua.edu.cn/" target="_blank" rel="external">http://mirrors.4.tuna.tsinghua.edu.cn/</a> (IPv4 only)<br>天津大学：<br>    <a href="http://mirror.tju.edu.cn/" target="_blank" rel="external">http://mirror.tju.edu.cn/</a><br>西南大学：<br>    <a href="http://linux.swu.edu.cn/swudownload/Distributions/" target="_blank" rel="external">http://linux.swu.edu.cn/swudownload/Distributions/</a><br>东北大学：<br>    <a href="http://mirror.neu.edu.cn/" target="_blank" rel="external">http://mirror.neu.edu.cn/</a> (IPv4 only)<br>    <a href="http://mirror.neu6.edu.cn/" target="_blank" rel="external">http://mirror.neu6.edu.cn/</a> (IPv6 only)<br>电子科技大学：<br>    <a href="http://ubuntu.uestc.edu.cn/" target="_blank" rel="external">http://ubuntu.uestc.edu.cn/</a><br>青岛大学：<br>    <a href="http://mirror.qdu.edu.cn/" target="_blank" rel="external">http://mirror.qdu.edu.cn/</a><br>兰州大学：<br>    <a href="http://mirror.lzu.edu.cn/" target="_blank" rel="external">http://mirror.lzu.edu.cn/</a><br>厦门大学：<br>    <a href="http://mirrors.xmu.edu.cn/" target="_blank" rel="external">http://mirrors.xmu.edu.cn/</a><br>北京理工大学：<br>    <a href="http://mirror.bit.edu.cn" target="_blank" rel="external">http://mirror.bit.edu.cn</a> (IPv4 only)<br>    <a href="http://mirror.bit6.edu.cn" target="_blank" rel="external">http://mirror.bit6.edu.cn</a> (IPv6 only)<br>北京交通大学：<br>    <a href="http://mirror.bjtu.edu.cn" target="_blank" rel="external">http://mirror.bjtu.edu.cn</a> (IPv4 only)<br>    <a href="http://mirror6.bjtu.edu.cn" target="_blank" rel="external">http://mirror6.bjtu.edu.cn</a> (IPv6 only)<br>    <a href="http://debian.bjtu.edu.cn" target="_blank" rel="external">http://debian.bjtu.edu.cn</a> (IPv4+IPv6)</p>
]]></content>
         
         
           
             
              <breadCrumb title="linux" url="http://blog.tinyxd.me/categories/linux/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/07/06/linux-sleep-usage/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>linux sleep 的用法</title>
        <pubTime>2012-07-06T04:40:00.000Z</pubTime>
        
        <tag>linux </tag>
         
         <content><![CDATA[<p><strong>应用程序</strong>：   </p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> &lt;syswait.h&gt;</span>
usleep(n) <span class="comment">//n微秒</span>
Sleep（n）<span class="comment">//n毫秒</span>
sleep（n）<span class="comment">//n秒</span>
</code></pre><p><a id="more"></a><br><strong>驱动程序</strong>：   </p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> &lt;linux/delay.h&gt;</span>
mdelay(n) <span class="comment">//milliseconds 其实现</span>
</code></pre><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#ifdef notdef</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> mdelay(n) (\</span></div><div class="line">{<span class="keyword">unsigned</span> <span class="keyword">long</span> msec=(n); <span class="keyword">while</span> (msec--) udelay(<span class="number">1000</span>);})</div><div class="line"><span class="preprocessor">#<span class="keyword">else</span></span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> mdelay(n) (\</span></div><div class="line">(__builtin_constant_p(n) && (n)&lt;=MAX_UDELAY_MS) ? udelay((n)*<span class="number">1000</span>) : \</div><div class="line">({<span class="keyword">unsigned</span> <span class="keyword">long</span> msec=(n); <span class="keyword">while</span> (msec--) udelay(<span class="number">1000</span>);}))</div><div class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></div></pre></td></tr></table></figure>

<p>调用asm/delay.h的udelay,udelay应该是纳秒级的延时   </p>
<p>dos:<br>    sleep(1); //停留1秒<br>    delay(100); //停留100毫秒<br>Windows:<br>    Sleep(100); //停留100毫秒<br>Linux:<br>    sleep(1); //停留1秒<br>    usleep(1000); //停留1毫秒<br>每一个平台不太一样,最好自己定义一套跨平台的宏进行控制<br>附：Linux下（使用的gcc的库），sleep()函数是以秒为单位的，sleep(1);就是休眠1秒。而MFC下的sleep()函数是以微秒为单位的，sleep(1000);才是休眠1秒。而如果在Linux下也用微妙为单位休眠，可以使用线程休眠函数:void usleep(unsigned long usec);当然，使用的时候别忘记#include <system.h>哦。另外，linux下还有个delay()函数，原型为extern void delay(unsigned int msec);它可以延时msec*4毫秒，也就是如果想延时一秒钟的话，可以这么用 delay(250)。   </system.h></p>
]]></content>
         
         
           
             
              <breadCrumb title="linux" url="http://blog.tinyxd.me/categories/linux/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/07/06/ruby-learning/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>ruby初学</title>
        <pubTime>2012-07-06T15:43:00.000Z</pubTime>
        
        <tag>ruby </tag>
         
         <content><![CDATA[<p>这几天在学习Ruby，面对一个陌生的脚本语言，虽然陌生但是既然是脚本语言，自然也有与shell类似的地方，所以学习起来困难不是很大。<br>在感受到脚本语言的方便后，试了个例子，如下计算一个文件中单词的个数，以空格来区分。   </p>
<figure class="highlight ruby"><figcaption><span>统计单词个数ruby脚本word.rb</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#计算单词个数</span></div><div class="line">count = <span class="constant">Hash</span>.new(<span class="number">0</span>)</div><div class="line"></div><div class="line"><span class="comment">##统计单字</span></div><div class="line"><span class="keyword">while</span> line = gets</div><div class="line">words = line.split</div><div class="line">words.each{|word|</div><div class="line">count[word] += <span class="number">1</span></div><div class="line">}</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="comment">##输出结果</span></div><div class="line">count.sort{|a,b|</div><div class="line">a[<span class="number">1</span>] &lt;=&gt; b[<span class="number">1</span>]</div><div class="line">}.each{|key,value|</div><div class="line">print <span class="string">"<span class="subst">#{key}</span>: <span class="subst">#{value}</span>\n"</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>用法：<code>ruby word.rb your_file</code><br><a id="more"></a><br>还有个问题以后可能会经常遇到，用p方法来输出包括日文或者中文的字符串的时候，会发生一般所谓的“乱码”的输出结果。所以在执行ruby程序时需要加上-Ks、-Ke之类的环境参数，这些参数用来指定文字编码。针对中文字符串，可以制定-Ku参数（UTF-8）来取得正常的显示效果。<br><br></p>
]]></content>
         
         
           
             
              <breadCrumb title="ruby" url="http://blog.tinyxd.me/categories/ruby/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/07/07/regular-expressions-in-ruby/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>正则表达式</title>
        <pubTime>2012-07-07T15:40:00.000Z</pubTime>
        
        <tag>ruby </tag>
         
         <content><![CDATA[<p>Ruby语言是一种“万事万物皆对象”的程序语言，正则表达式也是一个对象。正则表达式所属的类，就是Regexp类。<br>要建立正则表达式两种方法：<br>1.用“//”括住。<br>2.当正则表达式内部用到“/”字符的时候，改用%r会比较方便。 示例%r(样式)<br>下面介绍一些规则。<br>1.^ 行首匹配 $行尾匹配 \A 字符串头 \Z字符串尾<br>2.指定想要匹配成功的文字范围用[]<br>    比如[A-Z]所有大写英文字母[A-Za-z]所有英文字母[0-9]所有阿拉伯数字[^ABC]A、B、C以外的字<br>3.匹配任意字符用.<br>    想要指定字数/^…$/ 刚好三个字的一行<br>    配合“<em>”等转义字符使用<br><a id="more"></a><br>4.使用反斜杠的样式（“\”+“一个英文字母”）<br>    \s 空白 会与空白字符（0x20）、定位字符、换行字符、换页字符匹配成功<br>    \d与0-9之间的数字匹配成功<br>    \w与英文与数字匹配成功<br>    \A与字符串前端匹配成功<br>    \Z与字符串末端匹配成功<br>5.将转义字符当作一般字符<br>    “\”后接上“^”、“$”、“[”这些英文、数字以外的转义字符时，这些字符就不在具备转义字符的效用了，而可以去匹配这些字符本身。<br>6.匹配连续出现的相同字符或单字   
    </em>出现0次以上<br>    +出现1次以上<br>    ?出现0次或1次<br>7.最短匹配<br>    *?出现0次以上，但取最短的匹配结果<br>    +?出现1次以上，但取最短的匹配结果<br>8.“()”与反复<br>    使用“()”可以多个字构成的字符串反复匹配<br>9.多选<br>    /^(ABC|DEF)$/<br>    正则项选项/</p>
<figure class="highlight /后面类似/.../ei"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">	i忽略英文大小写差异</div><div class="line">	s e u n 指定字符编码方式 s是<span class="constant">Shift_JIS</span>,e是<span class="constant">EUC</span>-<span class="constant">JP</span>，u是<span class="constant">UTF</span>-<span class="number">8</span> n是匹配是不考虑文字编码。</div><div class="line">	x忽略正则表达式内部的空白，并忽略“<span class="comment">#”后面的内容。加上这个选项就可以在正则表达式内部写注释了。</span></div><div class="line">	m 让“.”能与换行符号匹配成功</div><div class="line">	p /<span class="constant">DEF</span>.<span class="constant">GHI</span>/m =~ <span class="string">"ABC\nDEF\nGHI"</span> <span class="comment">#=&gt; 4 匹配成功</span></div><div class="line">&lt;br /&gt;</div><div class="line">**正则表达式的方法**    </div><div class="line">sub、gsub、scan    </div><div class="line">sub方法只会取代第一个匹配成功处的字符串，而gsub则会取代所有匹配成功的字符串    </div><div class="line">	str = “abc <span class="function"><span class="keyword">def</span> </span>g hi”    </div><div class="line">	p str.sub(<span class="regexp">/\s+/</span>,<span class="string">' '</span>) <span class="comment">#=&gt; "abc def g hi"   </span></div><div class="line">	p str.gsub(<span class="regexp">/\s+/</span>,<span class="string">' '</span>) <span class="comment">#=&gt; "abc def g hi"   </span></div><div class="line">scan跟gsub一样会匹配字符串里所有符合样式的部分，但只是获取不会取代。    </div><div class="line">&lt;br /&gt;</div><div class="line">取出服务器的地址的正则表达式：    </div><div class="line">	/<span class="symbol">http:</span>\/\/([^\/]*)\/<span class="regexp">/ %r|http:/</span><span class="regexp">/([^/</span>]*)/|</div></pre></td></tr></table></figure>

<p> ruby url_match.rb<br>str = “<a href="http://www.ruby-lang.org/ja/" target="_blank" rel="external">http://www.ruby-lang.org/ja/</a>“<br>%r|<a href="http://([^/]*)/|" target="_blank" rel="external">http://([^/]*)/|</a> =~ str<br>print “server address: “, $1, “\n”<br>```<br>运行：    </p>
<pre><code>&gt;<span class="keyword">ruby</span> url_match.rb   
server addres<span class="variable">s:</span> www.<span class="keyword">ruby</span>-lang.org
</code></pre><p>正则表达式的圣书：<code>Mastering Regular Expressions, Third Edition (Jeffrey E.F.Friedl 著/O&#39;REILLY 出版)</code><br><br></p>
]]></content>
         
         
           
             
              <breadCrumb title="ruby" url="http://blog.tinyxd.me/categories/ruby/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/07/08/blog-one-month/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>写在开博一个月</title>
        <pubTime>2012-07-08T15:31:00.000Z</pubTime>
        
        <tag>blog </tag>
         
         <content><![CDATA[<p>其实说开博一个月，不太妥当。用octopress搭建博客是在5月底，域名是在6月9号申请的。Anyway，在这一个月中，深切体会到了“隔行如隔山”。从刚开始一点不懂，到现在知道了“SEO”、“sitemap”、”PR”、还有各种博客工具，学习了ruby、html，css等等。<br>到现在google PR值仍然为0（站长真是不容易啊），不过bing、yahoo、sogou等搜索引擎已经开始收录了，只是baidu还没有动静（伤感中），只好继续等待了。<br>先写到这吧，有啥体会了再继续。。。</p>
]]></content>
         
         
           
             
              <breadCrumb title="essay" url="http://blog.tinyxd.me/categories/essay/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/07/08/degrading-for-success/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>互联网创业降级论</title>
        <pubTime>2012-07-07T16:46:00.000Z</pubTime>
        
        <tag>IT </tag>
         
         <content><![CDATA[<p>本文来自：<a href="http://meditic.com/degrading-for-success/" target="_blank" rel="external">meditic</a><br>几乎一年没有写博客了，说没时间那是借口，唯一的原因是，年纪越大越发觉自己肤浅。有些想法还没提笔，就发现很幼稚，就不敢发出来贻笑大方了。这次先给大家说个小故事：</p>
<p>从前有三个屌丝，聚在一起做网络，提供免费的网络服务，砸锅卖铁，通宵达旦，除了卖肾啥都做了。3年后终于做到了五百万用户，对于年轻人来说，能把五百万人玩弄于鼓掌之间，已经是很牛逼轰轰的事了，不过用户越多，成本越高，每年服务器、带宽租金、房租水电、广告运营等成本，已经达到了十七八万，屌丝们不得不面对一个终极问题：如何盈利？</p>
<p>屌丝们定了三盘沙县水饺，围着一箱子的冰啤酒开始计算：按照最近一月的登陆情况来看，四百万个账号已经不活跃了，真正有商业价值的只有一百万人，如 果开通xx功能，收点高级会员费，让其中1%的人升级为高级会员，每年付30块钱年费，那么每年收入就是100万x1%x30元=30万元！不错嘛， 扣除十七八万的运营成本，还剩毛利润12万，每个屌丝年底能分到4万大洋，如果按照打工者的算法，这三个人每人月薪3333元，木有奖金，木有津贴、木有任何福利，上班还得带自家的电脑。</p>
<p>尽管如此，屌丝们还是激动得热泪盈眶：老子有钱啦！老子有钱啦！！！那一夜，人们看到三个发疯的屌丝在屋顶翩翩起舞。</p>
<p>韩寒说，中国人民是最有忍耐力的族群，一点好处就感激涕零。他一定不知道，IT创业界里的屌丝，才是这群傻逼中的战斗机。他们可以平静地忍受每年都持续亏钱，而且还能信心十足的对所有人说公司的状态非常好，如果有一天居然收支平衡了，他们会激动的趁夜难眠，比北朝鲜倒掉还开心。<br><a id="more"></a><br>本文开头的三个屌丝，其实是非常幸运的，至少能做到月薪3333元。大部分的屌丝在第一年做到几万用户的时候就会挂掉，原因众多，最主要要的是意志太弱，受不了最初的寂寞；意志稍微坚强点的会在第二年第三年慢慢挂掉，原因主要是资金断裂、团队分裂；能成功熬到第四年还没饿死、还没被口水淹死、还没被肠胃病颈椎病腰肌劳损折磨死的，甚至员工不减反增的，基本上属于神仙级别了。</p>
<p>我为什么要说三个屌丝的故事呢。首先是因为这是身边每天都在发生的故事，其次是因为感到可惜，IT界在我眼里一直是一个无比高级的职业，聚集着全球最聪明、最富有的人类精英。以IT创业界的青年们的智商，他们可以做成任何一件事情，包括改造银行到制造汽车到发射航天飞机 。结果这帮人却整天在蓬头垢面得为3k的月薪而挣扎，太悲催了。</p>
<p>为什么用悲催这个词？ 如果一个人生下来就在山沟沟里，一辈子都没机会去见什么好东西，这不叫悲催，这只叫苦难；而如果一个人生出来有一个奇怪的特异功能：皮肤出来的汗水会凝结成昂贵的水晶，本来只靠出汗就能赚钱，结果这傻逼居然觉得出汗这个行为太低级，做手术把自己的汗腺全给切了，而且丝毫没有意识到他做了什么傻事，这才叫真的悲催。</p>
<p>我们IT界中的很多人，生下来就是有这个出汗成水晶的特异功能的，正是因为这种与众不同，这群人能混入牛逼的大学，整天打网游还能写出像样的毕业论文， 拿到学位，进外企，考CPA，做咨询、做证券分析，研究高分子材料，做电子商务，做云计算。。。一级一级的上升，直到有一天，发现身边的人里，已经没有一个不是CPA，不是咨询师，不是高级研究员了，身边的人全是业界精英，个个都超级强悍。在这个所谓的高级圈子里，自己并没有任何过人之处，只不过是just another analyst而已。在高级圈子里拼的头破血流，最后也只能混到给台湾人整理数据而已。莫然回首，发现当年的血气方刚、年少时的无限梦想，进化成了一身肥胖的赘肉。这个时候，有个旁观者说：“升级到头了，该降级了”</p>
<p>当一个社会疯狂鼓吹快节奏的时候，一定需要有人来宣扬慢生活；当全社会跟打了鸡血似的吹捧升级的时候，一定需要有人来说说降级论。</p>
<p>IT青年们喜欢打游戏，喜欢升级。他们的人生也和游戏一样，沉醉于不停的升级中，不仅喜欢升级自己手上的技术，把MySql改成MongoDB，把Apache升级为Nginx，在Mac上装Ubuntu，Ubuntu里再装个虚拟机去跑Mac OS。。。IT青年们也喜欢升级自己的人生，从程序员升级到项目经理，再升级到技术总监或产品总监，再升级到合伙人。。。</p>
<p>在不断追求升级的过程中，所面临的一个很大事实是：当一个人从A刚升级到A+级的时候，其实这个人的能力层级依然只是A的层级，还未胜任A+的层级，他必须要到A+的后期，才可以胜任A+。就好像一个高中生，高考完之后，虽然理论上已经属于大学生了，但是他的实际能力依然只是高三毕业的水平，除非他全部pass了大一的期末考试。同样的道理，这个世界上有很多人的身份和称谓，都是在描述“未来的自己”，而不是现在的自己。当你从销售员升级为销售经理的时候，你自我感觉很好：“我现在是销售经理了”，但是这个时候 ，你并未通过公司对你作为销售经理这一年的工作成果的考核，你只是一个“未来可能是合格的销售经理”的前身。如果年终考核你失败了，那么这一年最准确的描述是：一个销售员，占了整整一年销售经理的位子，最后失败了。而且这一年一定会过的很累，因为通过考核的其他销售经理，才是真正胜任这个层级的人，跟一帮真正属于这个圈子的人厮杀，就好像拳击馆里当陪练的小角色，去和泰森比了一年的武，怎么可能不累呢？</p>
<p>当我07年进入互联网行业的时候，就是那个拳击馆里陪练的小角色，我被迫去跟全国各地的泰森比拼，结果累的半死。后来我开始反思最初的目标，为什么要在自己身上挂一个“拳击高手”的招牌，被那么多泰森追着打？ 我把这块招牌卸了，找个完全没练武的人去比拼，不是更容易赢么？于是果断照做，去找了一个没人懂拳击的小乡村，做了纯英文的<a href="http://www.tucia.com/" target="_blank" rel="external">Tucia.com</a>(需翻墙)，只做国外的业务。在那个地方，作为一个知名武馆的拳击小陪练，我成了村子里拳击技术最高超的人，受人仰慕，还开武馆教人拳击，活的非常滋润，而且在教人拳击的过程中，自己的拳术也比以前提高了很多，发展出一套属于自己的拳法，我虽然进不了泰森们的大圈子，但他们也进不了我的小圈子。</p>
<p>关于圈子，有一个很赤裸裸的现实：不会是你进入圈子，只能是圈子进入你。很多人会四处找关系，“帮我介绍给xxx吧，我想进入你们的圈子”，这样的人是永远进不去这个圈子的，因为圈子的天性是，永远追求更高一个层级的人。而我们的大部分人，其实都在以低一级的属性，占着更高一级的位子，徘徊在更高一级的圈子边缘，与更高一级的人竞争，幻想着自己可以升级到那个圈子里去。也许永远进不去，悲催的努力一辈子；也许运气好，某一天真的进入这个圈子了，但那个时候又会有下一个目标，希望进入更高级的圈子，这是一场没有终点的战斗。永远的追求升级，永远的累。</p>
<p>有没有想过降级呢？</p>
<p>如果一个来自微软的高级工程师，辞职去一个养猪场做开放平台经理，那么他的到来不仅会让养猪圈感到无比荣幸，更是意味着，利用他在IT界训练出来的高效工作方式和逻辑思维能力，他可以掀起一场养猪行业的革命，使得20年后才会出现的人性、高效、开放、协作、健康的养殖方式提前到达。在这场革命中，他会活的非常有价值。这种价值，在原先的圈子里，是完全体验不到的，因为他此前的所有工作，只是在满身疮痍的windows系统上不停的打补丁，无论打多少都逃不开产品衰落、被人鄙视的命运。</p>
<p>很多人的命运，都像是上面那个微软工程师。只需要降级，就能创造更大的价值，也能获得更大的满足。那为什么不呢？为什么要死死抱着那个所谓的“高级职业”不放呢？</p>
<p>去年我曾犯贱去趟了移动互联网的浑水，做了个手机app，刚开始的时候感觉很高级，但很快，铺天盖地的竞争对手就出现了，我又发现自己陷入了07年一样的场景：作为一个小小陪练，我他妈的又被一帮泰森们给围住了。当泰森中的战斗机—-微信，变得无比牛逼之后，我就知道，战胜这群泰森是绝对不可能的事情了。于是我再次投靠了“降级论”，把自己从牛逼哄哄的移动互联网行业，降级到了一个被人不齿的低级项目：<a href="http://www.tuciababy.com/" target="_blank" rel="external">Tucia Baby</a>。</p>
<p>这个项目虽然是传统行业，但是我们基本上是按照互联网产品的思路去做的，除了拍摄需要来店里以外，其他一切，包括营销、预约、客服、后期、选片、取片、客户关系等，所有环节都放在网络上，尤其是微博（<a href="http://weibo.com/tuciababy" target="_blank" rel="external">@tuciababy官网</a>）。当然，最重要的是，作为一个脑残的果粉，我按照iPhone的做工和品质去要求每一张作品，必须达到我们能力可以做到的最好水准，不计成本的最好水准，才允许送给客户。正式接客不到两个月时间，虽然还远未达到成功，但目前已做到每天都有客户订单，财务上已实现盈利，未来相信一定会比大部分app开发者更光明。（ps:我们没有请工商、税务、城管去吃饭喝酒泡桑拿，也没有塞钱给任何政府机关。当你的产品真的用心做到很好的时候，其实你不需要讨好任何人的。）</p>
<p>这个项目让我沉思了很久：07年我曾把一个纯纯的web2.0网站做到了alexa中国区前1000名（如有质疑，请查询2010年附近的tucia.com排名），结果一路亏损，到最后只剩下一个员工；11年我把那个纯纯的app做到苹果官方推荐区免费榜的第一位（<a href="http://ww3.sinaimg.cn/bmiddle/823ddc58gw1dkiqty41ukj.jpg" target="_blank" rel="external">点此看截图</a>），那段时间每天四五千iPhone安装量，结果一路烧钱，到最后濒临关闭；而如今，我只需把自己从纯纯的互联网降级下来，做一些看起来有些“低级”的项目，居然就能立即实现收支平衡。</p>
<p>除此以外，我还发现一个现象，中国消费者在与奸商们的长期斗争中，已经培养出了一种非常苦B的品质：只要不被坑，他就谢天谢地。如果商家严格做到了承诺的每一件事情，客户就会感动的泪如泉涌。如果商家不仅做到了所有承诺的事情，还很贴心的提供了一些额外的服务（比如我们给每位客户赠送非常好吃的樱桃和昂贵的进口巧克力作为甜点），那么客户就会激动的哭天喊地、奔走相告，推荐给他认识的每一个人。</p>
<p>其实这片肮脏的国土，就是上天赐予IT青年们的最好机会。</p>
<p>在一个不会练武的村子里，只要你会打两拳，你就是拳术最厉害的人；在一个没有服务意识、忽视产品质量的土地上，只要你用心做服务，用最高的标准去要求自己，你就会成为这块土地上最出色的商家；在一个没有现代管理意识，不懂网络、不懂微博、不懂用户体验、不懂口碑传播的粗犷社会里，你只需要把之前花在IT产品上的心思的10%拿过来用，就可以秒杀一切天朝对手。</p>
<p>所以，</p>
<p>IT青年们，当你在为网站的转化率苦苦思索的时候，当你在为app的活跃度辗转反侧的时候，当你在为融资计划苦苦哀求各界大佬引荐的时候，也许犯了一个错误，也许你们的脑子最值得闪光的地方，不是去悲催的IT界当炮灰，而应该是去按摩界、餐饮界、烧烤界、早餐界、理发界、家政界、按摩界、送花界、纺织界、成人用品界、现代化养殖界、有机蔬果界、个人护理界、汽车修理界。。。。与IT界相比，这些行业的确无比低级，他们的老板连qq都会发音成“抠抠”，他们的员工一辈子都没用过Email；跟他们解释什么是SEO，什么是用户体验，什么是数据挖掘，他们会在听你说完之前就开枪自杀掉。正是因为如此，这些行业才是如此的不堪一击。正是因为如此，当智商高达147的IT青年还在为3k薪水拼命、而智商不到50的烧烤店老板正坐在porsche里玩着前面那位青年开发的app的时候，我就忍不住仰望星空。</p>
<p>这些原始而纯粹的行业，正在等待IT精英们的降级，如同蒲公英一般的伞兵，在黑夜里从天而降，长驱直入，用最智慧的产品、最优质的服务拯救这些早就该死的行业，屌丝的生命将会绽放出银色的羽翼，无比丰满，无比性感。</p>
<p>最后注意，请珍惜生命，远离我的微博：<a href="http://weibo.com/meditic" target="_blank" rel="external">@meditic</a></p>
]]></content>
         
         
           
             
              <breadCrumb title="essay" url="http://blog.tinyxd.me/categories/essay/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/07/08/git-branch-management-strategy/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>git分支管理策略</title>
        <pubTime>2012-07-08T15:46:00.000Z</pubTime>
        
        <tag>git </tag>
         
         <content><![CDATA[<p>如果你严肃对待编程，就必定会使用”<a href="http://www.ruanyifeng.com/blog/2008/12/a_visual_guide_to_version_control.html" target="_blank" rel="external">版本管理系统</a>“（Version Control System）。</p>
<p>眼下最流行的”版本管理系统”，非<a href="https://github.com/" target="_blank" rel="external">Git</a>莫属。   </p>
<p><iframe src="https://skydrive.live.com/embed?cid=1F260DE1061FCF3E&resid=1F260DE1061FCF3E%21131&authkey=AAPFgWVBfiUqHeo" width="320" height="134" frameborder="0" scrolling="no"></iframe><br>相比同类软件，Git有很多优点。其中很显著的一点，就是版本的分支（branch）和合并（merge）十分方便。有些传统的版本管理软件，分支操作实际上会生成一份现有代码的物理拷贝，而Git只生成一个指向当前版本（又称”快照”）的指针，因此非常快捷易用。<br><a id="more"></a><br>但是，太方便了也会产生副作用。如果你不加注意，很可能会留下一个枝节蔓生、四处开放的版本库，到处都是分支，完全看不出主干发展的脉络。   </p>
<p><iframe src="https://skydrive.live.com/embed?cid=1F260DE1061FCF3E&resid=1F260DE1061FCF3E%21132&authkey=AOWpB7QlaRtAdFA" width="320" height="169" frameborder="0" scrolling="no"></iframe><br><a href="http://nvie.com/" target="_blank" rel="external">Vincent Driessen</a>提出了一个分支管理的<a href="http://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="external">策略</a>，我觉得非常值得借鉴。它可以使得版本库的演进保持简洁，主干清晰，各个分支各司其职、井井有条。理论上，这些策略对所有的版本管理系统都适用，Git只是用来举例而已。如果你不熟悉Git，跳过举例部分就可以了。</p>
<p>一、主分支Master</p>
<p>首先，代码库应该有一个、且仅有一个主分支。所有提供给用户使用的正式版本，都在这个主分支上发布。   </p>
<p><iframe src="https://skydrive.live.com/embed?cid=1F260DE1061FCF3E&resid=1F260DE1061FCF3E%21130&authkey=AGTrDkY9-vGp3os" width="160" height="320" frameborder="0" scrolling="no"></iframe><br>Git主分支的名字，默认叫做Master。它是自动建立的，版本库初始化以后，默认就是在主分支在进行开发。</p>
<p>二、开发分支Develop</p>
<p>主分支只用来分布重大版本，日常开发应该在另一条分支上完成。我们把开发用的分支，叫做Develop。   </p>
<p><iframe src="https://skydrive.live.com/embed?cid=1F260DE1061FCF3E&resid=1F260DE1061FCF3E%21137&authkey=AKPfVNUBKokrRFU" width="289" height="320" frameborder="0" scrolling="no"></iframe><br>这个分支可以用来生成代码的最新隔夜版本（nightly）。如果想正式对外发布，就在Master分支上，对Develop分支进行”合并”（merge）。</p>
<p>Git创建Develop分支的命令：</p>
<pre><code>　　<span class="title">git</span> checkout -b develop master
</code></pre><p>将Develop分支发布到Master分支的命令：</p>
<pre><code>　　<span class="comment"># 切换到Master分支</span>
　　git checkout master

　　<span class="comment"># 对Develop分支进行合并</span>
　　git <span class="built_in">merge</span> <span class="comment">--no-ff develop</span>
</code></pre><p>这里稍微解释一下，上一条命令的—no-ff参数是什么意思。默认情况下，Git执行”快进式合并”（fast-farward merge），会直接将Master分支指向Develop分支。   </p>
<p><iframe src="https://skydrive.live.com/embed?cid=1F260DE1061FCF3E&resid=1F260DE1061FCF3E%21134&authkey=AN9912ePTGm_jHA" width="264" height="320" frameborder="0" scrolling="no"></iframe><br>使用—no-ff参数后，会执行正常合并，在Master分支上生成一个新节点。为了保证版本演进的清晰，我们希望采用这种做法。关于合并的更多解释，请参考Benjamin Sandofsky的<a href="http://sandofsky.com/blog/git-workflow.html" target="_blank" rel="external">《Understanding the Git Workflow》</a>。   </p>
<p><iframe src="https://skydrive.live.com/embed?cid=1F260DE1061FCF3E&resid=1F260DE1061FCF3E%21133&authkey=AGXTd8Ijt7ax2Nw" width="110" height="319" frameborder="0" scrolling="no"></iframe><br>三、临时性分支</p>
<p>前面讲到版本库的两条主要分支：Master和Develop。前者用于正式发布，后者用于日常开发。其实，常设分支只需要这两条就够了，不需要其他了。</p>
<p>但是，除了常设分支以外，还有一些临时性分支，用于应对一些特定目的的版本开发。临时性分支主要有三种：</p>
<pre><code>　　<span class="keyword">*</span> 功能（feature）分支

　　<span class="keyword">*</span> 预发布（release）分支

　　<span class="keyword">*</span> 修补bug（fixbug）分支
</code></pre><p>这三种分支都属于临时性需要，使用完以后，应该删除，使得代码库的常设分支始终只有Master和Develop。</p>
<p>四、 功能分支</p>
<p>接下来，一个个来看这三种”临时性分支”。</p>
<p>第一种是功能分支，它是为了开发某种特定功能，从Develop分支上面分出来的。开发完成后，要再并入Develop。   </p>
<p><iframe src="https://skydrive.live.com/embed?cid=1F260DE1061FCF3E&resid=1F260DE1061FCF3E%21135&authkey=APEKOZ5K-E-yHZE" width="176" height="320" frameborder="0" scrolling="no"></iframe><br>功能分支的名字，可以采用feature-*的形式命名。   </p>
<p><iframe src="https://skydrive.live.com/embed?cid=1F260DE1061FCF3E&resid=1F260DE1061FCF3E%21136&authkey=AHLTEmtvBwaY3dM" width="320" height="273" frameborder="0" scrolling="no"></iframe><br>创建一个功能分支：</p>
<pre><code>　　<span class="title">git</span> checkout -b feature-x develop
</code></pre><p>开发完成后，将功能分支合并到develop分支：</p>
<pre><code>　　git checkout develop

　　git <span class="operator"><span class="keyword">merge</span> <span class="comment">--no-ff feature-x</span></span>
</code></pre><p>删除feature分支：</p>
<pre><code>　　git branch <span class="operator">-d</span> feature-x
</code></pre><p>五、预发布分支</p>
<p>第二种是预发布分支，它是指发布正式版本之前（即合并到Master分支之前），我们可能需要有一个预发布的版本进行测试。</p>
<p>预发布分支是从Develop分支上面分出来的，预发布结束以后，必须合并进Develop和Master分支。它的命名，可以采用release-*的形式。</p>
<p>创建一个预发布分支：</p>
<pre><code>　　git checkout -b <span class="operator"><span class="keyword">release</span>-<span class="number">1.2</span> develop</span>
</code></pre><p>确认没有问题后，合并到master分支：</p>
<pre><code>　　git checkout master

　　git <span class="built_in">merge</span> <span class="comment">--no-ff release-1.2</span>

　　<span class="comment"># 对合并生成的新节点，做一个标签</span>
　　git tag -<span class="operator">a</span> <span class="number">1.2</span>
</code></pre><p>再合并到develop分支：</p>
<pre><code>　　git checkout develop

　　git <span class="operator"><span class="keyword">merge</span> <span class="comment">--no-ff release-1.2</span></span>
</code></pre><p>最后，删除预发布分支：</p>
<pre><code>　　git branch <span class="operator">-d</span> release-<span class="number">1.2</span>
</code></pre><p>六、修补bug分支</p>
<p>最后一种是修补bug分支。软件正式发布以后，难免会出现bug。这时就需要创建一个分支，进行bug修补。</p>
<p>修补bug分支是从Master分支上面分出来的。修补结束以后，再合并进Master和Develop分支。它的命名，可以采用fixbug-*的形式。</p>
<p>创建一个修补bug分支：</p>
<pre><code>　　<span class="title">git</span> checkout -b fixbug-<span class="number">0</span>.<span class="number">1</span> master
</code></pre><p>修补结束后，合并到master分支：</p>
<pre><code>　　git checkout master

　　git <span class="built_in">merge</span> <span class="comment">--no-ff fixbug-0.1</span>

　　git tag -<span class="operator">a</span> <span class="number">0.1</span><span class="number">.1</span>
</code></pre><p>再合并到develop分支：</p>
<pre><code>　　git checkout develop

　　git <span class="operator"><span class="keyword">merge</span> <span class="comment">--no-ff fixbug-0.1</span></span>
</code></pre><p>最后，删除”修补bug分支”：</p>
<pre><code>　　git branch <span class="operator">-d</span> fixbug-<span class="number">0.1</span>
</code></pre><p><br><br>原文网址：<a href="http://www.ruanyifeng.com/blog/2012/07/git.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2012/07/git.html</a></p>
]]></content>
         
         
           
             
              <breadCrumb title="git" url="http://blog.tinyxd.me/categories/git/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/07/09/add-douban-aside/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>给octopress博客添加豆瓣侧边栏</title>
        <pubTime>2012-07-09T14:38:00.000Z</pubTime>
        
        <tag>octopress </tag>
         
         <content><![CDATA[<p>1.添加<code>source/_includes/custom/asides/douban.html</code>   </p>
<p><script src="https://gist.github.com/3076932.js?file=douban.html"></script><br>其中<code>&lt;div&gt; &lt;/div&gt;</code>中间的代码从<a href="http://www.douban.com/service/badgemakerjs" target="_blank" rel="external">这里</a>获取，记得改成自己的哦！<br>2.在<code>_config.yml</code>中添加：<br>douban_user: XXX<br>(XXX为你的豆瓣用户名)<br>3.记得把这里（default_asides: ）加上douban.html的位置<br>然后，<code>rake generate</code> 和<code>rake preview</code>看看效果吧<br>类似微薄侧边浪也是这么弄的。<br><br></p>
]]></content>
         
         
           
             
              <breadCrumb title="octopress" url="http://blog.tinyxd.me/categories/octopress/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/07/09/reasons-for-quitting-it/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>IT生活：10个不干IT的理由</title>
        <pubTime>2012-07-08T16:16:00.000Z</pubTime>
        
        <tag>IT </tag>
         
         <content><![CDATA[<p>作者：Jack Wallen     来源：<a href="http://www.techrepublic.com" target="_blank" rel="external">http://www.techrepublic.com</a><br>摘要： 搞IT有很多好处——但是审时度势一下，你也许会考虑别的职业选择。Jack Wallen 阐述了哪些影响因素会成为压垮某些IT人士的最后一根稻草。</p>
<p>有谁起码有那么一两次快想不干了的？请举手。来吧，不要不好意思。IT的压力，没有最大，只有更大，路人皆知。更为不幸的是，大学并没有教你度过并坚守这些岁月的应对机制。我们来看看有哪些原因会导致你决意离开所挚爱的IT行业。</p>
<p>注：本文有<a href="http://www.techrepublic.com/downloads/10-reasons-for-quitting-it/2568617" target="_blank" rel="external">PDF版</a>可供下载。</p>
<p>1: 压力</p>
<p>千万不要相信IT很好做的鬼话。能拿到一个毫无压力的IT岗位这种情况少之又少。记住，IT就是灾难管理。一旦客户或用户打电话给你，几乎就是需要马上处置的紧急情况。且一旦你在做这些工作的时候，你最好任何事情都没有出错，因为出娄子的代价是一份合同或工作。更糟糕的是压力鲜见减轻的时候。日复一日，每一分每一秒，你干得越来越累，超出自己的意料。<br><a id="more"></a></p>
<p>2: 时间</p>
<p>如果你想找一份周一至周五、朝九晚五的工作，到别处去找——IT似乎是一份7乘24小时全天候不间断的工作。跟其他一般职业相比，做IT的不单要在办公室呆久一点，工作以外你还得拔高自己，以保证不被你后面那些家伙踩下去。还有一些人，他们虽不是你的客户或用户，却希望能免费利用你的知识让自己的电脑运转保持顺畅。</p>
<p>3: 薪水</p>
<p>如果你是独立承揽人，面临的其中一个最大的压力就是支付酬金。为了拿到报酬，我认得的顾问不得不施加威胁或聘请律师，这种情况数不胜数。而如果你是自由职业者，要是人家不给你钱你就没饭吃。这种压力很沉重。你没有那种优势，每周或半周支票会定时给你送来。锤炼自己的人际交往技巧是尽可能保持好关系的关键。良好的关系（即便是跟一些不那么好的人）有助于确保你最终拿到酬劳。（译注：看来美国人也有拖欠IT民工工资现象）</p>
<p>4: 人事</p>
<p>提出这一点实非我所愿。很久以前，我是那种充满朝气、乐观向上、人见人爱、花见花开、车见爆胎的好青年。自从做了咨询顾问以后，却发现自己成了被利用的对象，干得多、挣得少、怀才不遇、未受赏识，诸如此类。必须不断忍受着归隐山林、甩手不干这种想法的煎熬。这并不是说人之初，性本恶。而是一旦你有了IT的光环，人们似乎就会对你另眼相看。同一个躯体下，你既被视为救世主，又被当成原罪人，不堪重负。 </p>
<p>5: 上级</p>
<p>面对现实。没有多少个上级能理解你的工作。他们总认为你仅靠微薄成本、无需帮忙就能把一切搞定，他们还认为你对待客户应当像春天那样温暖，就好像他们个个人品都比你好。雪上加霜的是，上级希望你能够神奇地让那些PC顶用十几年。对责任和技术的理解误区导致了一件事：让你的工作成为不可能完成的任务。一旦高层事无巨细地插足你的部门管理，每一个不好的因素都会更加恶化。你了解自己的工作，你也知道自己了解自己的工作，但他们却不知道自己并不了解你的工作。如此一环扣一环，形成压力传递的恶性循环。 </p>
<p>6: 技术</p>
<p>你有没有经历过那样的日子，一时间似乎所有技术都跟你作对，看起来就好像是殊方异类？这时候你是不是只想着收拾自己的一切用品、逃之夭夭了事？ 这曾经是我不得不去处理的麻烦之一，既然我是在一家主要为Windows客户服务的咨询公司工作。有时候你能赢得战争，有时候你会输掉。但是胜利的日子总会被失败的日子所淹没。  </p>
<p>7: 竞争</p>
<p>有一件事你可以肯定 — 总会有人比你更出色。但在IT这个行当里面，它不是1:1这样的比例。相反，似乎每一个你这样的人后面总是总是有一百个更聪慧、更敏捷、更优秀的人出现。这种对比马上就会转化为收入差距。记住，IT的大势总是日新月异，如果你跟不上形势，你的饭碗是保不住的，也没人会雇你。我在这个行当待得越长，就越能意识到这是年轻人的游戏。要足够敏捷、工作能打持久战……总而言之你得面面俱到。我并不是说我们这些老家伙就经不起来回折腾。我们也能。但我们每工作一天，这个领域的竞争就累积多一点，这种竞争是残酷的。</p>
<p>8: 云端</p>
<p>每次听见电视上的演员说“腾云驾雾”的时候，我就恨不得扯掉自己的头发然后一脚踹烂电视机。云已经成为IT的一个不断变化的概念之一，“不知所云”，很有可能今后也一直如此。到底什么是“云”？我该不该用它？“云”安不安全？“云”多少钱一斤？我不断为这些问题抓狂。通常客户问到我这些问题的时候，我就反问他们用没用过谷歌文档（Google Docs），如果他们回答用过，我就告诉他们说他们已经用上“云”了。但这永远也不会令人满意的。客户和最终用户希望“云”能带来某种魔幻般的体验，能令其工作更简单、更出色、更快速。除非他们了解真相。</p>
<p>9: 无序</p>
<p>毫无疑问，如果某些规范能在整个IT范围得到应用的话，我们的生活会更美好。为了实现一组规范，许多开源项目已经竭尽所能，却只迎来被专利软件推翻的下场。那些专利软件供应商就是不想公开自己的代码，不跟规范兼容，以便让自己的腰包越鼓越好。我理解这一点，真的。但是只要他们拒绝遵守规范，就会让最终用户和IT专业人士每天都头疼无比。如果不能阻止专利软件供应商大发横财，遵守规范也就无从谈起。</p>
<p>10: 尊重</p>
<p>IT专业人士在公众中的口碑不好。为什么？其中有诸多原因。有的是一朝被蛇咬十年怕井绳。有的遇到的顾问似乎总是想向他们推销更大更好的东西。只要这些事情延续，公众就会变得疲倦，IT专业人士就难以赢得尊重。哦，当然，当他们看见你进门的时候，你是他们最好的朋友……那一刻是。 但是一旦你解决了那个“大难临头”的问题之后，要么赶紧拍拍屁股走人，要么就得不断强调你的所为已经超出了他们雇你的范围（或者超出了时间范围）。（译注：意思是说拿IT人当牛当马） </p>
<p>想打退堂鼓了吗？</p>
<p>这些IT工作的负面影响是不是已经超出了其积极面？如果不干IT的话你想从事什么职业？希望你能在评论中分享自己的观点。   </p>
<p><strong><em>如果你还是感同身受的IT人士，请帮顶支持一下</em></strong>   </p>
<p><strong><em>如果你是脱离苦海的非IT人士，请帮顶同情一下</em></strong><br>　看完了<a href="http://tinyxd.me/blog/07/09/reasons-for-quitting-it/" target="_blank" rel="external">《IT生活：10个不干IT的理由》</a>，下面再看看<a href="http://tinyxd.me/blog/2012/07/09/reasons-to-stay-in-it/" target="_blank" rel="external">《IT生活：10个继续干IT的理由》</a><br>本文转自：<a href="http://article.yeeyan.org/view/boxi/176955" target="_blank" rel="external">http://article.yeeyan.org/view/boxi/176955</a></p>
]]></content>
         
         
           
             
              <breadCrumb title="IT" url="http://blog.tinyxd.me/categories/IT/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/07/09/reasons-to-stay-in-it/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>IT生活：10个继续干IT的理由</title>
        <pubTime>2012-07-08T16:25:00.000Z</pubTime>
        
        <tag>IT </tag>
         
         <content><![CDATA[<blockquote>

<p>前面我们曾经分析过不要做IT的十个理由，现在反方有话要说了。一位曾经混迹IT江湖几进几出的过来人现身说法：“曾经有一份美好的工作摆在我的面前，我没有珍惜，等到失去时才后悔莫及。人生最悲哀的事情莫过于此。如果上天能再给我一次重来的机会，我会对那份工作说三个字：我爱你。如果非给这份职业加个期限，我希望是一万年！”</p>
</blockquote>

<p><br><br>作者：Alan Norton 2011年7月1日， 1:27 PM PDT<br>摘要： 不想干IT了？ Alan Norton就是这么想的，还不止一次。看看为什么他会说有10个理由继续呆在IT这个行当里。</p>
<p>在其文章<a href="http://article.yeeyan.org/view/boxi/176955" target="_blank" rel="external">《不干IT的十个理由》</a>中，Jack Wallen列举了一些离开IT这个行业的理由。而我呢，则愿意提供一个不同的观点，下面有我自己的一些思考，这些也许能对阐明为什么你应当留在IT有所帮助。</p>
<p>1: 钱，钱，钱</p>
<p>对，我们努力工作就是为了赚钱，而IT专业人士的努力工作的确得到了很好的补偿。报酬不仅仅是好而已，而是非常棒。根据美国劳工部<a href="http://www.bls.gov/oes/highlight_2010.pdf" target="_blank" rel="external">《2010年美国就业与报酬情况概览》</a>（表6，PDF）的统计数据 ，在所有的职业群体当中，计算机和数学2010年的排行并列第三，年均工资为77230美元。只有管理和法律的报酬比IT高。<br><br></p>
<p><a id="more"></a><br>2: 专业   </p>
<p>如果你跟我一样，跟谁在一起工作是件非常重要的事情。毕竟，在你生命里将会有超过四分之一的时间要跟他们在一起。我跟<a href="http://www.techrepublic.com/blog/10things/10-things-that-define-a-true-professional/1685" target="_blank" rel="external">专业的人</a>和<a href="http://www.techrepublic.com/blog/10things/10-toxic-character-types-youll-meet-on-the-job/2492" target="_blank" rel="external">不那么专业的人</a>都共事过。我倾向于接触前者、回避后者。我也在别的职业领域遇到过专业人士，如果要我列举说明的话，比如说国防工业，但是IT的专业人士依旧排行前列。  </p>
<p>3: 职业连续性</p>
<p>我第二次离开IT的时候，就只想着休息，什么事都不做。然后我发现（太迟了）离开自己的职业后想要返回会更加困难。最大的问题是潜在的老板会怎么看你。老板不希望看到你的履历中出现断层。这种不幸的机会可能会被你撞上，那就是你会发现<a href="http://www.techrepublic.com/blog/career/are-the-jobless-discriminated-against-in-hiring/3072" target="_blank" rel="external">对失业的歧视的真实性存在</a>会给你带来一条艰困之道。<br>4: 挑战</p>
<p>我现则写计算机程序的其中一个理由是我发现它充满挑战。在编写代码的时候，前进的道路上没有一天是不会遇到至少一个障碍的。IT专业人士在解决困惑和问题中成长。有了正确的态度（这对于在IT上取得成功是必不可少的），障碍就会变成挑战。信息技术是充满挑战，但是你却不会感到厌烦。无论你在IT里面的角色怎样，你明天所遇到的挑战很可能就会跟今天所经历的不一样。<br>5: 回报<br>当你遇到挑战的时候是有回报的——这是选择并留在这个行当的另一个理由。当自己写的程序按照设计运行，没有错误出现的时候，或者是当一个长期的系统项目成功地按时完成的时候，我的职业满意度就会前所未有地高。好吧，也许你对拯救生命并没有什么帮助。但是，如果实在为医疗人员提供支持的话，那么你就是在拯救生命。同时你也在拯救蓝领和白领工人，拯救他们于单调乏味的、可由、也应该由机器完成的任务之中。喜欢做繁重工作的人寥寥无几。我职业生涯中建设的系统替代了若干的无意义工作。坦率地说， 除了少数几段艰难时期，意识到我正在帮助别人把工作做得更好之后，我工作结束的时候都是满意地离开的。无论你在IT的众所担当的角色是什么，帮助别人并出色完成工作都会令人产生自尊感和成就感，这都是很高的回报。</p>
<p><a href="http://www.techrepublic.com/forum/discussions/102-342385-3430107?tag=discussion-thread" target="_blank" rel="external">正如TR的成员Chronological所说的那样</a>，“有史以来最具挑战的性工作？也许是。最有内涵的工作？——100%确定。”<br>6: 畅销</p>
<p>IT职业人员找工作保工作的机会要好得多。IT专业人士的前途一片光明——至少在美国是这样的。前20佳职业中有5个是IT岗位，前50大薪水最高且最具增长潜力的的职业里面有14个也是IT岗位，这是<a href="http://money.cnn.com/magazines/moneymag/bestjobs/2010/full_list/index.html" target="_blank" rel="external">CNN金钱与薪资表的调查结果</a>。<br>7: 技能<br>那些想干IT的人通常都是相当聪明的，都具有<a href="http://www.techrepublic.com/blog/10things/10-things-you-gotta-have-to-succeed-in-it/2421" target="_blank" rel="external">独特的品质</a>和技能。 IT吸引了<a href="http://www.techrepublic.com/blog/10things/10-curses-of-the-analytical-thinker/2466" target="_blank" rel="external">分析型人士</a>并让世界发生技术性倾斜。如果你具备这些品质和技能，你就能在IT找到一个家。</p>
<p>另一个留在IT的好理由是让你的技能与时俱进。离开IT太久的话的你的技能就会过时或者甚至被淘汰。在你离开IT之前，想想吧，是你的老板出钱让你学习新技能并保持已有技能跟得上形势。那些技能是对你未来的投资。</p>
<p>8: 尊重<br>Jack在他的文章中提到，IT专业人士得不到大众的尊重。我从在论坛的反馈中得知你们当中有许多人都同意这一点，并感觉到自己没有得到威望以及渴望中的尊重。如果你自己的工作干得很出色却感到缺乏尊重，也许其原因要归咎于旁观者地无知，而非你自己的过失。</p>
<p>公众也许是块硬骨头，但是你可以在你的同事那里获得尊重。富于知识和智慧的专业人士重视他人的贡献，并会表明其对同事的尊重。IT是赢得尊重的好地方。如果你不能够在IT这个领域赢得尊重，那么很有可能在别的任何地方也得不到它。</p>
<p>也许只是我本人比较幸运或幼稚了点，但我一直都认为自己赢得了经理、助手和客户的尊重。可能最重要的是，尊重是一种态度，你的态度，以及你对别人如何看待你的感知。<br>9: 极客</p>
<p>IT是满足你对极端技术之渴望的绝佳场所。还有什么别的地方既能够满足你的极客需求又能为此付钱给你的呢？ 如果你享受按字节、GHz、图表、里程碑，还有IF THEN ELSE语句进行思考的方式，你就会喜欢上跟你有着共同兴趣和相同的独特语言的他人共事。</p>
<p>10: 热爱<br>许多选择干IT的人热爱这项事业。快点承认吧。在内心深处你热爱自己的工作。就那些不是这样的人来说，那也是相对而言的。在考虑其他面向大众的工作及其薪水时，你就会热爱上IT。如果你从自身和自己的IT工作上面找不出一丝的热爱，那么也许分道扬镳的时候快到了。</p>
<p>也许<a href="http://www.techrepublic.com/forum/discussions/102-254217-2432699?tag=discussion-thread" target="_blank" rel="external">讲得最好</a>的是在一次讨论中IT_Goddess的说法： “有多少人能够说自己真的喜欢乃至热爱自己的工作？我认识的好多人，都不是干IT的，都害怕投入工作。而我认识的大多IT人士，只要他们的实际工作能够获得应有的补偿，他们都很热爱自己的工作。”</p>
<p>总结<br>我曾在“正规”IT这个行当中几进几出。已经从挫折这所学校里面了解到了许多坚守下来的理由。说实话，或多或少地，上述每一条我都有做不到的地方。当你真正了解了干IT的基本理由之后，你就会知道，是IT而不是别的职业能够满足技术头脑的更多需求。况且IT工作十分好工作。根据《华尔街日报》的说法， <a href="http://online.wsj.com/article/SB10001424052748704723104576062173458318658.html" target="_blank" rel="external">2011年前5佳工作里面有2个</a>是IT的：即软件工程师和系统分析师。</p>
<p>当然，我太了解哪些日常琐碎的折磨人之处了，身兼重担日复一日的压力，漫长、疲惫的时光以及众多永不见天日的坎坷挫折。一旦你的注意力停留在核销掉又一条待办事宜列表，再回复一封电子邮件这些小事情的时候，不难理解你会只见树木不见森林。我想，意识不到自己当时所处的积极面乃是人之本性。正如琼尼·蜜雪儿（Joni Mitchell，加拿大歌手）<a href="http://www.youtube.com/watch?v=ZgMEPk6fvpg" target="_blank" rel="external">曾说过那样</a>， “它似乎永远不会走，直到它真的走了，你得到了什么自己才知道。”真的，考虑到IT这么多的好处，没必要像我曾经做过的那样离开IT。   </p>
<p>本文转自：<a href="http://www.yixieshi.com/zhichang/8072.html" target="_blank" rel="external">http://www.yixieshi.com/zhichang/8072.html</a>   </p>
]]></content>
         
         
           
             
              <breadCrumb title="IT" url="http://blog.tinyxd.me/categories/IT/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/07/10/linux-filesysterm/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>linux文件系统</title>
        <pubTime>2012-07-10T15:26:00.000Z</pubTime>
        
        <tag>linux </tag>
         
        <tag>kernel </tag>
         
         <content><![CDATA[<p>linux文件操作：文件操作系统调用（create、open、read、write、lseek、close）、c库文件操作（fopen、fscanf、fprintf、fread、fwrite、fseek、fclose等）。 </p>
<p>linux文件系统：在设备驱动程序的设计中，一般会关心file和inode这两个结构体。 </p>
<h2 id="devfs、udev、sysfs的区别：">devfs、udev、sysfs的区别：</h2>
<p>以下内容来自<a href="http://blog.csdn.net/yeqishi/article/details/5491413" target="_blank" rel="external">devfs, sysfs, udev文件系统区别</a> 和 linux设备驱动开发详解（第二版） </p>
<h3 id="一-devfs设备文件简略介绍(2-6版本以后内核都采用udev设备文件系统)">一.devfs设备文件简略介绍(2.6版本以后内核都采用udev设备文件系统)</h3>
<p>devfs(设备文件系统)是由2.4内核引入的，具有如下优点： </p>
<p>1.可以通过程序在设备初始化时在/dev目录下创建设备文件，卸载时将它删除。 </p>
<p>2.设备驱动程序可以指定设备号,所有者,和权限位,用户空间可以修改所有者和权限位。 </p>
<p>3.不再需要为设备驱动程序分配主设备号以及处理的次设备号，在程序可以直接给register_chrdev()传递0主设备号以动态获得可用的主设备号，并在devfs_register() 中指定次设备号。<br><a id="more"></a><br>在2.6内核以前一直使用的是 devfs，devfs挂载于/dev目录下，提供了一种类似于文件的方法来管理位于/dev目录下的所有设备，我们知道 /dev目录下的每一个文件都对应的是一个设备，至于当前该设备存在与否先且不论，而且这些特殊文件是位于根文件系统上的，在制作文件系统 的时候我们就已经建立了这些设备文件，因此通过操作这些特殊文件，可以实现与内核进行交互。但是devfs文件系统有一些缺点，例如：不确定的设备映射，有时一个设备映射的设备文件可能不同，例如我的U盘可能对应sda有可能对应sdb；没有足够的主/辅设备号，当设备过多的时候，显然这会成为一个问题；/dev目录下文件太多而且不能表示当前系统上的实际设备；命名不够灵活，不能任意指定等等。<br><br></p>
<h3 id="二-sysfs">二.sysfs</h3>
<p>从Fedora 2开始，在根目录下会有一个/sys目录，mount 看一下，这个目录挂装了一个sysfs的文件系统。 </p>
<p>Linux 2.6 的内核引入了 sysfs 文件系统。sysfs 被看成是与 proc，devfs，和 devpty 同类别的文件系统。sysfs 把连接在系统上的设备和总线组织成为一个分级的文件，它们可以被从用户的空间存取到。这是被设计用来处理那些以前驻留在 /proc/ 的设备和驱动程序指定的选件以及用来处理那些以前由 devfs 提供支持的动态加载设备。在早期的 sysfs 实现中，一些驱动和应用仍然被当做老的 proc 条目。但是 sysfs 是未来的发展方向。 </p>
<p>sysfs 被加载在 /sys/ 系统中。它所包括的目录可以使用不同的方式来治理连接在系统上的设备。/sysfs/ 中的子目录包括： </p>
<p>/devices/ 目录这个目录包括 /css0/。它的子目录代表了所有被 Linux 内核检测到的子通道。子通道目录的命名格式是 0.0.nnnn，其中的 nnnn 是子通道的十六进制代码 (0到ffff)。子通道目录包括状态文件和其他代表实际设备的设备子目录。设备目录的格式是：0.0.xxxx，其中的 xxxx 是这个设备的单元地址。/devices/ 还包括了状态信息和设备的配置选项。 </p>
<p>/bus/ 目录这个目录包括了 /ccw/ 和 /ccwgroup/ 两个子目录。CCW 设备可以通过使用通道命令来存取。在 /ccw/ 目录中的设备只使用一个子通道。CCW 组设备也可以通过使用通道命令来存取，但是它们的每个设备使用多于一个的子通道。比如：一个3390-3 DASD 设备使用一个子通道，但是一个 OSA 适配器的 QDIO 网络连接使用三个子通道。/ccw/ 和 /ccwgroup/ 目录都包括设备目录和驱动器目录： </p>
<p>/devices/ 目录包括了到 /sys/devices/css0/ 目录的设备目录的符号链接。/drivers 目录包括了所有由代表当前被系统加载的设备的驱动程序的目录。zFCP 驱动程序有一个目录在这里。/driver/ 目录包括了设备驱动程序的设置和它使用的符号链接 (/sys/devices/css0/ 目录)/class/ 目录/class/ 目录包括了代表由相似功能的设备组成的组 (ttys，SCSI 磁带驱动器，网络设备…)的目录。 </p>
<p>/block/ 目录这个目录包括了系统中的每一个块设备的目录。块设备主要是磁盘类的设备，例如 DASD，回送设备，以及软件磁盘冗余阵列设备。一个与老版本 Linux 不同的是，使用 sysfs 系统的 Linux 需要使用设备在 sysfs 中的名字来指定设备。在一个 2.4 版本的内核映像中，zFCP 驱动程序是由它的设备地址来指定的。但是在 2.6 版本的内核映像中，它的驱动程序是由 0.0.1600 来指定的。<br><br></p>
<h3 id="三-udev设备文件详细介绍">三.udev设备文件详细介绍</h3>
<p>   devfs 存在的主要的问题是它处理设备检测、创建和命名的方式，其中设备节点的命名可能是最严重的问题。一般可接受的方式是，如果设备名是可配置的，那么设备命名策略应该由系统管理员决定，而不是由某些开发者强制规定。devfs 文件系统还存在竞争条件(race conditions)的问题，这是它天生的设计缺陷，不对内核做彻底的修改就无法修正这个问题。 </p>
<p>   上篇文章简单介绍sysfs文件系统，您可能想知道 sysfs 是怎么认出系统中存在的设备以及应该使用什么设备号。对于已经编入内核的驱动程序，当被内核检测到的时候，会直接在 sysfs 中注册其对象；对于编译成模块的驱动程序，当模块载入的时候才会这样做。一旦挂载了 sysfs 文件系统(挂载到 /sys)，内建的驱动程序在 sysfs 注册的数据就可以被用户空间的进程使用，并提供给 udev 以创建设备节点。 </p>
<p>   udev 初始化脚本负责在 Linux 启动的时候创建设备节点，该脚本首先将 /sbin/udevsend 注册为热插拔事件处理程序。热插拔事件(随后将讨论)本不应该在这个阶段发生，注册 udev 只是为了以防万一。然后 udevstart 遍历 /sys 文件系统，并在 /dev 目录下创建符合描述的设备。例如，/sys/class/tty/vcs/dev 里含有”7:0”字符串，udevstart 就根据这个字符串创建主设备号为 7 、次设备号为0 的 /dev/vcs 设备。udevstart 创建的每个设备的名字和权限由 /etc/udev/rules.d/ 目录下的文件指定的规则来设置。如果 udev 找不到所创建设备的权限文件，就将其权限设置为缺省的 660 ，所有者为 root:root 。 </p>
<p>   上面的步骤完成后，那些已经存在并且已经内建驱动的设备就可以使用了，那么以模块驱动的设备呢？ </p>
<p>   前面我们提到了”热插拔事件处理程序”的概念，当内核检测到一个新设备连接时，内核会产生一个热插拔事件， </p>
<p>   并在 /proc/sys/kernel/hotplug 文件里查找处理设备连接的用户空间程序。udev 初始化脚本将 udevsend 注册为该处理程序。 </p>
<p>   当产生热插拔事件的时候，内核让 udev 在 /sys 文件系统里检测与新设备的有关信息，并为新设备在 /dev 里创建项目。 </p>
<p>   大多数 Linux 发行版通过 /etc/modules.conf 配置文件来处理模块加载，对某个设备节点的访问导致相应的内核模块被加载。对 udev 这个方法就行不通了，因为在模块加载前，设备节点根本不存在。为了解决这个问题，在 LFS-Bootscripts 软件包里加入了 modules 启动脚本，以及 /etc/sysconfig/modules 文件。通过在 modules 文件里添加模块名，就可以在系统启动的时候加载这些模块，这样 udev 就可以检测到设备，并创建相应的设备节点了。如果插入的设备有一个驱动程序模块但是尚未加载，Hotplug 软件包就有用了，它就会响应上述的内核总线驱动热插拔事件并加载相应的模块，为其创建设备节点，这样设备就可以使用了。 </p>
<p>   udev是一种工具，它能够根据系统中的硬件设备的状况动态更新设备文件，包括设备文件的创建，删除等。设备文件通常放在/dev目录下，使用udev 后,在/dev下面只包含系统中真实存在的设备。它于硬件平台无关的，位于用户空间，需要内核sysfs和tmpfs的支持，sysfs为udev提供设备入口和uevent通道，tmpfs为udev设备文件提供存放空间。 </p>
<p>   显而易见<code>udev设备文件的优点</code>： </p>
<p>   1.udev完全在用户态工作，利用设备加入或移除时内核所发送的热插拔事件。在热插拔时，设备的详细信息会由内核输出到位于/sys的sysfs文件系统。udev的设备命名策略权限控制都在用户态完成的，它利用sysfs信息来进行创建设备文件节点。 </p>
<p>   2.udev根据系统中的硬件设备的状态动态更新设备文件，进行设备文件的创建和删除等。 </p>
<p>   注：使用udev,/dev目录下就会只包含系统中真正存在的设备。 </p>
<p>   注：所有在 sysfs 中显示的设备都可以由 udev 来创建节点。如果内核中增加了其它设备的支持， </p>
<p>   udev 也就自动地可以为它们工作了。在init初始化之前，udev 可以被放入 initramfs 之中，并在每个设备被发现的时候运行。 </p>
<p>   也可以让udev 工作在一个真的根分区被加载之后根据 /sys 的内容创建的初始 /dev 目录之中<br><br></p>
<h3 id="四-udev和devfs设备文件的对比">四.udev和devfs设备文件的对比</h3>
<p>1.udev能够实现所有devfs实现的功能。但udev运行在用户模式中，而devfs运行在内核中。 </p>
<p>2.当一个并不存在的 /dev 节点被打开的时候， devfs一样自动加载驱动程序而udev确不能。 </p>
<p>  udev设计时，是在设备被发现的时候加载模块，而不是当它被访问的时候。 </p>
<p>  devfs这个功能对于一个配置正确的计算机是多余的。系统中所有的设备都应该产生 </p>
<p>  hotplug 事件、加载恰当的驱动，而 udev 将会注意到这点并且为它创建对应的 </p>
<p>  设备节点。如果你不想让所有的设备驱动停留在内存之中，应该使用其它东西来 </p>
<p>  管理你的模块 (如脚本, modules.conf, 等等) 。 </p>
<p>  其中devfs 用的方法导致了大量无用的 modprobe 尝试，以此程序探测设备是否存在。 </p>
<p>  每个试探性探测都新建一个运行 modprobe 的进程，而几乎所有这些都是无用的。 </p>
<p>3.udev是通过对内核产生的设备名增加别名的方式来达到上述目的的。前面说过，udev是用户模式程序，不会更改内核的行为。 </p>
<p>因此，内核依然会我行我素地产生设备名如sda,sdb等。但是，udev可以根据设备的其他信息如总线（bus），生产商（vendor）等 </p>
<p>不同来区分不同的设备，并产生设备文件。udev只要为这个设备文件取一个固定的文件名就可以解决这个问题。在后续对设备的操作中， </p>
<p>只要引用新的设备名就可以了。但为了保证最大限度的兼容，一般来说， </p>
<p>新设备名总是作为一个对内核自动产生的设备名的符号链接（link）来使用的。 </p>
<p><strong>例如</strong>：内核产生了sda设备名，而根据信息，这个设备对应于是我的内置硬盘，那我就可以制定udev规则，让udev除了产生/dev/sda设备文件外，另外创建一个符号链接叫/dev/internalHD。这样，我在fstab文件中，就可以用/dev/internalHD来代替原来的 /dev/sda了。下次，由于某些原因，这个硬盘在内核中变成了sdb设备名了，那也不用着急，udev还会自动产生/dev/internalHD这个链接，并指向正确的/dev/sdb设备。所有其他的文件像fstab等都不用修改。 </p>
<p>而在在2.6内核以前一直使用的是 devfs，devfs挂载于/dev目录下，提供了一种类似于文件的方法来管理位于/dev目录下的所有设备，但是devfs文件系统有一些缺点，例如：不确定的设备映射，有时一个设备映射的设备文件可能不同，例如我的U盘可能对应sda有可能对应sdb 。 </p>
<p>注：可以用命令查看其中的信息，    udevinfo -a -p /sys/block/sda </p>
<p>在此之前的设备文件管理方法（静态文件和devfs）有几个缺点： </p>
<p><strong> 不确定的设备映射。</strong>特别是那些动态设备，比如USB设备，设备文件到实际设备的映射并不可靠和确定。举一个例子：如果你有两个USB打印机。一个可能称为 /dev/usb/lp0,另外一个便是/dev/usb/lp1。但是到底哪个是哪个并不清楚，lp0,lp1和实际的设备没有一一对应的关系，因为他可能因为发现设备的顺序，打印机本身关闭等原因而导致这种映射并不确定。理想的方式应该是：两个打印机应该采用基于他们的序列号或者其他标识信息的唯一设备文件来映射。但是静态文件和devfs都无法做到这点。 </p>
<p><strong>没有足够的主/辅设备号。</strong>我们知道，每一个设备文件是有两个8位的数字：一个是主设备号 ，另外一个是辅设备号来分配的。这两个8位的数字加上设备类型（块设备或者字符设备）来唯一标识一个设备。不幸的是，关联这些身边的的数字并不足够。 </p>
<p><strong>/dev目录下文件太多。</strong>一个系统采用静态设备文件关联的方式，那么这个目录下的文件必然是足够多。而同时你又不知道在你的系统上到底有那些设备文件是激活的。 </p>
<p><strong>命名不够灵活。</strong>尽管devfs解决了以前的一些问题，但是它自身又带来了一些问题。其中一个就是命名不够灵活；你别想非常简单的就能修改设备文件的名字。缺省的devfs命令机制本身也很奇怪，他需要修改大量的配置文件和程序。; </p>
<p><strong>内核内存使用</strong>，devfs特有的另外一个问题是，作为内核驱动模块，devfs需要消耗大量的内存，特别当系统上有大量的设备时（比如上面我们提到的系统一个上有好几千磁盘时） </p>
<p>udev的目标是想解决上面提到的这些问题，他通采用用户空间(user-space)工具来管理/dev/目录树，他和文件系统分开。知道如何改变缺省配置能让你如何定制自己的系统，比如创建设备字符连接，改变设备文件属组，权限等。 </p>
]]></content>
         
         
           
             
              <breadCrumb title="linux" url="http://blog.tinyxd.me/categories/linux/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/05/23/octopressan-zhuang-bi-ji/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>Octopress安装笔记</title>
        <pubTime>2012-05-22T23:16:00.000Z</pubTime>
        
        <tag>octopress </tag>
         
         <content><![CDATA[<p>在阅读此教程之前，先安装git和ruby环境。</p>
<p><strong>1.安装ruby环境</strong></p>
<p>如果已经安装了ruby,就不用安装rvm 了。<br>Archlinux用户建议用pacman 安装ruby,方便省事。</p>
<p>Archlinux安装RVM教程：<br><a href="https://wiki.archlinux.org/index.php/RVM" target="_blank" rel="external">archlinux安装RVM教程</a></p>
<pre><code>[tinyxd<span class="variable">@archbang</span>  ~]<span class="variable">$ </span>sudo bash &lt; &lt;(curl -s <span class="symbol">https:</span>/<span class="regexp">/raw.github.com/wayneeseguin</span><span class="regexp">/rvm/master</span><span class="regexp">/binscripts/rvm</span>-installer )
</code></pre><p>添加当前用户到rvm 组<br>    [tinyxd@archbang  ~]$ sudo usermod -a -G rvm admin</p>
<p>查看下添加成功了没：<br>    [tinyxd@archbang ~]$ grep rvm /etc/group<br>    rvm:x:1004:admin</p>
<p>再注销，登录。</p>
<blockquote>
<p>To start using RVM you need to run <code>source /etc/profile.d/rvm.sh</code> in all your open shell windows, in rare cases you need to reopen all shell windows.</p>
</blockquote>
<p>已经安装了ruby的就可以从这里开始了。<br><a id="more"></a><br><strong>2.安装依赖</strong></p>
<pre><code>[tinyxd@archbang ～]$ gem install bundler
<span class="label">WARNING:  </span>You don't have /home/tinyxd/.gem/ruby/1.9.1/bin in your PATH,
<span class="code">      gem executables will not run.</span>
vim ~/.bashrc
#for ruby gem
PATH=$PATH:~/.gem/ruby/1.9.1/bin
export PATH
</code></pre><p>注意路径后面不能带/，不然它还是会报错。<br>    [tinyxd@archbang ~]$ sudo gem install bundler<br>    [tinyxd@archbang ~]$ cd ovtopress/<br>    [tinyxd@archbang ~]$ bundle install<br>    [tinyxd@archbang ~]$ rake install<br>    rake aborted!<br>    You have already activated rake 0.9.2.2, but your Gemfile requires rake 0.9.2. Using bundle exec may solve this.</p>
<pre><code>(See full trace <span class="keyword">by</span> <span class="property">running</span> task <span class="keyword">with</span> <span class="comment">--trace)</span>
</code></pre><p>出现上述问题，按以下方法解决：<br>    bundle update<br>    rake install<br>    [tinyxd@archbang octopress]$ rake install</p>
<pre><code>## Copying classic theme into ./<span class="keyword">source</span> <span class="built_in">and</span> ./sass
<span class="built_in">mkdir</span> -<span class="keyword">p</span> <span class="keyword">source</span>
<span class="keyword">cp</span> -<span class="keyword">r</span> .themes/classic/<span class="keyword">source</span>/. <span class="keyword">source</span>
<span class="built_in">mkdir</span> -<span class="keyword">p</span> sass
<span class="keyword">cp</span> -<span class="keyword">r</span> .themes/classic/sass/. sass
<span class="built_in">mkdir</span> -<span class="keyword">p</span> <span class="keyword">source</span>/_posts
<span class="built_in">mkdir</span> -<span class="keyword">p</span> public
</code></pre><p><strong>3.Deploying to Github Pages</strong></p>
<p><a href="http://octopress.org/docs/deploying/github/" target="_blank" rel="external">http://octopress.org/docs/deploying/github/</a></p>
<p>首次deploy 之前的准备活动<br>创建 username.github.com 仓库<br>执行rake setup_github_pages来设置。</p>
<pre><code>[tinyxd@archbang octopress]$ rake setup_github_pages
Enter the read/write url for your repository: git@github.com:akm/akm.github.com.git
Added remote git@github.com:akm/akm.github.com.git as origin
<span class="operator"><span class="keyword">Set</span> origin <span class="keyword">as</span> <span class="keyword">default</span> remote
<span class="keyword">Master</span> branch renamed <span class="keyword">to</span> <span class="string">'source'</span> <span class="keyword">for</span> committing your blog source files
rm -rf _deploy
mkdir _deploy
cd _deploy
Initialized empty Git repository <span class="keyword">in</span> /home/admin/public_html/octopress/_deploy/.git/
[<span class="keyword">master</span> (root-<span class="keyword">commit</span>) ff105cf] Octopress init
 <span class="number">1</span> file <span class="keyword">changed</span>, <span class="number">1</span> insertion(+)
 <span class="keyword">create</span> <span class="keyword">mode</span> <span class="number">100644</span> <span class="keyword">index</span>.html
cd -

<span class="comment">---</span>
## <span class="keyword">Now</span> you can deploy <span class="keyword">to</span> http://ihacklog.github.com <span class="keyword">with</span> <span class="string">`rake deploy`</span> ##</span>
</code></pre><blockquote>
<p>This will:Ask you for your Github Pages repository url.Rename the remote pointing to imathis/octopress from ‘origin’ to ‘octopress’.Add your Github Pages repository as the default origin remote.Switch the active branch from master to source.Configure your blog’s url according to your repository.Setup a master branch in the _deploy directory for deployment.</p>
</blockquote>
<p>生成静态页面：<br>    [tinyxd@archbang octopress]$ rake generate<br>把源码push搭配github上<br>    git add .<br>    git commit -m “commit the source for my Octopress blog”<br>    git push origin source</p>
<p>Configuring Octopress配置略，见 <a href="http://octopress.org/docs/configuring/" target="_blank" rel="external">http://octopress.org/docs/configuring/</a></p>
<p>写日志<br>    rake new_post[“文章标题”] #新建页面<br>    rake new_page[super-awesome]</p>
<p>详见 <a href="http://octopress.org/docs/blogging/" target="_blank" rel="external">http://octopress.org/docs/blogging/</a><br>写完了之后</p>
<pre><code>rake <span class="keyword">generate</span>
rake deploy
</code></pre><p>如果想本地预览一下效果，可以用</p>
<pre><code><span class="title">rake</span> preview
</code></pre><p>要注意的是，如果修改源码和配置，是在source 分支修改和提交。<br>而发布日志，也是在source分支，rake deploy会自动将生成的静态页面push到master分支。因此，master分支的内容不用你管。</p>
<blockquote>
<p>插一句：如果以后要从另一个电脑pull源码来新电脑，用如下命令：<br>    cd your_local_octopress_directory<br>    cd _deploy<br>    git pull origin master<br>    cd ..<br>    git pull origin source<br>只要记住“your_local_octopress_directory”对应的的remote source branch，而”_deploy”对应的是remote master branch即可。</p>
<p>   如果你是和别人合作博客，或者自己同时在好几个电脑上写博客，每次开始之前，git pull origin source获得最新的文件,rake generate生成新的页面</p>
</blockquote>
<pre><code>我们在source分支做了博客的发布，或者改变了博客的设置之后，rake generate生成网站

rake watch+pow 或者rake review+<span class="method">http:</span>//<span class="method">localhost:</span><span class="number">4000</span>就可以看到我们所做的变化

确认无误后，rake deploy文章就发布到了博客中

当然，不要忘了更新项目 git push origin source

特别的，如果你克隆了博客，记得在git checkout source，然后rake setup_github_pages执行初始化，当然，在那之前也需要bundle install，然后rake generate就生成页面了.

如果是新建的<span class="class">Repo</span> ，记得
<span class="char">$ </span>mkdir yourrepo
<span class="char">$ </span>cd yourrepo
<span class="char">$ </span>git init
# 其实这这时如果你多新建一个index.html文件的话，github会为你生成一个jekyll博客。
<span class="char">$ </span>touch <span class="class">README</span>
<span class="char">$ </span>git add .
<span class="char">$ </span>git commit -m <span class="string">'first commit'</span>
<span class="char">$ </span>git remote add origin git@github.<span class="method">com:</span>username/yourname.github.com.git
<span class="char">$ </span>git push origin master
</code></pre><blockquote>
<p>对于新手有几个提醒:</p>
</blockquote>
<pre><code>时常git status,git <span class="built_in">log</span>避免误操作
不要在github上直接编辑文件
想清楚了再下手
</code></pre><blockquote>
<p>  github pages的 username 大小写敏感。如果用户名和username不一致的话,默认会生成这个Repo的project pages。</p>
</blockquote>
<p>rake watch 检测文件变化，实时生成新内容<br>rake preview 监听本机4000端口，可查看生成页面效果。</p>
<p>个性化<br>文档： <a href="http://octopress.org/docs/theme/template/" target="_blank" rel="external">http://octopress.org/docs/theme/template/</a><br>修改定制文件/source/_includes/custom/head.html 把google的自定义字体去掉或自行定义，如我的（自己下载了google font)：<br>1<br>2</p>
<p><link href="/assets/font/PT_Serif.css" rel="stylesheet" type="text/css"></p>
<link href="/assets/font/PT_Sans.css" rel="stylesheet" type="text/css">

<p>我把下载的google font放在 source/assets/font 目录下面。</p>
<p>图片发布<br>我把图片放在source/static 目录。<br>在文章中引用（注意URL前面的/)：</p>
<pre><code>![<span class="link_label"> Ultrablog.vim post title bug </span>](<span class="link_url">/static/2012/04/UltraBlog-post-title-bug.png</span>)
</code></pre><p>个性域名<br>先去给域名建立一个CNAME记录，指向 username.github.com ,如 ihacklog.github.com<br>在source目录下建一个名为CNAME的文件，然后将自己的域名输入进去<br>如：</p>
<p>tinyxd.tk</p>
<p>文档： <a href="http://help.github.com/pages/" target="_blank" rel="external">http://help.github.com/pages/</a></p>
<p>其它，如sidebar的修改等，可参考文档。<a href="http://octopress.org/docs/theme/template/" target="_blank" rel="external">http://octopress.org/docs/theme/template/</a><br>我这就不写了。<br>主题的修改参考了这篇文章<a href="http://melandri.net/2012/02/14/octopress-theme-customization/" target="_blank" rel="external">Octopress Theme Customization</a>，以后自己研究下css，做个自己的。</p>
<p>其它可参考的文章： <a href="http://blog.devtang.com/blog/2012/02/10/setup-blog-based-on-github/" target="_blank" rel="external">http://blog.devtang.com/blog/2012/02/10/setup-blog-based-on-github/</a>   </p>
<p><strong>一些技术：</strong><br><a href="https://github.com/mojombo/jekyll" target="_blank" rel="external">https://github.com/mojombo/jekyll</a> 静态页面发布技术，使用 Textile or Markdown and Liquid converters，是Github页面引擎背后的技术。<br><a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="external">http://daringfireball.net/projects/markdown/</a> 简单的标记语言，现在很多编辑器支持，快速编写并可编译成HTML、LaTeX等格式。<br><a href="http://gembundler.com/" target="_blank" rel="external">http://gembundler.com/</a> 将一个应用需要的Ruby软件包写入一个Gemfile文件，当应用安装时可以用Bundle命令自动从服务器上下载需要的软件包。<br><a href="http://rack.rubyforge.org/" target="_blank" rel="external">http://rack.rubyforge.org/</a> 基于Ruby的web服务器界面。<br><a href="http://pow.cx/" target="_blank" rel="external">http://pow.cx/</a> 配置好的Rack服务，即开即用。<br><a href="http://rake.rubyforge.org/" target="_blank" rel="external">http://rake.rubyforge.org/</a> 用Ruby写成的Make，批处理操作。<br><a href="http://sass-lang.com/" target="_blank" rel="external">http://sass-lang.com/</a> CSS3扩展，方便编写CSS并提供更多功能。<br><a href="http://ethanschoonover.com/solarized" target="_blank" rel="external">http://ethanschoonover.com/solarized</a> 一套便于阅读的代码配色方案。<br><a href="https://github.com/" target="_blank" rel="external">https://github.com/</a> 代码平台，基于git。<br><a href="http://www.heroku.com/" target="_blank" rel="external">http://www.heroku.com/</a> 云计算平台，发布非常方便。  </p>
]]></content>
         
         
           
             
              <breadCrumb title="octopress" url="http://blog.tinyxd.me/categories/octopress/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/07/11/soft-interrupt-and-tasklet/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>软中断和tasklet</title>
        <pubTime>2012-07-11T14:57:00.000Z</pubTime>
        
        <tag>linux </tag>
         
        <tag>kernel </tag>
         
         <content><![CDATA[<h2 id="软中断：">软中断：</h2>
<p>Linux中的软中断机制用于系统中对时间要求最严格以及最重要的中断下半部进行使用。在系统设计过程中，大家都清楚中断上下文不能处理太多的事情，需要快速的返回，否则很容易导致中断事件的丢失，所以这就产生了一个问题：中断发生之后的事务处理由谁来完成？在前后台程序中，由于只有中断上下文和一个任务上下文，所以中断上下文触发事件，设置标记位，任务上下文循环扫描标记位，执行相应的动作，也就是中断发生之后的事情由任务来完成了，只不过任务上下文采用扫描的方式，实时性不能得到保证。在Linux系统和Windows系统中，这个不断循环的任务就是本文所要讲述的软中断daemon。在Windows中处理耗时的中断事务称之为中断延迟处理，在Linux中称之为中断下半部，显然中断上半部处理清中断之类十分清闲的动作，然后在退出中断服务程序时触发中断下半部，完成具体的功能。</p>
<p>在Linux中，中断下半部的实现基于软中断机制。所以理清楚软中断机制的原理，那么中断下半部的实现也就非常简单了。通过上述的描述，大家也应该清楚为什么要定义软中断机制了，一句话就是为了要处理对时间要求苛刻的任务，恰好中断下半部就有这样的需求，所以其实现采用了软中断机制。</p>
<p>linux2.6中使用的软中断：</p>
<figure class="highlight c"><figcaption><span>interrupt.h</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span></div><div class="line">{</div><div class="line">	HI_SOFTIRQ=<span class="number">0</span>, <span class="comment">/*用于高优先级的tasklet(下标(优先级0))*/</span></div><div class="line">	TIMER_SOFTIRQ, <span class="comment">/*用于定时器的下半部(下标(优先级1))*/</span></div><div class="line">	NET_TX_SOFTIRQ,<span class="comment">/*用于网络层发包(下标(优先级2))*/</span></div><div class="line">	NET_RX_SOFTIRQ, <span class="comment">/*用于网络层收报(下标(优先级3))*/</span></div><div class="line">	SCSI_SOFTIRQ, <span class="comment">/*用于scsi设备(下标(优先级4))*/</span></div><div class="line">	TASKLET_SOFTIRQ <span class="comment">/*用于低优先级的tasklet(下标(优先级5))*/</span></div><div class="line">};</div></pre></td></tr></table></figure>

<a id="more"></a>

<p>一个软中断的下标决定了它的优先级；低下标意味着高优先级，因为软中断函数将从下标0开始执行。</p>
<h2 id="tasklet:">tasklet:</h2>
<p>Tasklet为一个软中断，考虑到优先级问题，分别占用了向量表中的0号和5号软中断。</p>
<p>tasklet是IO驱动程序中实现可延迟函数的首选方法。其建立在两个叫HI_SOFTIRQ和TASKLET_SOFTIRQ的软中断之上。 </p>
<h2 id="软中断和tasklet">软中断和tasklet</h2>
<p>软中断和tasklet有密切的关系，tasklet是在软中断之上实现。事实上，出现在内核代码中的术语“软中断（softirq）” 常常表示可延迟函数的所有种类。另外一种被广泛使用的术语是“中断上下文”：表示内核当前正在执行一个中断处理程序或一个可延迟的函数。</p>
<p>软中断的分配是静态的（即在编译时定义），而tasklet的分配和初始化可以在运行时进行（例如：安装一个内核模块时）。软中断（即便是同一种类型的软中断）可以并发地运行在多个CPU上。因此，软中断是可重入函数而且必须明确地使用自旋锁保护其数据结构。tasklet不必担心这些问题，因为内核对tasklet的执行进行了更加严格的控制。相同类型的tasklet总是被串行地执行，换句话说就是：不能在两个CPU上同时运行相同类型的tasklet。但是，类型不同的tasklet可以在几个CPU上并发执行。tasklet的串行化使tasklet函数不必是可重入的，因此简化了设备驱动程序开发者的工作。</p>
<p>一般而言，可延迟函数上可以执行四种函数：初始化、激活、屏蔽和执行。</p>
<h2 id="软中断的主要数据结构">软中断的主要数据结构</h2>
<p>软中断的主要数据结构是softirq_vec数组，该数组包含类型为softirq_action的32个元素。一个软中断的优先级是相应的softirq_action元素在数组内的下标，只有前六个被有效使用。</p>
<p>/*表示softirq最多可以有32种类型，实际上linux只使用了六种，见文件interrupt.h*/</p>
<p>static struct softirq_action softirq_vec[32] __cacheline_aligned_in_smp;</p>
<p>softirq_action数据结构包括两个字段：指向软中断函数的一个action指针和指向软中断函数需要的通用数据结构的data指针。</p>
<p>还有一个关键的字段是32位的preempt_cout字段，用它来跟踪内核抢占和内核控制路径的嵌套，该字段存放在每个进程描述符的thread_info字段中。</p>
<p>对于softirq，linux kernel中是在中断处理程序执行的，具体的路径为：<br>    do_IRQ() —&gt; irq_exit() —&gt; invoke_softirq() —&gt; do_softirq() —&gt; <strong>do_softirq()<br>在</strong>do_softirq()中有这么一段代码：    </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">do</span> { </div><div class="line"></div><div class="line">        <span class="keyword">if</span> (pending & <span class="number">1</span>) { </div><div class="line"></div><div class="line">                h-&gt;action(h); </div><div class="line"></div><div class="line">                rcu_bh_qsctr_inc(cpu); </div><div class="line"></div><div class="line">        } </div><div class="line"></div><div class="line">        h++; </div><div class="line"></div><div class="line">        pending &gt;&gt;= <span class="number">1</span>; </div><div class="line"></div><div class="line">} <span class="keyword">while</span> (pending);</div></pre></td></tr></table></figure>



<p>你看，这里就是对softirq进行处理了，因为pengding是一个__u32的类型，所以每一位都对应了一种softirq，正好是32种（linux kernel中实际上只使用了前6种 ）. h-&gt;action(h),就是运行softirq的处理函数。 </p>
<p>对于tasklet，前面已经说了，是一种特殊的softirq，具体就是第0和第5种softirq，所以说tasklet是基于softirq来实现的。 </p>
<p>tasklet既然对应第0和第5种softirq，那么就应该有对应的处理函数，以便h-&gt;action()会运行tasklet的处理函数。 </p>
<p>我们看代码： </p>
<figure class="highlight c"><figcaption><span>softirq.c </span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">void</span> __init softirq_init(<span class="keyword">void</span>)   </div><div class="line"></div><div class="line">{ </div><div class="line"></div><div class="line">        open_softirq(TASKLET_SOFTIRQ, tasklet_action, NULL); </div><div class="line"></div><div class="line">        open_softirq(HI_SOFTIRQ, tasklet_hi_action, NULL); </div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>


<p>这里注册了两种tasklet所在的softirq的处理函数，分别对应高优先级的tasklet和低优先级的tasklet。 </p>
<p>我们看低优先级的吧（高优先级的也一样）。 </p>
<figure class="highlight c"><figcaption><span>tasklet_action</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> tasklet_action(<span class="keyword">struct</span> softirq_action *a) </div><div class="line"></div><div class="line">{ </div><div class="line"></div><div class="line">        <span class="keyword">struct</span> tasklet_struct *<span class="built_in">list</span>; </div><div class="line"></div><div class="line">        local_irq_disable(); </div><div class="line"></div><div class="line">        <span class="built_in">list</span> = __get_cpu_var(tasklet_vec).<span class="built_in">list</span>; </div><div class="line"></div><div class="line">        __get_cpu_var(tasklet_vec).<span class="built_in">list</span> = NULL; </div><div class="line"></div><div class="line">        local_irq_enable(); </div><div class="line"></div><div class="line">        <span class="keyword">while</span> (<span class="built_in">list</span>) { </div><div class="line"></div><div class="line">                <span class="keyword">struct</span> tasklet_struct *t = <span class="built_in">list</span>; </div><div class="line"></div><div class="line">                <span class="built_in">list</span> = <span class="built_in">list</span>-&gt;next; </div><div class="line"></div><div class="line">                <span class="keyword">if</span> (tasklet_trylock(t)) { </div><div class="line"></div><div class="line">                        <span class="keyword">if</span> (!atomic_read(&t-&gt;count)) { </div><div class="line"></div><div class="line">                                <span class="keyword">if</span> (!test_and_clear_bit(TASKLET_STATE_SCHED, &t-&gt;state)) </div><div class="line"></div><div class="line">                                        BUG(); </div><div class="line"></div><div class="line">                                t-&gt;func(t-&gt;data); </div><div class="line"></div><div class="line">                                tasklet_unlock(t); </div><div class="line"></div><div class="line">                                <span class="keyword">continue</span>; </div><div class="line"></div><div class="line">                        } </div><div class="line"></div><div class="line">                        tasklet_unlock(t); </div><div class="line"></div><div class="line">                } </div><div class="line"></div><div class="line">                local_irq_disable(); </div><div class="line"></div><div class="line">                t-&gt;next = __get_cpu_var(tasklet_vec).<span class="built_in">list</span>; </div><div class="line"></div><div class="line">                __get_cpu_var(tasklet_vec).<span class="built_in">list</span> = t; </div><div class="line"></div><div class="line">                __raise_softirq_irqoff(TASKLET_SOFTIRQ);   </div><div class="line"></div><div class="line">                local_irq_enable(); </div><div class="line"></div><div class="line">        } </div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>你看，在运行softirq的处理时（__do_softirq），对于 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">do</span> { </div><div class="line"></div><div class="line">        <span class="keyword">if</span> (pending & <span class="number">1</span>) { </div><div class="line"></div><div class="line">                h-&gt;action(h); </div><div class="line"></div><div class="line">                rcu_bh_qsctr_inc(cpu); </div><div class="line"></div><div class="line">        } </div><div class="line"></div><div class="line">        h++; </div><div class="line"></div><div class="line">        pending &gt;&gt;= <span class="number">1</span>; </div><div class="line"></div><div class="line">} <span class="keyword">while</span> (pending);</div></pre></td></tr></table></figure>

<p>如果tasklet有任务需要处理，会运行到h-&gt;action()，这个函数指针就会指向tasklet_action()，然后在tasklet_action()里再去执行tasklet对应的各个任务，这些任务都是挂在一个全局链表里面的，具体的代码这里就不分析了。 </p>
<p>另外， softirq在smp中是可能被同时运行的，所以softirq的处理函数必须被编写成可重入的函数。 </p>
<p>但tasklet是不会在多个cpu之中同时运行的，所以tasklet的处理函数可以编写成不可重入的函数，这样就减轻了编程人员的负担。 </p>
<h2 id="ksoftirqd内核线程">ksoftirqd内核线程</h2>
<p>在最近的内核版本中，每个CPU都有自己的ksoftirqd/n内核线程（这里，n为CPU的逻辑号）。每个ksoftirqd/n内核线程都运行ksoftirqd()函数。在预期的时间内处理挂起的软中断。 </p>
<p><br></p>
]]></content>
         
         
           
             
              <breadCrumb title="linux" url="http://blog.tinyxd.me/categories/linux/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/07/12/python-backup-octopress/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>本地备份octopress</title>
        <pubTime>2012-07-12T14:42:00.000Z</pubTime>
        
        <tag>python </tag>
         
        <tag>linux </tag>
         
        <tag>octopress </tag>
         
         <content><![CDATA[<p>用python脚本备份octopress，当然也可以备份其他的目录。只要修改对应路径就可以了。</p>
<figure class="highlight python"><figcaption><span>octopress_backup.py</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python2</span></div><div class="line"><span class="comment"># Filename: octopress_backup.py</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line"><span class="comment"># 1. 需要备份的目录(也可以将其他的文件夹一起打包)</span></div><div class="line">source = [<span class="string">'/home/tiny/octopress'</span>, <span class="string">'/home/tiny/mytest'</span>]</div><div class="line"></div><div class="line"><span class="comment"># 2. 备份的目标位置</span></div><div class="line">target_dir = <span class="string">'/home/tiny/backup/'</span> <span class="comment"># Remember to change this to what you will be using</span></div><div class="line"></div><div class="line"><span class="comment"># 3. 本脚本备份成tar，当然也可以压缩gzip。</span></div><div class="line"><span class="comment"># 4. 日期是目录名</span></div><div class="line">today = target_dir + time.strftime(<span class="string">'%Y%m%d'</span>)</div><div class="line"><span class="comment"># 当前时间是备份文件的名称</span></div><div class="line">now = time.strftime(<span class="string">'%H%M%S'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 可以对备份的文件进行一些说明</span></div><div class="line">comment = raw_input(<span class="string">'Enter a comment --&gt; '</span>)</div><div class="line"><span class="keyword">if</span> len(comment) == <span class="number">0</span>: <span class="comment"># check if a comment was entered</span></div><div class="line">    target = today + os.sep + now + <span class="string">'.tar'</span></div><div class="line"><span class="keyword">else</span>:</div><div class="line">    target = today + os.sep + now + <span class="string">'_'</span> +\</div><div class="line">        comment.replace(<span class="string">' '</span>, <span class="string">'_'</span>) + <span class="string">'.tar'</span></div><div class="line"></div><div class="line"><span class="comment"># 创建子文件夹</span></div><div class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(today):</div><div class="line">    os.mkdir(today) <span class="comment"># make directory</span></div><div class="line">    <span class="keyword">print</span> <span class="string">'Successfully created directory'</span>, today</div><div class="line"></div><div class="line"><span class="comment"># 5. tar压缩命令（unix/linux）</span></div><div class="line">tar_command = <span class="string">"tar -cvf '%s' %s"</span> % (target, <span class="string">' '</span>.join(source))</div><div class="line"></div><div class="line"><span class="comment"># 运行备份命令</span></div><div class="line"><span class="keyword">if</span> os.system(tar_command) == <span class="number">0</span>:</div><div class="line">    <span class="keyword">print</span> <span class="string">'Successful backup to'</span>, target</div><div class="line"><span class="keyword">else</span>:</div><div class="line">    <span class="keyword">print</span> <span class="string">'Backup FAILED'</span></div></pre></td></tr></table></figure>

<p><br></p>
]]></content>
         
         
           
             
              <breadCrumb title="python" url="http://blog.tinyxd.me/categories/python/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/07/13/debian-setup/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>debian硬盘安装笔记</title>
        <pubTime>2012-07-13T03:29:00.000Z</pubTime>
        
        <tag>debian </tag>
         
        <tag>linux </tag>
         
         <content><![CDATA[<p>以前安装的时候都有光盘，这次换的机器，光驱坏了，那么有没有可能硬盘安装debian么？答案当然是可以的。<br>1.下载debian最新ISO映像。<br>2.下载安装所需要的vmlinuz  initrd.gz  boot.img.gz的这三个文件.<br>   下载地址：<a href="http://debian.osuosl.org/debian/dists/Debian6.0.5/main/installer-i386/current/images/hd-media/" target="_blank" rel="external">http://debian.osuosl.org/debian/dists/Debian6.0.5/main/installer-i386/current/images/hd-media/</a><br>3.下载grub4 for DOS<br>下载地址：<a href="http://download.gna.org/grub4dos/grub4dos-0.4.4-2009-06-20.zip" target="_blank" rel="external">http://download.gna.org/grub4dos/grub4dos-0.4.4-2009-06-20.zip</a>   </p>
<h2 id="安装过程：">安装过程：</h2>
<p>1、先把WINXP安装到C盘，这里唯一要说的是如果在安装WINXP时，选择了把C盘格式化为NTFS格式，那么之后安装用的DEBIAN的ISO文件就不能放在C盘了，必须放在FAT32格式的分区的根目录下。切记哦！否则硬盘安装DEBIAN时后找不到ISO文件哦。</p>
<p>WINXP安装好以后，把下载的GRUB4 for DOS包解压缩到C盘根目录，并将目录名改为grub，（个人认为不改也应该可以，不过没试，你可以试下呵），并进入GRUB目录将grldr文件复制到C盘根目录下；把vmlinuz、initrd.gz、boot.img.gz三个文件也复制到C盘根目录下：（基本上这个时候C盘是NTFS格式还是FAT32格式都没有关系的）<br><a id="more"></a><br>2、打开C盘根目录下的boot.ini文件，打开boot.ini后在文件的最后一行加上    C:\grldr=”GRUB FOR DOS”  </p>
<p>之后保存并关闭boot.ini文件。</p>
<p>3、把前面下载的DEBIAN安装CD的ISO文件复制到C盘根目录下，（要保证C盘是FAT32格式的），否则就复制到其它FAT32分区的根目录下。</p>
<p>4、以上检查没有问题后重新启动电脑，这时应该会出现如下启动菜单：</p>
<p>5、选第二项“GRUB FOR DOS”后，等屏幕出现如下画面时，按键盘上的“C”进入命令行状态。</p>
<p>6、按“C”键后屏幕显示如下：</p>
<p>7、这个时候输入如下三行命令：</p>
<pre><code><span class="function"><span class="title">kernel</span> <span class="params">(hd0,<span class="number">0</span>)</span>/<span class="title">vmlinuz</span>

<span class="title">initrd</span> <span class="params">(hd0,<span class="number">0</span>)</span>/<span class="title">initrd</span>.<span class="title">gz</span>

<span class="title">boot</span></span>
</code></pre><p>这里的（hd0,0）指的是C盘，hd是指硬盘啦，第一个0是指电脑里的第一块硬盘，第二个0是指该硬盘上的第一个主分区，如果是第二个主分区就是（hd0,1）啦，如果你有兴趣上网查一下相关的知识了，这里不说了。</p>
<p>8、接下来就是安装debian，先会自动寻找ISO映像，找到后就开始安装，不再赘述。</p>
<p>9、如果你的C盘是FAT32格式的，ISO文件也复制到C盘根目录，那么就不用担心了，安装程序会自动找到的。（ISO文件在其它FAT32分区根目录下也一样，我已试过呵）</p>
<p>10、我的分区是这样的：/boot 200M  、2G swap、15G / 、其余大概40G的/home   </p>
<p>11、等系统装好后，需要设置中文字体，还需要安装一些必要软件等等。见我以前的文章，下面是链接：<a href="http://blog.chinaunix.net/uid-26053577-id-3011222.html" target="_blank" rel="external">http://blog.chinaunix.net/uid-26053577-id-3011222.html</a>   </p>
<p>本文章来自本人<strong><a href="http://blog.chinaunix.net/uid/26053577.html" target="_blank" rel="external">ChinaUnix</a></strong>博客。    </p>
]]></content>
         
         
           
             
              <breadCrumb title="linux" url="http://blog.tinyxd.me/categories/linux/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/07/14/archlinux-time-config/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>archlinux下的时间时区设置</title>
        <pubTime>2012-07-14T15:56:00.000Z</pubTime>
        
        <tag>archlinux </tag>
         
        <tag>linux </tag>
         
         <content><![CDATA[<p>本文方法适合于archlinux，archbang等衍生版本。archbang亲测。<br>1.打开<code>/etc/rc.conf</code>，将<code>TIMEZONE</code>改为<code>&quot;Asia/Shanghai&quot;</code>。<br>2.打开<code>/etc/rc.conf</code>，将<code>HARDWARECLOCK</code>改为<code>&quot;localtime&quot;</code>。<br>下面是改完的rc.conf：<br><a id="more"></a>   </p>
<p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment"># /etc/rc.conf - Main Configuration for Arch Linux</span></div><div class="line"></div><div class="line"><span class="variable">LOCALE=</span><span class="string">"en_US.UTF-8"</span></div><div class="line"><span class="variable">DAEMON_LOCALE=</span><span class="string">"no"</span></div><div class="line"><span class="variable">HARDWARECLOCK=</span><span class="string">"localtime"</span></div><div class="line"><span class="variable">TIMEZONE=</span><span class="string">"Asia/Shanghai"</span></div><div class="line"><span class="variable">KEYMAP=</span><span class="string">"us"</span></div><div class="line"><span class="variable">CONSOLEFONT=</span></div><div class="line"><span class="variable">CONSOLEMAP=</span></div><div class="line"><span class="variable">USECOLOR=</span><span class="string">"yes"</span></div><div class="line"></div><div class="line"><span class="variable">MODULES=</span>()</div><div class="line"></div><div class="line"><span class="variable">UDEV_TIMEOUT=</span><span class="number">30</span></div><div class="line"><span class="variable">USEDMRAID=</span><span class="string">"no"</span></div><div class="line"><span class="variable">USEBTRFS=</span><span class="string">"no"</span></div><div class="line"><span class="variable">USELVM=</span><span class="string">"no"</span></div><div class="line"></div><div class="line"><span class="variable">HOSTNAME=</span><span class="string">"archbang"</span></div><div class="line"></div><div class="line"><span class="variable">interface=</span>eth0</div><div class="line"><span class="variable">address=</span></div><div class="line"><span class="variable">netmask=</span></div><div class="line"><span class="variable">broadcast=</span></div><div class="line"><span class="variable">gateway=</span></div><div class="line"></div><div class="line"><span class="variable">DAEMONS=</span>(dbus networkmanager !network !dhcdbd syslog-ng @alsa @iNodeAuthService @openntpd)</div></pre></td></tr></table></figure><br>3.在<code>/etc/localtime</code>做个软链接给具体的<code>zoneinfo</code>：<br>    sudo ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime<br>4.这个时候时区应该算是正确设置好了，把硬件时钟再同步回系统来。<br>    $ sudo hwclock —hctosys<br>5.现在看时间正确了没，如果还有问题，参照archlinux的官方wiki（题外话：wiki是个好东西，可以找到你需要的）安装openNTPD，自动同步时间。<br>    $ sudo pacman -S openntpd<br>配置文件看了下，基本都不用修改，直接起服务：<br>    $ sudo /etc/rc.d/openntpd start<br>确保网络通畅，等一会，系统时间应该就会更新了，确实蛮方便<br>最后在<code>rc.conf</code>的DAEMONS里面加上<code>@openntpd</code>，确保开机后台运行。<br><br>   </p>
]]></content>
         
         
           
             
              <breadCrumb title="linux" url="http://blog.tinyxd.me/categories/linux/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/07/16/archlinux-wireless-network-connection/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>archlinux 无线网络连接</title>
        <pubTime>2012-07-16T03:24:00.000Z</pubTime>
        
        <tag>linux </tag>
         
        <tag>archlinux </tag>
         
         <content><![CDATA[<p>今天，回家了。由于家里用的无线路由器，我的本是archlinux系统，所以这就涉及到archlinux的无线网络配置。<br>本文参考了<a href="https://wiki.archlinux.org/index.php/Wireless_Setup" target="_blank" rel="external">archlinux官方wiki</a>。<br>配置无线网络一般分两步：<br>第一步是识别硬件、安装正确的驱动程序并进行配置；<br>第二步是选择一种管理无线连接的方式。<br>关于第一步，wiki中有详细的介绍，我就不多叙述。<br>第二步，有几个命令和无线网络的加密方法，需要说说。<br>大概有两种方法：一个是手动，一个是自动。<br><a id="more"></a></p>
<h2 id="方法一：手动">方法一：手动</h2>
<p>不加密/WEP ：ifconfig + iwconfig + dhcpcd/ifconfig<br>WPA/WPA2 PSK：ifconfig + iwconfig + wpa_supplicant + dhcpcd/ifconfig<br>1.激活内核接口: </p>
<pre><code> <span class="comment"># ifconfig wlan0 up    </span>
</code></pre><p>2.查看可以的无线接入点信息：</p>
<pre><code><span class="preprocessor"># iwlist wlan0 scan</span>
</code></pre><p>3.根据加密方式不同，需要使用密码将无线设备关联到接入点。<br>假设要使用的接入点 ESSID 为 MyEssid:<br>a.无加密    </p>
<pre><code> <span class="array"># iwconfig wlan</span>0 essid <span class="string">"MyEssid"</span>   
</code></pre><p>b.WEP<br>使用十六进制密码：    </p>
<pre><code> <span class="array"># iwconfig wlan</span>0 essid <span class="string">"MyEssid"</span> key <span class="number">1234567890</span>   
</code></pre><p>使用 ascii 密码：       </p>
<pre><code> # iwconfig wlan0 essid <span class="string">"MyEssid"</span> key <span class="variable">s:asciikey</span>   
</code></pre><p>c.WPA/WPA2<br>需要安装 WPA_Supplicant 编辑 /etc/wpa_supplicant.conf 文件。<br>a.先备份下 /etc/wpa_supplicant.conf：<br>    mv /etc/wpa_supplicant.conf /etc/wpa_supplicant.conf.original<br>b.修改此文件，适合你的无线网络环境。当然可以阅读系统自带的/etc/wpa_supplicant.conf ，然后根据自己的无线环境来手动编辑。也可以使用下面的命令。<br>    wpa_passphrase linksys “my_secret_passkey” &gt; /etc/wpa_supplicant.conf<br>这里，linksys代表的是要连接的无线网络的essid,而my_secret_passkey则是无线网络的密码。然后运行： </p>
<pre><code><span class="preprocessor"># wpa_supplicant -i wlan0 -c /etc/wpa_supplicant.conf</span>
</code></pre><p>假设设备使用 wext 驱动。如果无法工作，可能需要调整选项，参见 <a href="https://wiki.archlinux.org/index.php/WPA_Supplicant" target="_blank" rel="external">WPA_Supplicant</a>。<br>4.获取IP地址。<br>静态IP：    </p>
<pre><code><span class="preprocessor"># ifconfig wlan0 192.168.0.2</span>
<span class="preprocessor"># route add default gw 192.168.0.1</span>
</code></pre><p>动态IP获取使用 DHCP： </p>
<pre><code><span class="preprocessor"># dhcpcd wlan0</span>
</code></pre><p>如果因为“waiting for carrier”出现超时错误，可以设置通道模式为 auto    </p>
<pre><code><span class="preprocessor"># iwconfig wlan0 channel auto </span>
</code></pre><p>注意: 尽管手动配置可以帮助解决无线问题，每次重启都需要执行这些步骤。</p>
<h2 id="方法二：使用管理工具来管理">方法二：使用管理工具来管理</h2>
<p>netcfg, newlan (AUR), wicd, NetworkManager, 等。<br>我使用的是NetworkManager，地址在<a href="https://wiki.archlinux.org/index.php/NetworkManager" target="_blank" rel="external">这里</a>。<br><br>   </p>
]]></content>
         
         
           
             
              <breadCrumb title="linux" url="http://blog.tinyxd.me/categories/linux/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/07/18/linux-kernel-synchronization/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>linux内核同步</title>
        <pubTime>2012-07-18T07:57:00.000Z</pubTime>
        
        <tag>linux </tag>
         
        <tag>kernel </tag>
         
         <content><![CDATA[<h2 id="内核抢占">内核抢占</h2>
<p>抢占内核的主要特点是：一个在内核态运行的进程，可能在执行内核函数期间被另外一个进程取代。<br>只有当内核正在执行异常处理程序（尤其是系统调用），而且内核抢占没有被显式地禁用时，才可能抢占内核。<br>内核使用的各种同步技术：每CPU变量、原子操作、内存屏障、自旋锁、信号量、顺序锁、本地中断的禁止、本地软中断的禁止、读-拷贝-更新（RCU）。   </p>
<h2 id="每CPU变量">每CPU变量</h2>
<p>主要是数据结构的数组，系统的每个CPU对应数组的一个元素。<br>一个CPU不应该访问与其他CPU对应的数组元素。另外，它可以随意读或修改它自己的元素而不用担心出现竞争条件，因为它是唯一有资格这么做的CPU。在单处理器和多处理器系统中，内核抢占都可能使每CPU变量产生竞争条件。总的原则是内核控制路径应该在禁用抢占的情况下访问每CPU变量。   </p>
<p><a id="more"></a></p>
<h2 id="原子操作">原子操作</h2>
<p>若干汇编语言指令具有“读-修改-写”类型——也就是说，它们访问存储器单元两次，第一次读原值，第二次写新值。<br>Linux内核提供了一个专门的atomic_t类型（一个原子计数器）和一些专门的函数和宏。在多处理器系统中，每条这样的指令都有一个lock字节（“锁定内存总线，直到这条指令执行完成”）的前缀。   </p>
<h2 id="优化和内存屏障">优化和内存屏障</h2>
<p>当使用优化的编译器时，编译器为了优化可能会重新安排汇编语言指令以便寄存器以最优的方式使用。<br>内存屏障（memory barrier）原语确保，在原语之后的操作开始执行之前，原语之前的操作已经完成。   </p>
<h2 id="自旋锁">自旋锁</h2>
<p>自旋锁（spin lock）是用来在多处理器环境中工作的一种特殊的锁。如果内核控制路径发现自旋锁“开着”，就获取锁并继续自己的执行。相反，如果内核控制路径发现锁由运行在另一个CPU上的内核控制路径“锁着”，就在周围“旋转”。反复执行一条紧凑的循环指令，直到锁被释放。<br>一般来说，由自旋锁所保护的每个临界区都是禁止内核抢占的。在单处理器系统上，这种锁本身并不起锁的作用，自旋锁原语仅仅是禁止或启用内核抢占。<br>在linux中，每个自旋锁都用spinlock_t结构表示，其中包含两个字段：    </p>
<p>1.slock——表示自旋锁的状态。（1—未加锁  负数和0—加锁）<br>2.break_lock——表示进程正在忙等自旋锁（只在内核支持SMP和内核抢占的情况下使用该标志）</p>
<p>读写自旋锁的引入是为了增加内核的并发能力。只要没有内核控制路径堆数据结构进行修改，读写自旋锁就允许多个内核控制路径读同一数据结构。允许对数据结构并发度可以提高系统性能。<br>顺序锁：与读写自旋锁非常相似，只是它为写者赋予了较高的优先级；事实上，即使在读者正在读的时候也允许写者继续运行。这种策略的好处是写者永远不会等待（除非另外一个写者正在写），缺点是有些时候读者不得不反复多次读相同的数据直到获得有效的副本。<br>当读者进入临界区时，不必禁用内核抢占；另一方面，由于写者获取自旋锁，所以它进入临界区时自动禁用内核抢占。<br>一般来说，在满足以下条件时才能使用顺序锁：   </p>
<p>1.被保护的数据结构不包括被写者修改和被读者间接引用的指针（否则，写者可能在读者的眼鼻下就修改指针）。<br>2.读者的临界区代码没有副作用（否则，多个读者的操作会与单独的读操作有不同的结果）。   </p>
<h2 id="读-拷贝-更新（RCU）">读-拷贝-更新（RCU）</h2>
<p>读-拷贝-更新（RCU）是为了保护在多数情况下被多个CPU读的数据结构而设计的另一种同步技术。RCU允许多个读者和写者并发执行，RCU不使用锁，就是说它不使用被所有CPU共享的锁或计数器。<br>RCU同步的关键思想是：</p>
<p>1.RCU只保护被动态分配并通过指针引用的数据结构。<br>2.在被RCU保护的临界区中，任何内核控制路径都不能睡眠。</p>
<p>使用RCU技术的真正困难在于：写者修改指针时不能立即释放数据结构的旧副本。实际上，写着开始修改时，正在访问数据结构的读者可能还在读旧副本。只有在CPU上的所有（潜在的）读者都执行完宏rcu_read_unlock()之后，才可以释放旧副本。<br>RCU是Linux2.6中新加的功能，用在网络层和虚拟文件系统中。   </p>
<h2 id="信号量">信号量</h2>
<p>Linux提供两种信号量：</p>
<p>1.内核信号量，由内核控制路径使用<br>2.Systerm V IPC 信号量，由用户态进程使用</p>
<p>内核信号量：类似于自旋锁，因为当锁关闭着时，它不允许内核控制路径继续进行。只有可以睡眠的函数才能获取内核信号量；中断处理程序和可延迟函数都不能使用内核控制量。<br>内核信号量是struct semaphore类型的对象。<br>TASK_INTERRUPTIBLE是可以被信号和wake_up()唤醒的，当信号到来时，进程会被设置为可运行。<br>而TASK_UNINTERRUPTIBLE只能被wake_up()唤醒。<br>读/写信号量：类似于前面的“读写自旋锁”，有一点不同的是，在信号量再次变为打开之前，等待进程挂起而不是自旋。内核以严格的FIFO顺序处理等待读写信号量的所有进程。<br>每个读写信号量都是有rw_semaphore结构描述的。<br>补充原语（completion）：其和信号量之间的真正区别在于如何使用等待队列中包含的自旋锁。在补充原语中，自旋锁用来确保complete()和wait_for_completion()不会并发执行。在信号量中，自旋锁用于避免并发执行的down()函数弄乱信号量的数据结构。<br><br><br>本文章参考自《深入理解linux内核》。   </p>
]]></content>
         
         
           
             
              <breadCrumb title="linux" url="http://blog.tinyxd.me/categories/linux/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/07/25/archlinux-update-about-glibc/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>archlinux升级出现关于glibc的问题解决办法</title>
        <pubTime>2012-07-25T10:44:00.000Z</pubTime>
        
        <tag>archlinux </tag>
         
        <tag>linux </tag>
         
         <content><![CDATA[<p>好久没更新archlinux，今天更新，发现由于archlinux系统根目录结构的改变，导致好多人遇到问题，不错，笔者必然也遇到了。由于有前人的探索，再加上查阅archlinux官网论坛，得以顺利解决问题。<br>运行<code>pacman -Syu</code>时会出现   </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">error: failed to <span class="operator"><span class="keyword">commit</span> <span class="keyword">transaction</span> (conflicting files)</span></div><div class="line">glibc: /lib <span class="keyword">exists</span> <span class="keyword">in</span> filesystem</div><div class="line"><span class="keyword">Errors</span> occurred, <span class="keyword">no</span> packages were upgraded.</div></pre></td></tr></table></figure>


<p>由于这次是glibc的升级，绝对不可以用<code>--force</code>，而之前是filesysterm的升级，必须用<code>--force</code>。<br>那么接下来该怎么办呢？<br>查阅了archlinux论坛地址：<a href="https://bbs.archlinux.org/viewforum.php?id=44" target="_blank" rel="external">https://bbs.archlinux.org/viewforum.php?id=44</a>，并参考了<a href="http://www.j927.net/arch/archlinux%E5%8D%87%E7%BA%A7%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E8%AE%B0%E5%BD%95.html" target="_blank" rel="external">这篇文章</a>。<br>发现这个<a href="https://bbs.archlinux.org/viewtopic.php?id=145186" target="_blank" rel="external">帖子</a>，其中提到这两篇文章：<a href="http://allanmcrae.com/2012/07/updating-arch-linux-from-a-core-install/" target="_blank" rel="external">updating-arch-linux-from-a-core-install</a> 和<a href="https://wiki.archlinux.org/index.php/DeveloperWiki:usrlib" target="_blank" rel="external">DeveloperWiki:usrlib</a>，总结以下命令：<br><a id="more"></a>   </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="input"><span class="prompt">shell &gt;</span> pacman -<span class="constant">Sy</span></span></div><div class="line"><span class="input"><span class="prompt">shell &gt;</span> rm -rf /var/run /var/lock && pacman -<span class="constant">Sf</span> filesystem</span></div><div class="line"><span class="input"><span class="prompt">shell &gt;</span> pacman -<span class="constant">S</span> tzdata</span></div><div class="line"><span class="input"><span class="prompt">shell &gt;</span> pacman -<span class="constant">U</span> <span class="symbol">http:</span>/<span class="regexp">/pkgbuild.com/</span>~allan/glibc-<span class="number">2.16</span>.<span class="number">0</span>-<span class="number">1</span>-i686.pkg.tar.xz <span class="comment">#32位的用这个包(和下面的一条命令二选一)</span></span></div><div class="line"><span class="input"><span class="prompt">shell &gt;</span> pacman -<span class="constant">U</span> <span class="symbol">http:</span>/<span class="regexp">/pkgbuild.com/</span>~allan/glibc-<span class="number">2.16</span>.<span class="number">0</span>-<span class="number">1</span>-x86_64.pkg.tar.xz <span class="comment">#64位的用这个包 具体的包名称可以打开http://pkgbuild.com/~allan/看一下</span></span></div><div class="line"><span class="input"><span class="prompt">shell &gt;</span> rm /etc/profile.d/locale.sh</span></div><div class="line"><span class="input"><span class="prompt">shell &gt;</span> pacman -<span class="constant">Su</span> --ignore glibc <span class="comment">#因为pacman也升级了，新版本开启了软件包签名验证，故还需要运行下面2条命令</span></span></div><div class="line"><span class="input"><span class="prompt">shell &gt;</span> pacman-key --init <span class="comment">#该命令运行后不要什么都不做，随机敲键盘或者切换到其它终端(Alt+F2)运行些命令或做些其它操作</span></span></div><div class="line"><span class="input"><span class="prompt">shell &gt;</span> pacman-key --populate archlinux</span></div><div class="line"><span class="input"><span class="prompt">shell &gt;</span> pacman -<span class="constant">Su</span> <span class="comment">#再更新被忽略的glibc</span></span></div></pre></td></tr></table></figure>

<p>执行完上述命令后，系统顺利更新好了，但是依然出现下述问题：   </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">error: failed to <span class="operator"><span class="keyword">commit</span> <span class="keyword">transaction</span> (conflicting files)</span></div><div class="line">glibc: /lib <span class="keyword">exists</span> <span class="keyword">in</span> filesystem</div><div class="line"><span class="keyword">Errors</span> occurred, <span class="keyword">no</span> packages were upgraded.</div></pre></td></tr></table></figure>


<p>我就去论坛中寻找，果不其然也有类似于我的情况，原帖<a href="http://bbs.archbang.org/viewtopic.php?pid=16509" target="_blank" rel="external">在此</a>。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="input"><span class="prompt">shell &gt;</span> pacman -<span class="constant">R</span> broadcom-wl</span></div><div class="line"><span class="input"><span class="prompt">shell &gt;</span> pacman -<span class="constant">Su</span></span></div><div class="line"><span class="input"><span class="prompt">shell &gt;</span> pacman -<span class="constant">S</span> broadcom-wl <span class="comment">#如果需要的话，再次安装即可</span></span></div></pre></td></tr></table></figure>

<p>至此，升级结束。<br><br></p>
]]></content>
         
         
           
             
              <breadCrumb title="linux" url="http://blog.tinyxd.me/categories/linux/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/07/26/linux-process-scheduling/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>linux进程调度</title>
        <pubTime>2012-07-26T15:18:00.000Z</pubTime>
        
        <tag>linux </tag>
         
        <tag>kernel </tag>
         
         <content><![CDATA[<p><strong><em>摘要</em></strong>：linux与任何分时系统一样，通过一个进程到另一个进程的快速切换，达到表面上看来的多个进程同时执行的神奇效果。 </p>
<p><br><br>Linux的调度基于分时（time sharing）技术：多个进程以“时间多路复用”方式运行，因为CPU的时间被分成“片（slice）”，给每个可运行进程分配一片。 </p>
<p>在linux中，进程的优先级是动态的。调度程序跟踪进程正在做什么，并周期性地调整它们的优先级。 </p>
<h2 id="分类_">分类 </h2>
<p>传统上，把进程分类为“IO受限（IO bound）”或“CPU受限（CPU bound）”。前者频繁使用IO设备，并花费很多时间等待IO操作的完成；而后者则需要大量CPU时间的数值计算应用程序。 </p>
<p>另一种分类方法把进程区分为三类：交互式进程（interactive process）、批处理进程（batch process、实时进程（real-time process）。<br><a id="more"></a>   </p>
<h2 id="进程的抢占_">进程的抢占 </h2>
<p>Linux的进程是抢占式的。根据优先级和时间片是否国企决定是否可以被抢占。 </p>
<p>Linux2.6内核是抢占式的，这意味着进程无论是处于内核态还是用户态，都可能被抢占。 </p>
<h2 id="调度算法_">调度算法 </h2>
<p>调度程序总能成功地找到要执行的进程。事实上，总是至少有一个可运行进程，即swapper进程，它的PID等于0，而且它只有在CPU不能执行其他进程时才执行。 </p>
<p>每个Linux进程总是按照下面的调度类型被调度： </p>
<p>SCHED_FIFO（先进先出的实时进程）：直到先被执行的进程变为非可执行状态，后来的进程才被调度执行。在这种策略下，先来的进程可以执行sched_yield系统调用，自愿放弃CPU，以让权给后来的进程； </p>
<p>SCHED_RR（时间片轮转的实时进程）：轮转调度。内核为实时进程分配时间片，在时间片用完时，让下一个进程使用CPU； </p>
<p>SCHED_NORMAL（普通的分时进程）。 </p>
<h2 id="普通进程的调度_(参考自linux进程调度浅析)_">普通进程的调度 (参考自<a href="http://hi.baidu.com/_kouu/blog/item/52471ab5e90e7c788ad4b24a.html" target="_blank" rel="external">linux进程调度浅析</a>) </h2>
<p>实时进程调度的中心思想是，让处于可执行状态的最高优先级的实时进程尽可能地占有CPU，因为它有实时需求；而普通进程则被认为是没有实时需求的进程，于是调度程序力图让各个处于可执行状态的普通进程和平共处地分享CPU，从而让用户觉得这些进程是同时运行的。 </p>
<p>每个普通进程都有它自己的静态优先级，还有动态优先级。 </p>
<p>与实时进程相比，普通进程的调度要复杂得多。内核需要考虑两件麻烦事： </p>
<p>一、动态调整进程的优先级 </p>
<p>按进程的行为特征，可以将进程分为“交互式进程”和“批处理进程”： </p>
<p>交互式进程（如桌面程序、服务器、等）主要的任务是与外界交互。这样的进程应该具有较高的优先级，它们总是睡眠等待外界的输入。而在输入到来，内核将其唤醒时，它们又应该很快被调度执行，以做出响应。比如一个桌面程序，如果鼠标点击后半秒种还没反应，用户就会感觉系统“卡”了； </p>
<p>批处理进程（如编译程序）主要的任务是做持续的运算，因而它们会持续处于可执行状态。这样的进程一般不需要高优先级，比如编译程序多运行了几秒种，用户多半不会太在意； </p>
<p>如果用户能够明确知道进程应该有怎样的优先级，可以通过nice、setpriority系统调用来对优先级进行设置。（如果要提高进程的优先级，要求用户进程具有CAP_SYS_NICE能力。） </p>
<p>然而应用程序未必就像桌面程序、编译程序这样典型。程序的行为可能五花八门，可能一会儿像交互式进程，一会儿又像批处理进程。以致于用户难以给它设置一个合适的优先级。 </p>
<p>再者，即使用户明确知道一个进程是交互式还是批处理，也多半碍于权限或因为偷懒而不去设置进程的优先级。（你又是否为某个程序设置过优先级呢？） </p>
<p>于是，最终，区分交互式进程和批处理进程的重任就落到了内核的调度程序上。 </p>
<p>调度程序关注进程近一段时间内的表现（主要是检查其睡眠时间和运行时间），根据一些经验性的公式，判断它现在是交互式的还是批处理的？程度如何？最后决定给它的优先级做一定的调整。 </p>
<p>进程的优先级被动态调整后，就出现了两个优先级： </p>
<p>1、用户程序设置的优先级（如果未设置，则使用默认值），称为静态优先级。这是进程优先级的基准，在进程执行的过程中往往是不改变的； </p>
<p>2、优先级动态调整后，实际生效的优先级。这个值是可能时时刻刻都在变化的； </p>
<p>二、调度的公平性 </p>
<p>在支持多进程的系统中，理想情况下，各个进程应该是根据其优先级公平地占有CPU。而不会出现“谁运气好谁占得多”这样的不可控的情况。 </p>
<p>linux实现公平调度基本上是两种思路： </p>
<p>1、给处于可执行状态的进程分配时间片（按照优先级），用完时间片的进程被放到“过期队列”中。等可执行状态的进程都过期了，再重新分配时间片； </p>
<p>2、动态调整进程的优先级。随着进程在CPU上运行，其优先级被不断调低，以便其他优先级较低的进程得到运行机会； </p>
<p>后一种方式有更小的调度粒度，并且将“公平性”与“动态调整优先级”两件事情合而为一，大大简化了内核调度程序的代码。因此，这种方式也成为内核调度程序的新宠。 </p>
<p>强调一下，以上两点都是仅针对普通进程的。而对于实时进程，内核既不能自作多情地去动态调整优先级，也没有什么公平性可言。 </p>
<p>普通进程具体的调度算法非常复杂，并且随linux内核版本的演变也在不断更替（不仅仅是简单的调整），所以本文就不继续深入了。有兴趣的朋友可以参考下面的链接： </p>
<p><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-scheduler/" target="_blank" rel="external">《Linux 调度器发展简述》</a> </p>
<p><a href="http://blog.chinaunix.net/u1/42957/showart.php?id=337597" target="_blank" rel="external">《鼠眼看Linux调度器》</a> </p>
<p><a href="http://blog.chinaunix.net/u1/42957/showart.php?id=337604" target="_blank" rel="external">《鼠眼再看Linux调度器［1］》</a> </p>
<p><a href="http://blog.chinaunix.net/u1/42957/showart.php?id=337607" target="_blank" rel="external">《鼠眼再看Linux调度器［2］》</a> </p>
<h2 id="实时进程的调度_">实时进程的调度 </h2>
<p>每个实时进程都与一个实时优先级相关，实时优先级是一个范围从1（最高优先级）~99（最低优先级）的值。调度程序总是让优先级高的进程运行，换句话说，实时进程运行的过程中，禁止低优先级的进程的执行。与普通进程相反，实时进程总是被当成活动进程。用户可以通过系统调用sched_setparam()和sched_setscheduler()改变进程的实时优先级。 </p>
<p>只有在下述时间之一发生时，实时进程才会被另一个进程取代： </p>
<pre><code>进程被另外一个具有更高实时优先级的实时进程抢占 

进程执行了阻塞操作并进入睡眠（处于TASK_INTERRUPTIBLE或TASK_UNINTERRUPTIBLE状态）。 

进程停止（处于TASK_STOPPED或TASK_TRACED状态）或被杀死（处于EXIT_ZOMBIE或EXIT_DEAD状态）。 

进程通过调用系统调用sched_yield()自愿放弃<span class="built_in">CPU</span>。 

进程是基于时间片轮转的实时进程（SCHED_RR），而且用完了它的时间片。 
</code></pre><p>数据结构runqueue是Linux2.6调度程序最重要的数据结构。系统中的每个CPU都有它自己的运行队列，所有的runqueue结构存放在runqueues每CPU变量中。 </p>
<h2 id="调度程序所使用的函数_">调度程序所使用的函数 </h2>
<p>scheduler_tick()：维持当前最新的time_slice计数器 </p>
<p>try_to_wake_up()：唤醒睡眠进程 </p>
<p>recalc_task_prio()：更新进程的动态优先级 </p>
<p>schedule()：选择要被执行的新进程 </p>
<p>load_balance()：维持多处理器系统中运行队列的平衡 </p>
<h2 id="多处理器系统中运行队列的平衡_">多处理器系统中运行队列的平衡 </h2>
<p>Linux一直坚持采用对称多处理模式，这意味着，与其他CPU相比，内核不对一个CPU有任何偏向，但是，多处理器机器具有很多不同的风格，而且调度程序的实现随硬件特征的不同而有所不同，我们将特别关注下面三种不同类型的多处理器机器： </p>
<p>（1）标准的多处理器体系结构 </p>
<p>直到最近，这是多处理器机器最普通的体系结构。这些机器所共有的RAM芯片集被所有CPU共享。 </p>
<p>（2）超线程 </p>
<p>超线程芯片是一个立刻执行几个执行线程的微处理器；它包括几个内部寄存器的拷贝，并快速在它们之间切换。这种由Intel发明的技术，使得当前线程在访问内存的间隙，处理器可以使用它的机器周期去执行另外一个线程。一个超线程的物理CPU可以被Linux看作几个不同的逻辑CPU。 </p>
<p>（3）NUMA </p>
<p>把CPU和RAM以本地“结点”为单位分组，（通常一个结点包括一个CPU和几个RAM芯片）。内存仲裁器（一个使系统中的CPU以串型方式访问RAM的专用电路）是典型的多处理器系统的瓶颈。在NUMA体系结构中，当CPU访问与它同在一个结点中的“本地”RAM芯片时，几乎没有竞争，因此访问通常是非常快的。另一方面，访问它所属结点外的“远程”RAM芯片就非常慢。 </p>
<h2 id="与调度相关的系统调用_">与调度相关的系统调用 </h2>
<p>nice()、getpriority()和setpriority()系统调用、sched_getaffinity()和sched_setaffinity()调用 </p>
<h2 id="与实时进程相关的系统调用_">与实时进程相关的系统调用 </h2>
<p>sched_getscheduler()和sched_setscheduler()系统调用、sched_getparam()和sched_setparam()系统调用、sched_yield()系统调用、sched_get_priority_min()和 sched_get_priority_max()系统调用、sched_rr_get_interval()系统调用 </p>
<p><br><br>本文章参考自《深入理解linux内核》。   </p>
]]></content>
         
         
           
             
              <breadCrumb title="linux" url="http://blog.tinyxd.me/categories/linux/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/07/26/linux-timing-measurements/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>linux系统定时测量</title>
        <pubTime>2012-07-26T04:48:00.000Z</pubTime>
        
        <tag>linux </tag>
         
        <tag>kernel </tag>
         
         <content><![CDATA[<p>Linux内核必须完成的两种主要定时测量：     </p>
<p>保存当前的时间和日期，以便通过time()、ftime()、gettimeofday()系统调用把它们返回给用户程序，也可以由内核本身把当前时间作为文件和网络包的时间戳。  </p>
<p>维持定时器，这种机制能够告诉内核或用户程序某一时间间隔已经过去了。  </p>
<p>一般会遇到的几种时钟和定时器电路：实时时钟（Real Time Clock RTC）、时间戳计数器（Time Stamp Counter TSC）、可编程间隔定时器（Programmable Interval Timer PIT）、CPU本地定时器（APIC中）、高精度事件定时器（HPET）、ACPI电源管理定时器。   </p>
<p>Linux的计时体系结构是一组与时间流相关的内核数据结构和函数。实际上，基于80x86多处理器机器所具有的计时体系结构与单处理器机器所具有的稍有不同：  </p>
<p>在三处理器系统上，所有的计时活动都是由全局定时器（可以是可编程间隔定时器也可以是高精度事件定时器）产生的中断触发的。<br><a id="more"></a><br>在多处理器系统上，所有普通的活动（像软定时器处理）都是由全局定时器产生的中断触发的，而具体的CPU的活动（像监控当前运行进程的执行时间）是由本地APIC定时器产生的中断触发的。  </p>
<p>jiffies  </p>
<p>jiffies是一个计数器，用来记录自系统启动依赖产生的节拍总数。启动时，内核将该变量初始化为0，此后，每次时钟中断处理程序都会增加该变量的值。因为一秒内时钟中断的次数等于Hz，所以jiffies一秒内增加的值也就为Hz。系统运行时间以秒为单位计算，就等于jiffies/Hz。   </p>
<p>xtime  </p>
<p>xtime变量存放当前时间和日期；它是一个timespec类型的数据结构，该结构有两个字段：  </p>
<p>1.tv_sec 存放自1970年1月1日（UTC）午夜以来经过的秒数。  </p>
<p>2.tv_nsec存放自上一秒开始经过的纳秒数（它的值域范围在0-999999999之间）  </p>
<p>在单处理器系统上，所有与定时有关的活动都是由IRQ线0上的可编程间隔定时器产生的中断触发的。  </p>
<p>多处理器系统可以依赖两种不同的时钟中断源：可编程间隔定时器或高精度事件定时器产生的中断，以及CPU本地定时器产生的中断(监管内核代码并检测当前进程在特定CPU上已经运行了多长时间)。  </p>
<p>内核在于定时相关的其他任务中必须周期性地收集若干数据用于：  </p>
<pre><code>检查运行进程的<span class="built_in">CPU</span>资源限制  

更新与本地<span class="built_in">CPU</span>工作负载有关的统计数  

计算平均系统负载  

监管内核代码  
</code></pre><p>软定时器和延迟函数 </p>
<p>定时器是一种软件功能，即允许在将来的某个时期，函数在给定的时间间隔用完时被调用。超时（time-out）表示与定时器相关的时间间隔已经用完的那个时刻。 </p>
<p>Linux考虑两种类型的定时器，即动态定时器（dynamic timer）和间隔定时器（interval timer）。第一种类型由内核使用，而间隔定时器可以由进程在用户态创建。 </p>
<p>延迟函数 </p>
<p>当内核需要等待一个较短的时间间隔（比方说，不超过几毫秒）时，就不需要使用软定时器。 </p>
<p>开发驱动，需要较短的时间间隔，在以上情况下，内核使用udelay()和ndelay()函数：前者接收一个微妙级的时间间隔作为它的参数，并在指定的延迟结束后返回；后者与前者类似，但是指定的延迟参数是纳秒级的。 </p>
<p>本文章参考自《深入理解linux内核》。   </p>
]]></content>
         
         
           
             
              <breadCrumb title="linux" url="http://blog.tinyxd.me/categories/linux/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/07/29/linux-memory-management-1/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>linux内存管理（上）</title>
        <pubTime>2012-07-29T15:33:00.000Z</pubTime>
        
        <tag>linux </tag>
         
        <tag>kernel </tag>
         
         <content><![CDATA[<p><strong><em>摘要</em></strong>：内核如何给自己分配动态内存呢？  </p>
<p>“页框管理”和“内存区管理”是对连续物理内存区处理的两种不同技术。  </p>
<p>“非连续内存区管理”是处理非连续内存区的第三种技术。  </p>
<h2 id="页框管理_">页框管理  </h2>
<p>intel的Pentium处理器可以采用两种不同的页框大小：4KB和4MB。Linux采用4KB页框大小作为标准的内存分配单元。物理页在系统中由页框结构struct paga描述，系统中所有的页框存储在数组mem_map[]中，可以通过该数组找到系统中的每一页（空闲或非空闲）。  </p>
<p><a id="more"></a></p>
<h2 id="内存管理区_">内存管理区  </h2>
<p>Linux2.6把每个内存节点的物理内存划分为3个管理区（zone）。在80X86UMA体系结构中的管理区为：  </p>
<p>ZONE_DMA：包含低于16MB的内存页框  </p>
<p>ZONE_NORMAL：包含高于16MB且低于896MB的内存页框  </p>
<p>ZONE_HIGHMEM：包含从896MB开始高于896MB的内存页框（并不映射在内核线性地址空间的第4个GB）  </p>
<p>注意：ZONE_DMA和ZONE_NORMAL区包含内存的“常规”页框，通过把它们线性映射到线性地址空间的第4个GB，内核就可以直接进行访问。相反，ZONE_HIGHMEM区包含的内存页不能由内核直接访问，尽管它们也线性地映射到了线性地址空间的第4个GB。在64位体系结构上ZONE_HIGHMEM区总是空的。  </p>
<p>Linux内核管理物理内存是通过分页机制实现的，它将整个内存划分成无数4k(在i386体系结构中)大小页，从而分配和回收内存的基本单位便是内存页了。利用分页管理有助于灵活分配内存地址，因为分配时不必要求必须有大块的连续内存，系统可以东一页、西一页的凑出所需要的内存供进程使用。虽然如此，但是实际上系统使用内存还是倾向于分配连续的内存块，因为分配连续内存时，页表不需要更改，因此能降低TLB的刷新率（频繁刷新会很大增加访问速度）。     </p>
<p>鉴于上述需求，内核分配物理页为了尽量减少不连续情况，采用了“伙伴”关系来管理空闲页框。伙伴关系分配算法大家不应陌生——几乎所有操作系统书都会提到,我们不去详细说它了，如果不明白可以参看有关资料。这里只需要大家明白Linux中空闲页面的组织和管理利用了伙伴关系，因此空闲页面分配时也需要遵循伙伴关系，最小单位只能是2的幂倍页面大小。内核中分配空闲页框的基本函数是get_free_page/get_free_pages，它们或是分配单页或是分配指定的页框（2、4、8…512页）。  </p>
<p>注意：get_free_page是在内核中分配内存，不同于malloc在用户空间中分配，malloc利用堆动态分配，实际上是调用brk()系统调用，该调用的作用是扩大或缩小进程堆空间（它会修改进程的brk域）。如果现有的内存区域不够容纳堆空间，则会以页面大小的倍数位单位，扩张或收缩对应的内存区域，但brk值并非以页面大小为倍数修改，而是按实际请求修改。因此Malloc在用户空间分配内存可以以字节为单位分配,但内核在内部仍然会是以页为单位分配的。  </p>
<h2 id="高端内存页框的内核映射_">高端内存页框的内核映射  </h2>
<p>内核可以采用三种不同的机制将页框映射到高端内存；分别叫做永久内核映射、临时内核映射及非连续内存分配。  </p>
<p>永久内核映射可能阻塞当前进程，不能用于中断处理程序和可延迟函数。  </p>
<p>临时内核映射比永久内核映射的实现要简单，可以用在中断处理程序和可延迟函数的内部，因为它们从不阻塞当前进程。  </p>
<h2 id="伙伴系统算法（buddy_systerm）_">伙伴系统算法（buddy systerm）  </h2>
<p>内核要分配一组连续的页框，必须建立一种健壮、高效的分配策略。为此，必须解决著名的外部碎片（external fragmentation）问题。频繁地请求和释放不同大小的一组连续页框，必然导致在已分配页框的块内分散了许多小块的空闲页框。由此带来的问题是，即使有足够的空闲页框可以满足请求，但要分配一个大块的连续页框就可能无法满足。  </p>
<p>Linux 采用伙伴系统（buddy system）算法来解决外碎片问题。把所有的空闲页框分组为11个块链表，每个块链表分别包含大小为1, 2, 4, 8, 16, 32, 64, 128, 256，512和1024 个连续的页框。对1024 个页框的最大请求对应着4MB 大小的连续RAM块。每个块的第一个页框的物理地址是该块大小的整数倍。例如，大小为16 个页框的块，其起始地址是16 × 212（212 ＝ 4096，这是一个常规页的大小）的倍数。  </p>
<p>本文章参考自《深入理解linux内核》及 <a href="http://www.cnblogs.com/hoys/archive/2011/09/08/2171606.html" target="_blank" rel="external">Linux内存管理(上)</a> 。   </p>
]]></content>
         
         
           
             
              <breadCrumb title="linux" url="http://blog.tinyxd.me/categories/linux/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/07/31/linux-memory-management-2/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>linux内存管理（中）</title>
        <pubTime>2012-07-31T15:16:00.000Z</pubTime>
        
        <tag>linux </tag>
         
        <tag>kernel </tag>
         
         <content><![CDATA[<p><strong><em>摘要</em></strong>：slab分配器是Linux内存管理中非常重要和复杂的一部分，其工作是针对一些经常分配并释放的对象，如进程描述符等，这些对象的大小一般比较小，如果直接采用伙伴系统来进行分配和释放，不仅会造成大量的内碎片，而且处理速度也太慢。而slab分配器是基于对象进行管理的，相同类型的对象归为一类(如进程描述符就是一类)，每当要申请这样一个对象，slab分配器就从一个slab列表中分配一个这样大小的单元出去，而当要释放时，将其重新保存在该列表中，而不是直接返回给伙伴系统。slab分配对象时，会使用最近释放的对象内存块，因此其驻留在CPU高速缓存的概率较高。 </p>
<h2 id="简介">简介</h2>
<p><a id="more"></a><br>内存管理的目标是提供一种方法，为实现各种目的而在各个用户之间实现内存共享。内存管理方法应该实现以下两个功能： </p>
<ul>
<li><p>最小化管理内存所需的时间 </p>
</li>
<li><p>最大化用于一般应用的可用内存（最小化管理开销） </p>
</li>
</ul>
<p>内存管理实际上是一种关于权衡的零和游戏。您可以开发一种使用少量内存进行管理的算法，但是要花费更多时间来管理可用内存。也可以开发一个算法来有效地管理内存，但却要使用更多的内存。最终，特定应用程序的需求将促使对这种权衡作出选择。 </p>
<p>每个内存管理器都使用了一种基于堆的分配策略。在这种方法中，大块内存（称为 堆）用来为用户定义的目的提供内存。当用户需要一块内存时，就请求给自己分配一定大小的内存。堆管理器会查看可用内存的情况（使用特定算法）并返回一块内存。搜索过程中使用的一些算法有 first-fit（在堆中搜索到的第一个满足请求的内存块 ）和 best-fit（使用堆中满足请求的最合适的内存块）。当用户使用完内存后，就将内存返回给堆。 </p>
<p>这种基于堆的分配策略的根本问题是碎片（fragmentation）。当内存块被分配后，它们会以不同的顺序在不同的时间返回。这样会在堆中留下一些洞，需要花一些时间才能有效地管理空闲内存。这种算法通常具有较高的内存使用效率（分配需要的内存），但是却需要花费更多时间来对堆进行管理。 </p>
<p>另外一种方法称为 buddy memory allocation，是一种更快的内存分配技术，它将内存划分为 2 的幂次方个分区，并使用 best-fit 方法来分配内存请求。当用户释放内存时，就会检查 buddy 块，查看其相邻的内存块是否也已经被释放。如果是的话，将合并内存块以最小化内存碎片。这个算法的时间效率更高，但是由于使用 best-fit 方法的缘故，会产生内存浪费。 </p>
<p>伙伴系统算法采用页框作为基本内存区，适合对大块内存的请求，为了解决外碎片的问题。而小内存的分配，会产生内碎片（internal fragmentation），这需要新的数据结构来描述在同一页框中 如何分配小内存区。 </p>
<p>为了满足内核对这种小内存块的需要，Linux系统采用了一种被称为slab分配器的技术。Slab分配器的实现相当复杂，但原理不难，其核心思想就是“存储池[2]”的运用。内存片段（小块内存）被看作对象，当被使用完后，并不直接释放而是被缓存到“存储池”里，留做下次使用，这无疑避免了频繁创建与销毁对象所带来的额外负载。 </p>
<p>Slab技术不但避免了内存内部分片（下文将解释）带来的不便（引入Slab分配器的主要目的是为了减少对伙伴系统分配算法的调用次数——频繁分配和回收必然会导致内存碎片——难以找到大块连续的可用内存），而且可以很好利用硬件缓存提高访问速度。 </p>
<p>Slab并非是脱离伙伴关系而独立存在的一种内存分配方式，slab仍然是建立在页面基础之上，换句话说，Slab将页面（来自于伙伴关系管理的空闲页框链）撕碎成众多小内存块以供分配，slab中的对象分配和销毁使用kmem_cache_alloc与kmem_cache_free。每个高速缓存都是由kmem_cache_t(等价于struct kmem_cache) </p>
<p>slab分配器把对象分组放进高速缓存。包含高速缓存的主内存区被划分为多个slab，每个slab由一个或多个连续的页框组成，这些页框既包含已分配的对象，也包含空闲的对象。内核周期性地扫描高速缓存并释放空slab对应的页框。 </p>
<p>普通高速缓存在系统初始化期间调用kmem_cache_init()和kmem_cache_sizes_init()来建立普通高速缓存。专用高速缓存由kmem_cache_create()函数创建。所有普通和专用高速缓存的名字都可以在运行期间通过读取/proc/slabinfo文件得到。这个文件也指明每个高速缓存中空闲对象的个数和已分配对象的个数。 </p>
<p>slab的对象描述符与slab描述符本身类似，也可以用两种可能的方式来存放：外部对象描述符（存放在slab的外部）、内部对象描述符（存放在slab的内部）。每个对象都有类型为kmem_bufctl_t的一个描述符。 </p>
<h2 id="API_函数_">API 函数 </h2>
<p>现在来看一下能够创建新 slab 缓存、向缓存中增加内存、销毁缓存的应用程序接口（API）以及 slab 中对对象进行分配和释放操作的函数。 </p>
<p>第一个步骤是创建 slab 缓存结构，您可以将其静态创建为： </p>
<p>struct struct kmem_cache *my_cachep;  </p>
<p>然后其他 slab 缓存函数将使用该引用进行创建、删除、分配等操作。kmem_cache 结构包含了每个中央处理器单元（CPU）的数据、一组可调整的（可以通过 proc 文件系统访问）参数、统计信息和管理 slab 缓存所必须的元素。 </p>
<p>kmem_cache_create </p>
<p>内核函数 kmem_cache_create 用来创建一个新缓存。这通常是在内核初始化时执行的，或者在首次加载内核模块时执行。其原型定义如下： </p>
<p>struct kmem_cache <em> kmem_cache_create( const char </em>name, size_t size, size_t align,                        unsigned long flags;                        void (<em>ctor)(void</em>, struct kmem_cache <em>, unsigned long),                        void (</em>dtor)(void<em>, struct kmem_cache </em>, unsigned long));  </p>
<p>name 参数定义了缓存名称，proc 文件系统（在 /proc/slabinfo 中）使用它标识这个缓存。 size 参数指定了为这个缓存创建的对象的大小， align 参数定义了每个对象必需的对齐。 flags 参数指定了为缓存启用的选项。这些标志如表 1 所示。 </p>
<p>表 1. kmem_cache_create 的部分选项（在 flags 参数中指定） </p>
<p>选项                  说明 </p>
<p>SLAB_RED_ZONE      在对象头、尾插入标志，用来支持对缓冲区溢出的检查。 </p>
<p>SLAB_POISON            使用一种己知模式填充 slab，允许对缓存中的对象进行监视（对象属对象所有，不过可以在外部进行修改）。 </p>
<p>SLAB_HWCACHE_ALIGN             指定缓存对象必须与硬件缓存行对齐。 </p>
<p>ctor 和 dtor 参数定义了一个可选的对象构造器和析构器。构造器和析构器是用户提供的回调函数。当从缓存中分配新对象时，可以通过构造器进行初始化。 </p>
<p>在创建缓存之后， kmem_cache_create 函数会返回对它的引用。注意这个函数并没有向缓存分配任何内存。相反，在试图从缓存（最初为空）分配对象时，refill 操作将内存分配给它。当所有对象都被使用掉时，也可以通过相同的操作向缓存添加内存。 </p>
<p>kmem_cache_destroy </p>
<p>内核函数 kmem_cache_destroy 用来销毁缓存。这个调用是由内核模块在被卸载时执行的。在调用这个函数时，缓存必须为空。 </p>
<p>void kmem_cache_destroy( struct kmem_cache *cachep );  </p>
<p>kmem_cache_alloc </p>
<p>要从一个命名的缓存中分配一个对象，可以使用 kmem_cache_alloc 函数。调用者提供了从中分配对象的缓存以及一组标志： </p>
<p>void kmem_cache_alloc( struct kmem_cache *cachep, gfp_t flags );  </p>
<p>这个函数从缓存中返回一个对象。注意如果缓存目前为空，那么这个函数就会调用 cache_alloc_refill 向缓存中增加内存。kmem_cache_alloc 的 flags 选项与 kmalloc 的 flags 选项相同。表 2 给出了标志选项的部分列表。 </p>
<p>表 2. kmem_cache_alloc 和 kmalloc 内核函数的标志选项 </p>
<p>标志    说明 </p>
<p>GFP_USER 为用户分配内存（这个调用可能会睡眠）。 </p>
<p>GFP_KERNEL       从内核 RAM 中分配内存（这个调用可能会睡眠）。 </p>
<p>GFP_ATOMIC         使该调用强制处于非睡眠状态（对中断处理程序非常有用）。 </p>
<p>GFP_HIGHUSER       从高端内存中分配内存。 </p>
<p>kmem_cache_zalloc </p>
<p>内核函数 kmem_cache_zalloc 与 kmem_cache_alloc 类似，只不过它对对象执行 memset 操作，用来在将对象返回调用者之前对其进行清除操作。 </p>
<p>kmem_cache_free </p>
<p>要将一个对象释放回 slab，可以使用 kmem_cache_free。调用者提供了缓存引用和要释放的对象。 </p>
<p>void kmem_cache_free( struct kmem_cache <em>cachep, void </em>objp );  </p>
<p>kmalloc 和 kfree </p>
<p>内核中最常用的内存管理函数是 kmalloc 和 kfree 函数。这两个函数的原型如下： </p>
<p>void <em>kmalloc( size_t size, int flags ); void kfree( const void </em>objp );  </p>
<p>注意在 kmalloc 中，惟一两个参数是要分配的对象的大小和一组标志（请参看 表 2 中的部分列表）。但是 kmalloc 和 kfree 使用了类似于前面定义的函数的 slab 缓存。kmalloc 没有为要从中分配对象的某个 slab 缓存命名，而是循环遍历可用缓存来查找可以满足大小限制的缓存。找到之后，就（使用 <code>__kmem_cache_alloc</code>）分配一个对象。要使用 kfree 释放对象，从中分配对象的缓存可以通过调用 virt_to_cache 确定。这个函数会返回一个缓存引用，然后在 __cache_free 调用中使用该引用释放对象。 </p>
<h2 id="其他函数_">其他函数 </h2>
<p>slab 缓存 API 还提供了其他一些非常有用的函数。 kmem_cache_size 函数会返回这个缓存所管理的对象的大小。您也可以通过调用kmem_cache_name 来检索给定缓存的名称（在创建缓存时定义）。缓存可以通过释放其中的空闲 slab 进行收缩。这可以通过调用kmem_cache_shrink 实现。注意这个操作（称为回收）是由内核定期自动执行的（通过 kswapd）。 </p>
<p>unsigned int kmem_cache_size( struct kmem_cache <em>cachep ); const char </em>kmem_cache_name( struct kmem_cache <em>cachep ); int kmem_cache_shrink( struct kmem_cache </em>cachep ); </p>
<h2 id="补充：_">补充： </h2>
<p>如果对存储区的请求不频繁，就用一组普通高速缓存来处理，普通高速缓存中的对象具有几何分布的大小，范围为32~131072字节。 </p>
<p>使用kmalloc()函数申请，kfree()释放。   </p>
<p><br><br>本文章参考自《深入理解linux内核》及 <a href="https://www.ibm.com/developerworks/cn/linux/l-linux-slab-allocator/" target="_blank" rel="external">动态内存管理</a>。   </p>
]]></content>
         
         
           
             
              <breadCrumb title="linux" url="http://blog.tinyxd.me/categories/linux/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/07/31/linux-memory-management-3/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>linux内存管理（下）</title>
        <pubTime>2012-07-31T15:51:00.000Z</pubTime>
        
        <tag>linux </tag>
         
        <tag>kernel </tag>
         
         <content><![CDATA[<p><strong><em>摘要</em></strong>：把一块存放slab结构的内存区映射到一组连续的页框是最好的选择，这样会充分利用高速缓存并获得较低的平均访问时间。不过，上面的方式主要是针对那些使用非常频繁的内核数据结构——如task_struct、inode来设计的。如果对内存区的请求不是很频繁，那么，通过连续的线性地址，而不是物理地址来访问非连续的物理页框这样一种分配模式就会很有意义了。这种模式的主要优点是避免了外碎片，而缺点是必须打乱内核页表。此外，非连续内存区的大小必须是4096 的倍数。Linux 在几个方面使用非连续内存区：为活动的交换区分配数据结构，为模块分配空间，或者给某些I/O 驱动程序分配缓冲区等。此外，非连续内存区还提供了另一种使用高端内存页框的方法。 </p>
<h2 id="非连续内存区的线性地址_">非连续内存区的线性地址    </h2>
<p>要查找线性地址的一个空闲区，我们可以从PAGE_OFFSET开始查找（通常为0xc0000000，即第4 个GB 的起始地址）。下图让我们回忆了如何使用第4个GB 的线性地址：<br><a id="more"></a><br>回忆一下：    </p>
<iframe src="https://skydrive.live.com/embed?cid=1F260DE1061FCF3E&resid=1F260DE1061FCF3E%21156&authkey=ABbb5MTrh96mmAU" width="317" height="94" frameborder="0" scrolling="no"></iframe>


<p>（1）内存区的开始部分包含的是对前896MB RAM 进行映射的线性地址。直接映射的物理内存末尾所对应的线性地址保存在high_memory全局变量中。当物理内存小于896MB，则线性地址0xc0000000以后的896MB与其一一对应；当物理内存大于896MB而小于4GB时，只直接映射前896MB的地址到0xc0000000以后的线性空间，然后把线性空间的其他部分与896MB和4GB物理空间映射起来，称为动态重映射，这是本博的重点；当物理内存大于4GB，则需要考虑PAE的情况，其他的东东没什么区别，我们不做过多的回忆了。 </p>
<p>（2）内核的页表由内核页全局目录变量swapper_pg_dir维护；pagetable_init()建立内核页表项。 </p>
<p>（3）内存区的结尾部分包含的是固定映射的线性地址，主要用于存放一些常量线性地址，具体查看“高端内存映射”博文。 </p>
<p>（4）从PKMAP_BASE 开始，我们查找用于高端内存页框的永久内核映射的线性地址，具体查看“高端内存映射 ”博文。 </p>
<p>（5）其余的线性地址可以用于非连续内存区。在物理内存映射的末尾与第一个内存区之间插入一个大小为8MB（宏VMALLOC_OFFSET）的安全区，目的是为了“捕获”对内存的越界访问。出于同样的理由，插入其他4KB 大小的安全区来隔离非连续的内存区。 </p>
<h2 id="非连续内存区的描述符_">非连续内存区的描述符 </h2>
<p>每个非连续内存区都对应着一个类型为vm_struct 的描述符： </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> vm_struct { </div><div class="line"></div><div class="line">    <span class="keyword">void</span>            *addr; </div><div class="line"></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>        size; </div><div class="line"></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>        flags; </div><div class="line"></div><div class="line">    <span class="keyword">struct</span> page        **pages; </div><div class="line"></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        nr_pages; </div><div class="line"></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>        phys_addr; </div><div class="line"></div><div class="line">    <span class="keyword">struct</span> vm_struct    *next; </div><div class="line"></div><div class="line">};</div></pre></td></tr></table></figure>



<p>介绍下它的字段： </p>
<p>void *    addr    内存区内第一个内存单元的线性地址（首址） </p>
<p>unsigned long    size    内存区的大小加4096（内存区之间的安全区间的大小） </p>
<p>unsigned long    flags    非连续内存区映射的内存的类型 </p>
<p>struct page **    pages    指向nr_pages数组的指针，该数组由指向页描述符的指针组成 </p>
<p>unsigned int    nr_pages    内存区填充的页的个数 </p>
<p>unsigned long    phys_addr    该字段设为0，除非内存已被创建来映射一个硬件设备的I/O 共享内存 </p>
<p>struct vm_struct *    next    指向下一个vm_struct结构的指针 </p>
<h2 id="分配非连续内存区_">分配非连续内存区 </h2>
<p>vmalloc()函数给内核分配一个非连续内存区。参数size表示所请求内存区的大小。如果这个函数能够满足请求，就返回新内存区的起始地址；否则，返回一个NULL 指针（mm/ vmalloc.c） </p>
<p>其工作方式类似于kmalloc()，只不过vmalloc()分配的内存虚拟地址是连续的，而物理地址则无需连续。这也是用户空间分配函数的工作方式：由malloc()返回的页在进程的虚拟地址空间内是连续的，但是，这并不保证它们在物理RAM中也连续。kmalloc()函数确保页在物理地址上是连续的（虚拟地址自然也是连续的）。vmalloc()函数只确保页在虚拟地址空间内是连续的。vmalloc()仅在不得已时才会使用——一般是在为了获得大块内存时，例如，当模块被动态插入到内核中时，就把模块装载到由vmalloc()分配的内存上。 </p>
<p>伙伴关系也好、slab技术也好，从内存管理理论角度而言目的基本是一致的，它们都是为了防止“分片”，不过分片又分为外部分片和内部分片之说，所谓内部分片是说系统为了满足一小段内存区（连续）的需要，不得不分配了一大区域连续内存给它，从而造成了空间浪费；外部分片是指系统虽有足够的内存，但却是分散的碎片，无法满足对大块“连续内存”的需求。无论何种分片都是系统有效利用内存的障碍。slab分配器使得一个页面内包含的众多小块内存可独立被分配使用，避免了内部分片，节约了空闲内存。伙伴关系把内存块按大小分组管理，一定程度上减轻了外部分片的危害，因为页框分配不在盲目，而是按照大小依次有序进行，不过伙伴关系只是减轻了外部分片，但并未彻底消除。你自己比划一下多次分配页面后，空闲内存的剩余情况吧。 </p>
<p>所以避免外部分片的最终思路还是落到了如何利用不连续的内存块组合成“看起来很大的内存块”——这里的情况很类似于用户空间分配虚拟内存，内存逻辑上连续，其实映射到并不一定连续的物理内存上。Linux内核借用了这个技术，允许内核程序在内核地址空间中分配虚拟地址，同样也利用页表（内核页表）将虚拟地址映射到分散的内存页上。以此完美地解决了内核内存使用中的外部分片问题。内核提供vmalloc函数分配内核虚拟内存，该函数不同于kmalloc，它可以分配较Kmalloc大得多的内存空间（可远大于128K，但必须是页大小的倍数），但相比Kmalloc来说,Vmalloc需要对内核虚拟地址进行重映射，必须更新内核页表，因此分配效率上要低一些（用空间换时间）。   </p>
<h2 id="释放函数_">释放函数   </h2>
<p>vfree()函数释放vmalloc()或vmalloc_32()创建的非连续内存区，而vunmap()函数释放vmap()创建的内存区。两个函数都使用同一个参数 —— 将要释放的内存区的起始线性地址address；它们都依赖于<code>__vunmap()</code>函数来做实质性的工作。 </p>
<p><code>__vunmap()</code>函数接收两个参数：将要释放的内存区的起始地址的地址addr，以及标志deallocate_pages，如果被映射到内存区内的页框应当被释放到分区页框分配器（调用vfree()）中，那么这个标志被置位，否则被清除（vunmap()被调用）。该函数执行以下操作： </p>
<ol>
<li><p>调用remove_vm_area()函数得到vm_struct 描述符的地址area，并清除非连续内存区中的线性地址对应的内核的页表项。 </p>
</li>
<li><p>如果deallocate_pages 被置位，函数扫描指向页描述符的area-&gt;pages指针数组；对于数组的每一个元素，调用<code>__free_page()</code>函数释放页框到分区页框分配器。此外，执行kfree(area-&gt;pages)来释放数组本身。 </p>
</li>
<li><p>调用kfree(area)来释放vm_struct 描述符。</p>
</li>
</ol>
<p><br><br>本文章参考自《linux内核设计与实现》、<a href="http://blog.csdn.net/jiangyuping_fyl/article/details/7268287" target="_blank" rel="external">slab分配器</a> 及 <a href="http://blog.csdn.net/yunsongice/article/details/5536197" target="_blank" rel="external">非连续内存区</a> 。   </p>
]]></content>
         
         
           
             
              <breadCrumb title="linux" url="http://blog.tinyxd.me/categories/linux/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/08/01/awk-study/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>awk 学习</title>
        <pubTime>2012-07-31T16:15:00.000Z</pubTime>
        
        <tag>linux </tag>
         
        <tag>awk </tag>
         
         <content><![CDATA[<p>AWK是一种优良的文本处理工具。它不仅是 Linux 中也是任何环境中现有的功能最强大的数据处理引擎之一。这种编程及数据操作语言（其名称得自于它的创始人 Alfred Aho 、Peter Weinberger 和 Brian Kernighan 姓氏的首个字母）的最大功能取决于一个人所拥有的知识。AWK 提供了极其强大的功能：可以进行样式装入、流控制、数学运算符、进程控制语句甚至于内置的变量和函数。它具备了一个完整的语言所应具有的几乎所有精美特性。 </p>
<h2 id="一、awk调用方式_">一、awk调用方式 </h2>
<p>1、awk [-F field-separator] ‘commands’ input-file(s) </p>
<p>commands 是真正的awk命令 </p>
<p>-F 为域分隔符<br><a id="more"></a><br>2、第二种方法是将所有a w k命令插入一个文件，并使a w k程序可执行，然后用a w k命令解释 </p>
<p>器作为脚本的首行，以便通过键入脚本名称来调用它。 </p>
<p>3、第三种方式是将所有的a w k命令插入一个单独文件，然后调用： </p>
<p>awk -f awk-script-file input-files(s) </p>
<p><code>-f</code>选项指明在文件awkscriptfile中的awk脚本， inputfile(s)是使用awk进行浏览的文件 </p>
<p>名。 </p>
<h2 id="二、awk脚本_">二、awk脚本 </h2>
<p>1、awk由模式和动作组成，模式部分决定动作语句何时触发及触发事件 </p>
<p>模式可以是任何条件语句或复合语句或正则表达式。 模式包括两个特殊字段BEGIN和END </p>
<p>如： </p>
<p>awk ‘BEGIN{print “Name\n——-“}{print $1}END{“end-of-report”}’ </p>
<p>2、域和记录 </p>
<p>awk执行时，其浏览域标记为$1、$2…$n </p>
<p>$0指所有域 </p>
<p>保存awk输出 </p>
<p>(1)、awk ‘{print $0}’ grade.txt &gt;wow 即内容重定向 </p>
<p>(2)、使用tee命令 awk ‘{print $0}’ grade.txt | tee wow 既显示有写入文件 </p>
<p>3、元字符 </p>
<p>\ ^ $ . [] | () * + ? </p>
<p>其中： </p>
<p><code>+</code>使用+匹配一个或多个字符 </p>
<p>？ 匹配模式出现频率。例如使用/XY?Z/匹配XYZ或YZ </p>
<p>4、条件操作符 </p>
<p>&lt; 小于 </p>
<p><code>&gt;= 大于等于</code></p>
<p>&lt;= 小于等于 </p>
<p>~ 匹配正则表达式 </p>
<p>== 等于 </p>
<p>!~ 不匹配正则表达式 </p>
<p>!= 不等于 </p>
<p>(1)、awk ‘{if($4~/Brown/) print $0}’ grade.txt </p>
<p>其中if后面的条件用()括起来 </p>
<p>(2)、设置大小写 awk ‘/[Gg]reen/‘ grade.txt </p>
<p>(3)、任意字符<code>awk &#39;$1~/^...a/&#39; grade.txt</code>   </p>
<p>(4)、或关系匹配 awk ‘$0~/(Yellow)|(Brown)/‘ grade.txt </p>
<p>各表达式互相结合起来的表达式： </p>
<p>&amp;&amp; AND : 语句两边必须同时匹配为真。 </p>
<p>|| OR：语句两边同时或其中一边匹配为真。 </p>
<p>! 非求逆 </p>
<p>5、内置变量 </p>
<p>ARGC 命令行参数个数 </p>
<p>ARGV 命令行参数排列 </p>
<p>ENVIRON 支持队列中系统环境变量的使用 </p>
<p>FILENAME awk浏览的文件名 </p>
<p>FNR 浏览文件的记录数 </p>
<p>FS 设置输入域分隔符，等价于命令行- F选项 </p>
<p>NF 浏览记录的域个数 </p>
<p>NR 已读的记录数 </p>
<p>OFS 输出域分隔符 </p>
<p>ORS 输出记录分隔符 </p>
<p>RS 控制记录分隔符 </p>
<h2 id="三、awk操作符_">三、awk操作符 </h2>
<p>= += *= / = %= ^ = 赋值操作符 </p>
<p>？   条件表达操作符 </p>
<p>|| &amp;&amp; !   或、与、非（上一节已讲到） </p>
<p>~!~   匹配操作符，包括匹配和不匹配 </p>
<p>&lt; &lt;= == != &gt;&gt;  关系操作符 </p>
<p><code>+ - * / % ^  算术操作符</code></p>
<p><code>+ + --   前缀和后缀</code></p>
<p>1、设置输入域到域变量名 </p>
<p>cat crontab.bak  | awk ‘BEGIN{numall=20}{if($1~/[0-9]*/ &amp;&amp; $i&gt;numall &amp;&amp; NR &lt; 10) num+=$1} END{print num}’  </p>
<h2 id="四、内置的字符串函数_">四、内置的字符串函数 </h2>
<p>gsub(r,s) 在整个$ 0中用s替代r </p>
<p>gsub(r,s,t) 在整个t中用s替代r </p>
<p>index(s,t) 返回s中字符串t的第一位置 </p>
<p>length(s) 返回s长度 </p>
<p>match(s,r) 测试s是否包含匹配r的字符串 </p>
<p>split( s,a,fs) 在fs上将s分成序列a </p>
<p>sprint(fmt,exp) 返回经fmt格式化后的exp </p>
<p>sub(r,s) 用$ 0中最左边最长的子串代替s </p>
<p>substr(s,p) 返回字符串s中从p开始的后缀部分 </p>
<p>substr(s,p,n) 返回字符串s中从p开始长度为n的后缀部分 </p>
<p>实例： </p>
<p>1、awk ‘ BEGIN{numall=10}{gsub(12,20);if($1~/[0-9]*/  &amp;&amp; NR &lt; 10) num+=length($0);print substr($0,1,index($0,”=”));} END{print num}’ </p>
<p>2、awk ‘BEGIN {print split(“123#456#678”,myarray,”#”)}’ </p>
<p>   awk ‘BEGIN { split(“123#456#678”,myarray,”#”);print myarray[2]}’ </p>
<h2 id="五、字符串屏蔽序列_">五、字符串屏蔽序列 </h2>
<p>\b 退格键 \t tab键 </p>
<p>\f 走纸换页 \ddd 八进制值 </p>
<p>\n 新行 \c 任意其他特殊字符，例如\为反斜线符号 </p>
<p>\r 回车键 </p>
<p>1、printf修饰符 </p>
<p><code>- 左对齐</code></p>
<p>Width 域的步长，用0表示0步长 </p>
<p>.prec 最大字符串长度，或小数点右边的位数 </p>
<p>%c ASCII字符 </p>
<p>%d 整数 </p>
<p>%e 浮点数，科学记数法 </p>
<p>%f 浮点数，例如（123.44） </p>
<p>%g awk决定使用哪种浮点数转换e或者f </p>
<p>%o 八进制数 </p>
<p>%s 字符串 </p>
<p>%x 十六进制数 </p>
<p>如：awk ‘{printf “%-15s %s”,$1,$3}’    </p>
<p><br><br>本文<strong>转载</strong>自<a href="http://www.xuephp.com/main/detail.php?cid=22838" target="_blank" rel="external">awk学习整理和使用实例</a>。    </p>
]]></content>
         
         
           
             
              <breadCrumb title="linux" url="http://blog.tinyxd.me/categories/linux/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/08/02/blog-two-months/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>写在开博两个月</title>
        <pubTime>2012-08-02T10:46:00.000Z</pubTime>
        
        <tag>blog </tag>
         
         <content><![CDATA[<p>其实今天距离开博两个月还有几天的时间，因为今天PR变为2，所以写篇短文，记录下。<br>ps：今天和麦子做的网站——<a href="http://www.aitinan.com/" target="_blank" rel="external">挨踢男的那点事（专注移动互联网）</a>加了友链。其中不乏原创文章，写的很好。推荐大家去逛逛。</p>
]]></content>
         
         
           
             
              <breadCrumb title="essay" url="http://blog.tinyxd.me/categories/essay/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/08/05/linux-process-address-space/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>linux进程地址空间</title>
        <pubTime>2012-08-05T04:51:00.000Z</pubTime>
        
        <tag>linux </tag>
         
        <tag>kernel </tag>
         
         <content><![CDATA[<h2 id="简介_">简介   </h2>
<p>内核中获得动态内存的方式：<code>__get_free_pages()</code>或alloc_pages()从分区页框分配器中获得页框，kmem_cache_alloc()或kmalloc()使用slab分配器为专用或通用对象分配块，vmalloc()或vmalloc_32()获得一块非连续的内存区。如果所请求的内存区得以满足，这些函数都返回一个页描述符地址或线性地址（即所分配动态内存区的起始地址）。 </p>
<p>使用以上简单方法的原因： </p>
<pre><code>内核是操作系统中优先级最高的成分 

内核信任自己。 
</code></pre><p><a id="more"></a><br>当给用户态进程分配内存时： </p>
<pre><code>进程对动态内存的请求被认为是不紧迫的，内核总是尽量推迟给用户态进程分配动态内存。 

由于用户进程是不可信任的，因此 ，内核必须能随时准备捕获用户态进程引起的所有寻址错误。 
</code></pre><p>进程的地址空间（address space）由允许进程使用的全部线性地址组成。每个进程所看到的线性地址集合是不同的，一个进程所使用的地址与另外一个进程所使用的地址之间没有什么关系。后面我们会看到，内核可以通过增加或删除某些线性地址区间来动态修改进程的地址空间。 </p>
<p>内核通过所谓线性区的资源来表示线性地址区间，线性区是由起始线性地址、长度和一些访问权限来描述的。为了效率起见，起始地址和线性区的长度都必须是4096的倍数，以便每个线性区所识别的数据完全填满分配给它的页框。 </p>
<p>我们会在“缺页异常处理程序”博文中看到，确定一个进程当前所拥有的线性区（即进程的地址空间）是内核的基本任务，因为这可以让缺页异常处理程序有效地区分引发这个异常处理程序的两种不同类型的无效线性地址： </p>
<ul>
<li><p>由编程错误引发的无效线性地址。 </p>
</li>
<li><p>由缺页引发的无效线性地址；即使这个线性地址属于进程的地址空间，但是对应于这个地址的页框仍然有待分配。 </p>
</li>
</ul>
<p>从进程的观点来看，后一种地址不是无效的，内核要利用这种缺页以实现请求调页：内核通过提供页框来处理这种缺页，并让进程继续执行。 </p>
<h2 id="内存描述符_">内存描述符 </h2>
<p>与进程地址空间有关的全部信息都包含在一个叫做内存描述符（memory descriptor）的数据结构中，这个结构的类型为mm_struct，进程描述符的mm字段就指向这个结构。 </p>
<p>所有的内存描述符存放在一个双向链表中。每个描述符在mmlist段存放链表相邻元素的地址。链表的第一个元素是init_mm的mmlist字段，init_mm是初始化阶段进程0所使用的内存描述符。mmlist_lock自旋锁保护多处理器系统对链表的同时访问（同样是位于include/linux/Sched.h）： </p>
<p>extern spinlock_t mmlist_lock; </p>
<p>mm_users字段存放共享mm_struct数据结构的轻进程的个数。mm_count字段是内存描述符的主是使用计数器，在mm_users次使用计数器中的所有用户在mm_count中只作为一个单位。每当mm_count递减时，内核都要检查它是否变为0，如果是，就要解除这个内存描述符，因为不再有用户使用它。 </p>
<p>我们用一个例子来解释mm_users和mm_count之间的不同。如果一个内存描述符由两个轻量级进程共享。它的mm_users字段通常存放的值为2，而mm_count字段存放的值为1（两个所有者进程算作一个）。 </p>
<p>如果把内存描述符暂时借给一个内核线程，那么，内核就增加mm_count。这样，即使两个轻量级进程都死亡，且mm_users字段变为0，这个内存描述符也不被释放，直到内核线程使用完为止，因为mm_count字段仍然大于0。 </p>
<p>但是，如果内核想确保内存描述符在一个长操作的中间不被释放，那么，就应该增加mm_users字段而不是mm_coont字段的值。最终的结果是相同的，因为mm_users的增加确保了mm_count不变为0，即使拥有这个内存描述符的所有轻进程全部死亡。 </p>
<h2 id="内核线程的内存描述符_">内核线程的内存描述符 </h2>
<p>内核线程仅运行在内核态，因此，它们永远不会访问低于TASK_SIZE（等于PAGE_OFFSET，通常为0xc0000000，即768MB)的地址。与普通进程相反，内核线程不用线性区（vm_area_struct），因此，内存描述符的很多字段对内核线程是没有意义的。 </p>
<p>因为大于TASK_SIZE线性地址的相应页表项都应该总是相同的，因此，一个内核线程到底使用什么样的页表集根本就没有什么关系。为了避免无用的TLB和高速缓存刷新，内核线程使用一组最近运行的普通进程的页表。所以，我们在每个进程描述符中包含了两种内存描述符的指针：mm和active_mm。 </p>
<p>进程描述符中的mm字段指向进程所拥有的内存描述符，而active_mm字段指向进程运行时所使用的内存描述符。对于普通进程而言，这两个字段存放相同的指针。但是，内核线程不拥有任何内存描述符，因此，它们的mm字段总是为NULL。当内核线程得以运行时，他的active_mm字段被初始化为前一个运行进程的active_mm值。</p>
<p><br><br>本文章参考自《深入理解linux内核》 。   </p>
]]></content>
         
         
           
             
              <breadCrumb title="linux" url="http://blog.tinyxd.me/categories/linux/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/08/07/linux-linear-regions/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>linux线性区</title>
        <pubTime>2012-08-07T04:43:00.000Z</pubTime>
        
        <tag>linux </tag>
         
        <tag>kernel </tag>
         
         <content><![CDATA[<p><strong><em>摘要</em></strong>：内核使用一种新的资源成功实现了对进程动态内存的推迟分配。当用户态进程请求动态内存时，并没有获得请求的页框，而仅仅获得对一个新的线性地址区间的使用权，而这一线性地址区间就成为进程地址空间的一部分。这一区间叫做“线性区”（memory region）。<br><br><br>Linux通过类型为vm_area_struct的对象实现线性区。 </p>
<p>每次运行一个程序，该程序的内容必须被放到进程的虚拟地址空间，对于可执行程序的共享库也是如此。可执行程序并非真正读到物理内存中，而只是链接到进程的虚拟内存中。<br><a id="more"></a><br>不论我们运行某个程序多少次内存分配地址（bss、栈、堆、数据段、正文段）都是一样的。我们知道，linux操作系统每个进程的地址空间都是独立的，其实这里的独立说得是物理空间上得独立。即相同的虚拟地址，不同的物理地址。 </p>
<p>当一个可执行程序映射到进程虚拟地址空间时，一组vm_area_struct数据结构将被产生。每个vm_area_struct数据结构表示可执行印象的一部分;是可执行代码，或是初始化的数据，以及未初始化的数据等。 </p>
<p>　　linux操作系统是通过sys_exec对可执行文件进行映射以及读取的，有如下几步： </p>
<p>　　1.创建一组vm_area_struct </p>
<p>　　2.圈定一个虚拟用户空间，将其起始结束地址(elf段中已设置好)保存到vm_start和vm_end中。 </p>
<p>　　3.将磁盘file句柄保存在vm_file中 </p>
<p>　　4.将对应段在磁盘file中的偏移值(elf段中已设置好)保存在vm_pgoff中; </p>
<p>　　5.将操作该磁盘file的磁盘操作函数保存在vm_ops中 </p>
<p>　　注意：这里没有对应 的页目录表项创建页表，更不存在设置页表项了。 </p>
<p>每个线性区描述符表示一个线性地址区间。vm_start字段包含区间的第一个线性地址，而vm_end字段包含区间之外的第一个线性地址。vm_end - vm_start表示线性区的长度。vm_mm字段指向拥有这个区间的进程的mm_struct内存描述符。我们稍后将描述vm_area_struct的其他字段。 </p>
<p>进程所拥有的线性区从来不重叠，并且内核尽力把新分配的线性区与紧邻的现有线性区进行合并。两个相邻区的访问权限如果相匹配，就能把它们合并在一起。 </p>
<p>当一个新的线性地址区间加入到进程的地址空间时，内核检查一个已经存在的线性区是否可以扩大。如果不能，就创建一个新的线性区。类似地，如果从进程的地址空间删除一个线性地址区间，内核就要调整受影响的线性区大小。有些情况下，调整大小迫使一个线性区被分成两个更小的部分（从理论上说，如果没有空闲的内存给新的内存描述符使用，删除一个线性地址区间可能会失败，不过这种情况出现的概率太小太小）。 </p>
<h2 id="线性区的数据结构_">线性区的数据结构 </h2>
<p>进程所拥有的所有线性区是通过一个简单的链表链接在一起的。出现在链表中的线性区是按内存地址的升序排列的；不过，每两个线性区可以由未用的内存地址区隔开。每个vm_area_struct元素的vm_next字段指向链表的下一个元素。内核通过进程的内存描述符的mmap字段来查找线性区，其中mmap字段指向链表中的第一个线性区描述符。 </p>
<p>内存描述符的map_count字段存放进程所拥有的线性区数目。默认情况下，一个进程可以最多拥有65536个不同的线性区，系统管理员可以通过写/proc/sys/vm/max_map_count文件来修改这个限定值。 </p>
<p>内核频繁执行的一个操作就是查找包含指定线性地址的线性区。由于链表是经过排序的，因此，只要在指定线性地址之后找到一个线性区，搜索就可以结束。 </p>
<p>然而，仅当进程的线性区非常少时使用这种链表才是很方便的，比如说只有一二十个线性区。在链表中查找元素、插入元素、删除元素涉及许多操作，这些操作所花费的时间与链表的长度成线性比例。 </p>
<p>尽管多数的Linux进程使用的线性区的数量非常少，但是诸如面向对象的数据库，或malloc()的专用调试器那样过于庞大的大型应用程序可能会有成百上千的线性区。在这种情况下，线性区链表的管理变得非常低效，因此，与内存相关的系统调用的性能就降低到令人无法忍受的程度。 </p>
<p>Linux2.6实现了两种一种是线性的链表结构方便顺序索引，而红黑树的数据结构方便查找。 </p>
<h2 id="红黑树_">红黑树    </h2>
<p>二叉排序树：每个元素（或说节点）通常有两个孩子：左孩子和右孩子。树中的元素被排序。对关键字为N的节点，它的左子树上的所有元素的关键字都比N小；相反，它的右子树上的所有元素的关键字都比N大。节点的关键字被写入节点内部。而除了具有基本的二叉排序树的特点以外，红-黑树必须满足下列5条规则： </p>
<p>1、每个节点必须或为黑或为红。 </p>
<p>2、树的根必须为黑。 </p>
<p>3、新插入的节点必须为红色。 </p>
<p>4、红节点的孩子必须为黑。 </p>
<p>5、从一个节点到后代叶子节点的每个路径都包含相同数量的黑节点。当统计黑节点个数时，空指针也算作黑节点。 </p>
<p>这5条规则确保具有n个内部节点的任何红一黑树其高度最多为2 × log（n+l）。 </p>
<p>在红-黑树中搜索一个元素因此而变得非常高效，因为其操作的执行时间与树大小的对数成线性比例。换句话说，双倍的线性区个数只多增加一次循环。 </p>
<p>在红黑树中插入和删除一个元素也是高效的，因为算法能很快地遍历树以确定插入元素的位置或删除元素的位置。任何新节点必须作为一个叶子插入并着成红色。如果操作违背了上述规则，就必须移动或重新着色树的几个节点。 </p>
<p>为了存放进程的线性区，Linux既使用了链表，也使用了红-黑树。这两种数据结构包含指向同一线性区描述符的指针，当插入或删除一个线性区描述符时，内核通过红-黑树搜索前后元素，并用搜索结果快速更新链表而不用扫描链表。 </p>
<p>链表的头由内存描述符的mmap字段所指向。任何线性区对象都在vm_next字段存放指向链表下一个元素的指针。红-黑树的首部由内存描述符的mm_rb字段所指向。任和线性区对象都在类型为rb_node的vm_rb字段中存放节点颜色以及指向双亲、左孩子和右孩子的指针。 </p>
<p>一般来说，红-黑树用来确定含有指定地址的线性区，而链表通常在扫描整个线性区集合时来使用。 </p>
<h2 id="线性区访问权限_">线性区访问权限 </h2>
<p>页与线性区的关系：我们使用“页”这个术语既表示一组线性地址和其物理地址对应的关系。尤其是，我们把介于0-4095之间的线性地址区间称为第0页，介于4096-8191之间的线性地址区间称为第1页，依此类推。因此每个线性区都由一组号码连续的页所构成。 </p>
<p>与页相关的两种标志： </p>
<ul>
<li><p>在每个页表项中存放的几个标志，如：Read/Write、Present等（参见“常规分页”）。 </p>
</li>
<li><p>存放在每个页描述符flags字段中的一组标志（参见的“页框管理”）。 </p>
</li>
</ul>
<p>第一种标志由80x86硬件用来检查能否执行所请求的寻址类型；第二种标志由Linux用于许多不同的目的。 </p>
<p>现在介绍第三种标志，即与线性区的页相关的那些标志。它们存放在vm_area_struct描述符的vm_flags字段中。一些标志给内核提供有关这个线性区全部页的信息，例如它们包含有什么内容，进程访问每个页的权限是什么。另外的标志描述线性区自身，例如它应该如何增长（这些标志位于include/linux/Mm.h）。 </p>
<p>VM_READ：页是可读的 </p>
<p>VM_WRITE：页是可写的 </p>
<p>VM_EXEC：页是可执行的 </p>
<p>VM_SHARED：页可以由几个进程共享 </p>
<p>VM_MAYREAD：可以设置VM_READ标志 </p>
<p>VM_MAYWRITE：可以设置VM_WRITE标志 </p>
<p>VM_MAYEXEC：可以设置VM_EXEC标志 </p>
<p>VM_MAYSHARE：可以设置VM_SHARE标志 </p>
<p>VM_GROWSDOWN：线性区可以向低地址扩展 </p>
<p>VM_GROWSUP：线性区可以向高地址扩展 </p>
<p>VM_SHM：线性区用于IPC的共享内存 </p>
<p>VM_DENYWRITE：线性区映射一个不能打开用于写的文件 </p>
<p>VM_EXECUTABLE：线性区映射一个可执行文件 </p>
<p>VM_LOCKED：线性区中的页被锁住，且不能换出 </p>
<p>VM_IO：线性区映射设备的I/O地址空间 </p>
<p>VM_SEQ_READ：应用程序顺序地访问页 </p>
<p>VM_RAND_READ：应用程序以真正的随机顺序访问页 </p>
<p>VM_DONTCOPY：当创建一个新进程时不拷贝线性区 </p>
<p>VM_DONTEXPAND：通过mremap()系统调用禁止线性区扩展 </p>
<p>VM_RESERVED：线性区是特殊的（如：它映射某个设备的I/O地址空间），因此它的页不能被交换出去 </p>
<p>VM_ACCOUNT：创建IPC共享线性区时检查是否有足够的空闲内存用干映射 </p>
<p>VM_HUGETLB：通过扩展分页机制处理线性区中的页 </p>
<p>VM_NONLINEAR：线性区实现非线性文件映射 </p>
<p>线性区描述符所包含的页访问权限可以任意组合。例如，存在这样一种可能性，允许一个线性区中的页可以执行但是不可以读取。为了有效地实现这种保护方案，与线性区的页相关的访问权限（读、写及执行）必须被复制到相应的所有表项中，以便由分页单元直接执行检查。换句话说，页访问权限表示何种类型的访问应该产生一个缺页异常。Linux委派缺页处理程序查找导致缺页的原因，因为缺页处理程序实现了许多页处理策略。 </p>
<p>页表标志的初值（注意，同一线性区所有页标志的初值必须一样）存放在vm_area_struct描述符的vm_page_prot字段中。当增加一个页时，内核根据vm_page_prot字段的值设置相应页表项中的标志。 </p>
<pre><code><span class="keyword">typedef</span> <span class="keyword">struct</span> { <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> pgprot; } pgprot_t;   <span class="comment">/* include/asm-i386/Page.h */</span> 
</code></pre><p>然而，不能把线性区的访问权限直接转换成页保护位，这是因为： </p>
<ul>
<li><p>在某些情况下，即使由相应线性区描述符的vm flags字段所指定的某个页的访问权限允许对该页进行访问，但是，对该页的访问还是应当产生一个缺页异常。例如“写时复制”的情况，内核可能决定把属于两个不同进程的两个完全一样的可写私有页（它的VM_SHARE标志被清0）存入同一个页框中；在这种情况下，无论哪一个进程试图改动这个页都应当产生一个异常。 </p>
</li>
<li><p>80x86处理器的页表仅有两个保护位，即Read/Write和User/Supervisor标志。此外，一个线性区所包含的任何一个页的User/Supervisor标志必须总置为1，因为用户态进程必须总能够访问其中的页。 </p>
</li>
<li><p>启用PAE的新近Intel Pentium 4微处理器，在所有64位页表项中支持NX（No eXecute）标志。 </p>
</li>
</ul>
<p>如果内核没有被编译成支持PAE，那么Linux采取以下规则以克服80x86微处理器的硬件限制： </p>
<ul>
<li><p>读访问权限总是隐含着执行访问权限，反之亦然。 </p>
</li>
<li><p>写访问权限总是隐含着读访问权限。 </p>
</li>
</ul>
<p>反之，如果内核被编译成支持PAE，而且CPU有NX标志，Linux就采取不同的规则： </p>
<ul>
<li><p>行访问权限总是隐含着读访问权限。 </p>
</li>
<li><p>访问权限总是隐含着读访问权限。 </p>
</li>
</ul>
<p>因此，要根据以下规则精简由读、写、执行和共享访问权限的16种可能组合： </p>
<ul>
<li><p>如果页具有写和共享两种访问权限，那么，Read/Write位被设置为1。 </p>
</li>
<li><p>如果页具有读或执行访问权限，但是既没有写也没有共享访问权限，那么，Read/Write位被清0。 </p>
</li>
<li><p>如果支持NX位，而且页没有执行访问权限，那么，把NX位设置为1。 </p>
</li>
<li><p>如果页没有任何访问权限，那么，Presen七位被清0，以便每次访问都产生一个缺页异常。然而，为了把这种情况与真正的页框不存在的情况相区分，Linux还把Page size位置为1（你可能认为Page size位的这种用法并不正当，因为这个位本来是表示实际页的大小。但是，Linux可以侥幸逃脱这种骗局，因为80 x 86芯片在页目录项中检查Page size位，而不是在页表的表项中检查该位。） </p>
</li>
</ul>
<p>访问权限的每种组合所对应的精简后的保护位存放在protection_map数组的16个元素中（mm/Mmap.c）： </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">pgprot_t protection_map[<span class="number">16</span>] = { </div><div class="line"></div><div class="line">__P000, __P001, __P010, __P011, __P100, __P101, __P110, __P111, </div><div class="line"></div><div class="line">__S000, __S001, __S010, __S011, __S100, __S101, __S110, __S111 </div><div class="line"></div><div class="line">}; </div><div class="line"></div><div class="line"><span class="comment">//include/asm-i386/Pgtable.h </span></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> __P000 PAGE_NONE </span></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> __P001 PAGE_READONLY </span></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> __P010 PAGE_COPY </span></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> __P011 PAGE_COPY </span></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> __P100 PAGE_READONLY_EXEC </span></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> __P101 PAGE_READONLY_EXEC </span></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> __P110 PAGE_COPY_EXEC </span></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> __P111 PAGE_COPY_EXEC </span></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> __S000 PAGE_NONE </span></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> __S001 PAGE_READONLY </span></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> __S010 PAGE_SHARED </span></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> __S011 PAGE_SHARED </span></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> __S100 PAGE_READONLY_EXEC </span></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> __S101 PAGE_READONLY_EXEC </span></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> __S110 PAGE_SHARED_EXEC </span></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> __S111 PAGE_SHARED_EXEC</span></div></pre></td></tr></table></figure>

<p>例如： </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> COPY_EXEC / </span></div><div class="line"></div><div class="line">__pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_ACCESSED)</div></pre></td></tr></table></figure>

<p><br><br>本文章参考自《深入理解linux内核》 。   </p>
]]></content>
         
         
           
             
              <breadCrumb title="linux" url="http://blog.tinyxd.me/categories/linux/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/08/07/linux-page-fault-exception/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>linux缺页异常处理程序</title>
        <pubTime>2012-08-07T04:54:00.000Z</pubTime>
        
        <tag>linux </tag>
         
        <tag>kernel </tag>
         
         <content><![CDATA[<p>Linux的缺页（Page Fault）异常处理程序必须区分以下两种情况：由编程错误所引起的异常，及由引用属于进程地址空间但还尚未分配物理页框的页所引起的异常。  </p>
<p>线性区描述符可以让缺页异常处理程序非常有效地完成它的工作。do_page_fault()函数是80x86上的缺页中断服务程序，它把引起缺页的线性地址和当前进程的线性区相比较，从而能够根据和下图所示的方案选择适当的方法处理这个异常。<br><a id="more"></a></p>
<iframe src="https://skydrive.live.com/embed?cid=1F260DE1061FCF3E&resid=1F260DE1061FCF3E%21159&authkey=ACvRvyPr-3BWicI" width="320" height="207" frameborder="0" scrolling="no"></iframe> 

<p>在实际中，情况更复杂一些，因为缺页处理程序必须处理多种分得更细的特殊情况，它们不宜在总体方案中列出来，还必须区分许多种合理的访问。处理程序的详细流程图如图所示： </p>
<iframe src="https://skydrive.live.com/embed?cid=1F260DE1061FCF3E&resid=1F260DE1061FCF3E%21160&authkey=AFYUnmLPL0RCxXM" width="299" height="319" frameborder="0" scrolling="no"></iframe> 





<p>本文参考自《深入理解linux内核》和<a href="http://blog.csdn.net/yunsongice/article/details/5637671" target="_blank" rel="external">缺页异常处理程序</a> 。    </p>
]]></content>
         
         
           
             
              <breadCrumb title="linux" url="http://blog.tinyxd.me/categories/linux/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/08/08/linux-system-calls/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>linux系统调用</title>
        <pubTime>2012-08-08T10:18:00.000Z</pubTime>
        
        <tag>linux </tag>
         
        <tag>kernel </tag>
         
         <content><![CDATA[<p><strong><em>摘要</em></strong>：操作系统为在用户态运行的进程与硬件设备（如CPU、磁盘、打印机等等）进行交互提供了一组接口。在应用程序和硬件之间设置一个额外层具有很多优点。首先，这使得编程更加容易，那用户从学习硬件设备的低级编程特性中解放出来。其次，这极大地提高了系统的安全性，因为内核在试图满足某个请求之前在接口级就可以检查这种请求的正确性。最后，更重要的是这些接口使得程序更具有可移植性，因为只要内核所提供的一组接口相同，那么在任一内核上就可以正确地编译和执行程序。    </p>
<h2 id="简介_">简介     </h2>
<p>系统调用是在内核中实现的，再通过一定的方式把系统调用给用户，一般都通过门(gate)陷入(trap)实现。系统调用是用户程序和内核交互的接口。 <br><a id="more"></a><br>Linux系统在CPU的保护模式下提供了四个特权级别，目前内核都只用到了其中的两个特权级别，分别为“特权级0”和“特权级3”,[软间隔]级别0也就是我们通常所讲的内核模式，级别3也就是我们通常所讲的用户模式。划分这两个级别主要是对系统提供保护。内核模式可以执行一些特权指令和进入用[软间隔]户模式，而用户模式则不能。  </p>
<p>系统服务之所以需要通过系统调用提供给用户空间的根本原因是为了对系统“保护”，因为我们知道Linux的运行空间分为内核空间与用户空间，它们各自运行在不同的级别中，逻辑上相互隔离。所以用户进程在通常情况下不允许访问内核数据，也无法使用内核函数，它们只能在用户空间操作用户数据，调用户用空间函数。比如我们熟悉的“hello world”程序（执行时）就是标准的户空间进程，它使用的打印函数printf就属于用户空间函数，打印的字符“hello word”字符串也属于用户空间数据。 </p>
<p>但是很多情况下，用户进程需要获得系统服务（调用系统程序），这时就必须利用系统提供给用户的“特殊”接口——系统调用了，它的特殊性主要在于规定了用户进程进入内核的具体位置；换句话说用户访问内核的路径是事先规定好的，只能从规定位置进入内核，而不准许肆意跳入内核。有了这样的陷入内核的统一访问路径限制才能保证内核安全无虞。我们可以形象地描述这种机制：作为一个游客，你可以买票要求进入野生动物园，但你必须老老实实的坐在观光车上，按照规定的路线观光游览。当然，不准下车，因为那样太危险，不是让你丢掉小命，就是让你吓坏了野生动物。 </p>
<h2 id="API和系统调用_">API和系统调用 </h2>
<p>应用编程接口（API）与系统调用有所不同，前者只是一个函数定义，说明了如何获得一个给定的服务；而后者是通过软中断向内核态发出一个明确的请求。 </p>
<p>从编程者的观点看，API和系统调用之间的差别是没有关系的：唯一相关的事情就是函数名、参数类型及返回代码的含义。然而，从内核设计者的观点看，这种差别确实有关系，因为系统调用属于内核，而用户态的库函数不属于内核。 </p>
<h2 id="系统调用、用户编程接口（API）、系统命令、和内核函数的关系_">系统调用、用户编程接口（API）、系统命令、和内核函数的关系 </h2>
<p>系统调用并非直接和程序员或系统管理员打交道，它仅仅是一个通过软中断机制（我们后面讲述）向内核提交请求，获取内核服务的接口。而在实际使用中程序员调用的多是用户编程接口——API，而管理员使用的则多是系统命令。 </p>
<p>用户编程接口其实是一个函数定义，说明了如何获得一个给定的服务，比如read()、malloc()、free（）、abs()等。它有可能和系统调用形式上一致，比如read()接口就和read系统调用对应，但这种对应并非一一对应，往往会出现几种不同的API内部用到统一个系统调用，比如malloc()、free（）内部利用brk( )系统调用来扩大或缩小进程的堆；或一个API利用了好几个系统调用组合完成服务。更有些API甚至不需要任何系统调用——因为它不必需要内核服务，如计算整数绝对值的abs（）接口。 </p>
<p>另外要补充的是Linux的用户编程接口遵循了在Unix世界中最流行的应用编程界面标准——POSIX标准，这套标准定义了一系列API。在Linux中（Unix也如此）这些API主要是通过C库（libc）实现的，它除了定义的一些标准的C函数外，一个很重要的任务就是提供了一套封装例程（wrapper routine）将系统调用在用户空间包装后供用户编程使用。 </p>
<p>不过封装并非必须的，如果你愿意直接调用，Linux内核也提供了一个syscall()函数来实现调用，我们看个例子来对比一下通过C库调用和直接调用的区别。 </p>
<p>  </p>
<figure class="highlight c"><figcaption><span>例子</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;syscall.h&gt; </span></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;unistd.h&gt; </span></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt; </span></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;sys/types.h&gt; </span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">void</span>) { </div><div class="line"></div><div class="line"><span class="keyword">long</span> ID1, ID2; </div><div class="line"></div><div class="line"><span class="comment">/*-----------------------------*/</span> </div><div class="line"></div><div class="line"><span class="comment">/* 直接系统调用*/</span> </div><div class="line"></div><div class="line"><span class="comment">/* SYS_getpid (func no. is 20) */</span> </div><div class="line"></div><div class="line"><span class="comment">/*-----------------------------*/</span> </div><div class="line"></div><div class="line">ID1 = syscall(SYS_getpid); </div><div class="line"></div><div class="line"><span class="built_in">printf</span> (<span class="string">"syscall(SYS_getpid)=%ld\n"</span>, ID1); </div><div class="line"></div><div class="line"><span class="comment">/*-----------------------------*/</span> </div><div class="line"></div><div class="line"><span class="comment">/* 使用"libc"封装的系统调用 */</span> </div><div class="line"></div><div class="line"><span class="comment">/* SYS_getpid (Func No. is 20) */</span> </div><div class="line"></div><div class="line"><span class="comment">/*-----------------------------*/</span> </div><div class="line"></div><div class="line">ID2 = getpid(); </div><div class="line"></div><div class="line"><span class="built_in">printf</span> (<span class="string">"getpid()=%ld\n"</span>, ID2); </div><div class="line"></div><div class="line"><span class="keyword">return</span>(<span class="number">0</span>); </div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>  </p>
<p>系统命令相对编程接口更高了一层，它是内部引用API的可执行程序，比如我们常用的系统命令ls、hostname等。Linux的系统命令格式遵循系统V的传统，多数放在/bin和/sbin下（相关内容可看看shell等章节）。 </p>
<p>有兴趣的话可以通过strace ls或strace hostname 命令查看一下它们用到的系统调用，你会发现诸如open、brk、fstat、ioctl 等系统调用被用在系统命令中。 </p>
<p>下一个需要解释一下的问题是内核函数和系统调用的关系，内核函数大家不要想像的过于复杂，其实它们和普通函数很像，只不过在内核实现，因此要满足一些内核编程的要求[3]。系统调用是一层用户进入内核的接口，它本身并非内核函数，进入内核后，不同的系统调用会找到对应到各自的内核函数——换个专业说法就叫：系统调用服务服务例程。实际对请求服务的是内核函数而非调用接口。 </p>
<p>比如系统调用 getpid实际就是调用内核函数sys_getpid。 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">asmlinkage <span class="keyword">long</span> sys_getpid(<span class="keyword">void</span>) </div><div class="line"></div><div class="line">{ </div><div class="line"></div><div class="line">       <span class="keyword">return</span> current-&gt;tpid; </div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>Linux系统种存在许多的内核函数，有些是内核文件种自己使用的，有些则是可以export出来供内核其他部分共同使用的，具体情况自己决定。 </p>
<p>内核公开的内核函数——export出来的——可以使用命令ksyms 或 cat /proc/ksyms来查看。另外网上还有一本归纳分类内核函数的书叫作《The Linux Kernel API Book》，有兴趣的读者可以去看看。 </p>
<p>总而言之，从用户角度向内核看，依次是系统命令、编程接口、系统调用和内核函数。 </p>
<h2 id="系统调用处理程序及服务例程_">系统调用处理程序及服务例程 </h2>
<p>当用户态的进程调用一个系统调用时，CPU切换到内核态并开始执行一个内核函数，在80x86体系结构中，可以用两种不同的方式调用Linux的系统调用。两种方式的最终结果都是跳转到所谓系统调用处理程序（systerm call handler）的汇编语言函数。 </p>
<p>因为内核实现了很多不同的系统调用，因此进程必须传递一个名为系统调用号（systerm call number）的参数来识别所需的系统调用，eax寄存器就用作此目的。 </p>
<p>所有的系统调用都返回一个整数值。这些返回值与封装例程返回值的约定是不同的。在内核中，正数或0表示系统调用成功结束，而负数表示一个出错条件。在后一种情况下，这个值就是存放在errno变量中必须返回给应用程序的负出错码。内核没有设置或使用errno变量，而封装例程从系统调用返回之后设置这个变量。 </p>
<p>xyz()系统调用对应的服务例程的名字通常是sys_xyz()。不过也会有些例外。 </p>
<p>Linux中实现系统调用利用了0x86体系结构中的软件中断[4]。软件中断和我们常说的中断(硬件中断)不同之处在于——它是通过软件指令触发而并非外设，也就是说又编程人员出发的一种异常，具体的讲就是调用int $0x80汇编指令，这条汇编指令将产生向量为128的编程异常。 </p>
<p>之所以系统调用需要借助异常实现，是因为当用户态的进程调用一个系统调用时，CPU便被切换到内核态执行内核函数[5]，而我们在i386体系结构部分已经讲述过了进入内核——进入高特权级别——必须经过系统的门机制，这里异常实际上就是通过系统门陷入内核（除了int 0x80外用户空间还可以通过int3——向量3、into——向量4 、bound——向量5等异常指令进入内核，而其他异常用户空间程序无法利用，都是由系统使用的）。 </p>
<p>我们更详细的解释一下这个过程。int $0x80指令目的是产生一个编号为128的编程异常，这个编程异常对应的中断描述符表IDT中的第128项——也就是对应的系统门描述符。门描述符中含有一个预设的内核空间地址，它指向了系统调用处理程序：system_call()（别和系统调用服务程序混淆,这个程序在entry.S文件中用汇编语言编写）。 </p>
<p>很显然所有的系统调用都会统一的转到这个地址，但Linux一共有2、3百个系统调用都从这里进入内核后又该如何派发它们到各自的服务程序去呢？别发昏，解决这个问题的方法非常简单：首先Linux为每个系统调用都进行了编号（0—NR_syscall），同时在内核中保存了一张系统调用表，该表中保存了系统调用编号和其对应的服务例程，因此在系统调入通过系统门陷入内核前，需要把系统调用号一并传入内核，在x86上，这个传递动作是通过在执行int0x80前把调用号装入eax寄存器实现的。这样系统调用处理程序一旦运行，就可以从eax中得到数据，然后再去系统调用表中寻找相应服务例程了。 </p>
<p>除了需要传递系统调用号以外，许多系统调用还需要传递一些参数到内核，比如sys_write(unsigned int fd, const char * buf, size_t count)调用就需要传递文件描述符号fd和要写入的内容buf和写入字节数count等几个内容到内核。碰到这种情况，Linux会有6个寄存器使用来传递这些参数：eax (存放系统调用号)、 ebx、ecx、edx、esi及edi来存放这些额外的参数（以字母递增的顺序）。具体做法是在system_call( )中使用SAVE_ALL宏把这些寄存器的值保存在内核态堆栈中。 </p>
<p>有始便有终，当服务例程结束时，system_call( ) 从eax获得系统调用的返回值，并把这个返回值存放在曾保存用户态 eax寄存器栈单元的那个位置上。然后跳转到ret_from_sys_call( )，终止系统调用处理程序的执行。 </p>
<p>当进程恢复它在用户态的执行前，RESTORE_ALL宏会恢复用户进入内核前被保留到堆栈中的寄存器值。其中eax返回时会带回系统调用的返回码。（负数说明调用错误，0或正数说明正常完成） </p>
<h2 id="参数传递_">参数传递 </h2>
<p>与普通函数类似，系统调用通常也需要输入/输出参数，这些参数可能是实际的值，也可能是用户态进程地址空间的变量，甚至是指向用户态函数的指针的数据结构地址。 </p>
<p>普通C函数的参数传递是通过把参数值写入活动的程序栈（用户态栈或内核态栈）实现的。因为系统调用是一种横跨用户和内核两大陆地的特殊函数，所以既不能使用用户态栈也不能使用内核态栈。更确切地说，在发怵系统调用之前，系统调用的参数被写入CPU寄存器，然后在调用系统调用服务例程之前，内核再把存放在CPU中的参数拷贝到内核态堆栈中，这是因为系统调用服务例程是普通的C函数。 </p>
<p><br><br>本文参考自《深入理解linux内核》和<a href="http://chriszeng87.iteye.com/blog/1204500" target="_blank" rel="external">linux系统调用</a> 。   </p>
]]></content>
         
         
           
             
              <breadCrumb title="linux" url="http://blog.tinyxd.me/categories/linux/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/08/09/linux-heap-management/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>linux堆的管理</title>
        <pubTime>2012-08-09T10:32:00.000Z</pubTime>
        
        <tag>linux </tag>
         
        <tag>kernel </tag>
         
         <content><![CDATA[<p>每个Unix进程都拥有一个特殊的线性区，这个线性区就是所谓的堆（heap），堆用于满足进程的动态内存请求。内存描述符的start_brk与brk字段分别限定了这个区的开始地址和结束地址。<br><a id="more"></a><br>进程可以使用下面的API来请求和释放动态内存： </p>
<p>malloc（size） </p>
<pre><code>请求<span class="keyword">size</span>个字节的动态内存。如果分配成功，就返回所分配内存单元第一个字节的线性地址。 
</code></pre><p>calloc（n，size） </p>
<pre><code>请求含有n个大小为<span class="keyword">size</span>的元素的一个数组。如果分配成功，就把数组元素初始化为<span class="number">0</span>，并返回第一个元素的线性地址。 
</code></pre><p>realloc（ptr，size） </p>
<pre><code>改变由前面的<span class="function">malloc</span>()或<span class="function">calloc</span>()分配的内存区字段的大小。 
</code></pre><p>free（addr） </p>
<pre><code>释放由<span class="function">malloc</span>()或<span class="function">calloc</span>()分配的起始地址为addr的线性区。 
</code></pre><p>brk(addr) </p>
<pre><code>直接修改堆的大小。<span class="keyword">addr</span>参数指定current-&gt;mm-&gt;brk的新值，返回值是线性区新的结束地址（进程必须检查这个地址和所请求的地址值<span class="keyword">addr</span>是否一致）。  
</code></pre><p>sbrk(incr) </p>
<pre><code>类似于<span class="function">brk</span>()，不过其中的incr参数指定是增加还是减少以字节为单位的堆大小。 
</code></pre><p>brk()函数和以上列出的函数有所不同，因为它是唯一以系统调用的方式实现的函数，而其他所有的函数都是使用brk()和mmap()系统调用实现的C语言库函数。  </p>
<p>当用户态的进程调用brk()系统调用时，内核执行sys_brk(addr)函数。该函数首先验证addr参数是否位干进程代码所在的线性区。如 果 是，则立即返回，因为堆不能与进程代码所在的线性区重叠：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">mm = current-&gt;mm; </div><div class="line"></div><div class="line">down_write(&mm-&gt;mmap_sem); </div><div class="line"></div><div class="line"><span class="keyword">if</span> (addr &lt; mm-&gt;end_code) { </div><div class="line"></div><div class="line">out: </div><div class="line"></div><div class="line">    up_write(&mm-&gt;mmap_sem); </div><div class="line"></div><div class="line">    <span class="keyword">return</span> mm-&gt;brk; </div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>



<p>由于brk()系统调用作用于某一个非代码的线性区，它分配和释放完整的页 。因此，该函数把addr的值调整为PAGE_SIZE的倍数，然后把调整的结果与内存描述符的brk字段的值进行比较： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">newbrk = (addr + <span class="number">0xfff</span>) & <span class="number">0xfffff000</span>; </div><div class="line"></div><div class="line">oldbrk = (mm-&gt;brk + <span class="number">0xfff</span>) & <span class="number">0xfffff000</span>; </div><div class="line"></div><div class="line"><span class="keyword">if</span> (oldbrk == newbrk) { </div><div class="line"></div><div class="line">    mm-&gt;brk = addr; </div><div class="line"></div><div class="line">    <span class="keyword">goto</span> out; </div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>



<p>如果进程请求缩小堆，则sys_brk()调用do_munmap()函数完成这项任务，然后返回： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (addr &lt;= mm-&gt;brk) { </div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!do_munmap(mm, newbrk, oldbrk-newbrk)) </div><div class="line"></div><div class="line">        mm-&gt;brk = addr; </div><div class="line"></div><div class="line">    <span class="keyword">goto</span> out; </div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>



<p>如果进程请求扩大堆，则sys_brk()首先检查是否允许进程这样做。如果进程企图分配在其跟制范围之外的内存，函数并不多分配内存，只简单地返回mm-&gt;brk的原有值： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">rlim = current-&gt;signal-&gt;rlim[RLIMIT_DATA].rlim_cur; </div><div class="line"></div><div class="line"><span class="keyword">if</span> (rlim &lt; RLIM_INFINITY && addr - mm-&gt;start_data &gt; rlim) </div><div class="line"></div><div class="line">    <span class="keyword">goto</span> out;</div></pre></td></tr></table></figure>



<p>然后，函数检查扩大后的堆是否和进程的其他线性区相重叠，如果是，不做任何事情就返回： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (find_vma_intersection(mm, oldbrk, newbrk+PAGE_SIZE)) </div><div class="line"></div><div class="line">    <span class="keyword">goto</span> out;</div></pre></td></tr></table></figure>



<p>如果一切都顺利，则调用do_brk()函数。如果它返回oldbrk,则分配成功且sys_brt()函数返回addr的值；否则，返回旧的mm-&gt;brk值： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (do_brk(oldbrk, newbrk-oldbrk) == oldbrk) </div><div class="line"></div><div class="line">    mm-&gt;brk = addr; </div><div class="line"></div><div class="line"><span class="keyword">goto</span> out;</div></pre></td></tr></table></figure>



<p>do_brk()函数实际上是仅处理匿名线性区的do_mmap()的简化版。可以认为它的调用等价于： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">do_mmap(NULL, oldbrk, newbrk-oldbrk, PROT_READ|PROT_WRITE|PROT_EXEC, </div><div class="line"></div><div class="line">        MAP_FIXED|MAP_PRIVATE, <span class="number">0</span>)</div></pre></td></tr></table></figure>



<p>当然，do_brk()比do_mmap()稍快，因为前者假定线性区不映射磁盘上的文件，从而避免了检查线性区对象的几个字段。 </p>
<p>本文参考《深入理解linux内核》。   </p>
]]></content>
         
         
           
             
              <breadCrumb title="linux" url="http://blog.tinyxd.me/categories/linux/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/08/14/vps-lnmp-setup-and-typecho-blog/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>VPS申请及博客搭建</title>
        <pubTime>2012-08-13T16:33:00.000Z</pubTime>
        
        <tag>vps </tag>
         
        <tag>typecho </tag>
         
         <content><![CDATA[<p>前些天，在网上溜达时，突然看到一款免费的vps。不错。。。免费的。。。哥当时是激动啊，对于像我这样的屌丝，有免费的当然不会放过的。<br>于是乎哥就开始折腾了。<br>一、Vps申请<br>Vps是host1free提供的（128MB,10G,无限流量），申请地址：<a href="http://www.host1free.com/free-vps/" target="_blank" rel="external">http://www.host1free.com/free-vps/</a> ，看网上说，这已经是第三次开放注册了，一共2万个。最好翻墙注册，注册时最好用Gmail邮箱，不要用qq邮箱，然后就是耐心的等待了。建议大家，真心做正规站的来申请，做采集站的（包括采集类影视、小说、淘客及黑客、成人等违反TOS和中美法律内容）绕道吧。这个免费的vps对于想学习vps搭建博客的人实属不易。<br>二、 安装lnmp<br><a id="more"></a><br>参考<a href="http://lnmp.org/install.html" target="_blank" rel="external">LNMP一键安装包</a>，其中会用到putty工具，可以到<a href="http://dl.pconline.com.cn/html_2/1/97/id=3978&amp;pn=0.html" target="_blank" rel="external">这里</a>下载。<br>按照上面的步骤进行操作。需要说明的是   </p>
<ol>
<li>第一条命令<code>screen –S lnmp</code>很重要，当网络突然掉线或者不小心putty被关掉时候，可以用<code>screen –r lnmp</code>看到之前lnmp所进行到的情况。对于没有screen的可以按照<a href="http://www.vpser.net/manage/run-screen-lnmp.html" target="_blank" rel="external">这里</a>进行安装。   </li>
<li>当需要将二级域名绑定到此空间时，我所用的博客工具是typecho，当添加了虚拟主机后，进入后台出现404错误，一般出现这样的情况是nginx设置伪静态的问题，这个情况lnmp已经帮我们解决了。但是，我的仍然出现了404问题，最后把<code>/usr/local/nginx/conf/nginx.conf</code>里面的server_name 和所绑定的域名重名了。只要随便改个名字就好了。<br>三、 安装typecho<br>安装过程，<a href="http://docs.typecho.org/install" target="_blank" rel="external">官方文档</a>已经说的够详细了，这里就不再多说了。<br>四、 数据库的备份问题<br>数据备份，这个始终是个大问题。可以到<a href="http://www.vpser.net/vps-howto" target="_blank" rel="external">这里</a>参考，也可以使用rsync来同步备份。<br>五、关于新建站点<br>至于这个新建的站点，其实想法还没有成熟，只是想分享一些互联网，linux方面的资讯，还有一些搞笑的轻松的话题。地址是：<a href="http://info.tinyxd.me" target="_blank" rel="external">http://info.tinyxd.me</a><br>ps：博客还没有取名，希望大家给点建议。<br><br><br>关于vps，lnmp比较好的文章：<br><a href="http://www.cnblogs.com/amityat/archive/2011/08/23/2150177.html" target="_blank" rel="external">LNMP一键安装升级nginx及php常用设置 SFTP管理指南</a><br><a href="http://www.vpser.net/vps-howto" target="_blank" rel="external">VPS新手指南/教程</a><br><br></li>
</ol>
]]></content>
         
         
           
             
              <breadCrumb title="vps" url="http://blog.tinyxd.me/categories/vps/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/08/23/archlinux-change-mac/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>archlinux修改mac地址</title>
        <pubTime>2012-08-22T16:03:00.000Z</pubTime>
        
        <tag>mac </tag>
         
        <tag>archlinux </tag>
         
        <tag>linux </tag>
         
         <content><![CDATA[<p>快开学了，开学了紧接着就是找工作。由于今年的形势还不太好，所以最近一直在复习一些编程方面的东西，好久没更新文章了。<br>还没到月底，自己的流量都已经用完了，悲催啊！！！借用别人的，这就需要修改mac地址。学校流量3G真的伤不起阿！！！囧<br>查阅Archlinux Wiki可以看到有两种临时改变mac地址的方法：<br>1.使用macchanger或者使用ip命令：    </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">macchanger --mac=XX:XX:XX:XX:XX:XX</div></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ip link <span class="keyword">set</span> dev eth0 down</div><div class="line">ip link <span class="keyword">set</span> dev eth0 address XX:XX:XX:XX:XX:XX</div><div class="line">ip link <span class="keyword">set</span> dev eth0 up</div></pre></td></tr></table></figure>

<p>2.在每次启动时自动修改MAC地址。<br>创建文件<code>/etc/rc.d/functions.d/macspoof</code>     </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">spoof_mac() {</div><div class="line">	ip link set dev eth<span class="number">0</span> address <span class="constant">XX</span><span class="symbol">:XX</span><span class="symbol">:XX</span><span class="symbol">:XX</span><span class="symbol">:XX</span><span class="symbol">:XX</span></div><div class="line">}</div><div class="line"></div><div class="line">add_hook sysinit_end spoof_mac</div></pre></td></tr></table></figure>

<p>具体可参见Archlinux wiki。   </p>
<p>inode上网可参考我以前的一篇文章:<a href="http://blog.tinyxd.me/blog/2012/05/25/archbang-arch-linux-an-zhuang-inode/" target="_blank" rel="external">http://blog.tinyxd.me/blog/2012/05/25/archbang-arch-linux-an-zhuang-inode/</a>   </p>
]]></content>
         
         
           
             
              <breadCrumb title="linux" url="http://blog.tinyxd.me/categories/linux/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/08/25/vps-optimization/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>vps lnmp配置优化</title>
        <pubTime>2012-08-25T15:40:00.000Z</pubTime>
        
        <tag>vps </tag>
         
        <tag>lnmp </tag>
         
         <content><![CDATA[<p>我选用了lnmp（linux + Nginx + PHP + MySQL ）来安装，方便快捷，安装后发现其实好多已经优化好了。<br>其中需要注意到的有以下几个：<br>一. 基于xen架构的可以增加swap分区大小<br>我的vps是openVZ的，swap分区是不能随意更改的。PS.主机商已经提供了128M的swap了。满足了！   </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cd <span class="regexp">/var/</span></div><div class="line">dd <span class="keyword">if</span>=<span class="regexp">/dev/</span>zero of=swapfile bs=<span class="number">1024</span> <span class="keyword">count</span>=<span class="number">262144</span></div><div class="line"><span class="regexp">/sbin/m</span>kswap swapfile</div><div class="line"><span class="regexp">/sbin/</span>swapon swapfile</div></pre></td></tr></table></figure>

<p>然后让自己做的swap分区在系统启动时自动加载：<br>    vi /etc/fstab<br>在适当位置添加以下内容：    </p>
<pre><code>/<span class="keyword">var</span>/swapfile <span class="built_in">swap</span> <span class="built_in">swap</span> defaults <span class="number">0</span> <span class="number">0</span>
</code></pre><p><a id="more"></a><br>二.Nginx主配置文件（nginx.conf）的优化<br>Nginx每个进程耗费10M~12M内存，只开启一个Nginx进程，节省内存。<br>    worker_processes 1;<br>对网页文件、CSS、JS、XML等启动gzip压缩，减少数据传输量，提高访问速度。<br>    gzip on;<br>    gzip_min_length  1k;<br>    gzip_buffers     4 16k;<br>    gzip_http_version 1.0;<br>    gzip_comp_level 2;<br>    gzip_types       text/plain application/x-javascript text/css application/xml;<br>    gzip_vary on;<br>还有：<br>    location ~ .*.(php|php5)?$<br>       {</p>
<pre><code>     <span class="comment">#将Nginx与FastCGI的通信方式由TCP改为Unix Socket。TCP在高并发访问下比Unix Socket稳定，但Unix Socket速度要比TCP快。</span>
     <span class="title">fastcgi_pass</span>  <span class="url">unix:/tmp/php-cgi.sock</span>;
     <span class="comment">#fastcgi_pass  127.0.0.1:9000;</span>
     <span class="title">fastcgi_index</span> index.php;
     <span class="title">include</span> fcgi.conf;
   }

   <span class="title">location</span> <span class="regexp">~ /read.php</span>
   {
     <span class="comment">#将Nginx与FastCGI的通信方式由TCP改为Unix Socket。TCP在高并发访问下比Unix Socket稳定，但Unix Socket速度要比TCP快。</span>
     <span class="title">fastcgi_pass</span>  <span class="url">unix:/tmp/php-cgi.sock</span>;
     <span class="comment">#fastcgi_pass  127.0.0.1:9000;</span>
     <span class="title">fastcgi_index</span> index.php;
     <span class="title">include</span> fcgi.conf;
   }

   <span class="comment">#博客的图片较多，更改较少，将它们在浏览器本地缓存15天，可以提高下次打开我博客的页面加载速度。</span>
   <span class="title">location</span> <span class="regexp">~ .*\.(gif|jpg|jpeg|png|bmp|swf)$</span>
   {
     <span class="title">expires</span>      <span class="number">15d</span>;
   } 

   <span class="comment">#博客会加载很多JavaScript、CSS，将它们在浏览器本地缓存1天，访问者在看完一篇文章或一页后，再看另一篇文件或另一页的内容，无需从服务器再次下载相同的JavaScript、CSS，提高了页面显示速度。</span>
   <span class="title">location</span> <span class="regexp">~ .*\.(js|css)?$</span>
   {
     <span class="title">expires</span>      <span class="number">1d</span>;
   }   
</code></pre><p>其实上面说的lnmp自动安装包已经做好了这些优化！<br>包括后面<a href="http://blog.s135.com/post/375/2/1/" target="_blank" rel="external">这篇文章</a>提到的，lnmp已经配置好了。   </p>
<p><br><br>对于新手的忠告，将配置改好后，记得reload，或者restart。<br>经过优化后的vps，有人做过测试一小时，1000+的pv量都是没有问题的。相同的价格可见买vps还是比较合算的。<br>PS.我的vps现在放了两个站：<a href="http://tinyxd.me/" target="_blank" rel="external">本站</a>、<a href="http://info.tinyxd.me/" target="_blank" rel="external">冰之竹语</a>。后期准备再弄个技术bbs之类的玩玩。<br>对了我还放了个文件管理器<a href="http://encode-explorer.siineiolekala.net/" target="_blank" rel="external">Encode Explorer</a>，专门用来存放上传的图片和文件的。地址在<a href="http://upload.tinyxd.me/" target="_blank" rel="external">这里</a>。其实这一招是从<a href="http://log4d.com/2012/05/image-host/" target="_blank" rel="external">这里</a>学来的。。。<br>我将在我的下一篇<a href="http://tinyxd.me/blog/2012/08/26/imag-file-explorer/" target="_blank" rel="external">文章</a>中详细说明。<br><br></p>
]]></content>
         
         
           
             
              <breadCrumb title="vps" url="http://blog.tinyxd.me/categories/vps/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/08/26/imag-file-explorer/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>图床管理</title>
        <pubTime>2012-08-25T16:08:00.000Z</pubTime>
        
        <tag>vps </tag>
         
        <tag>explorer </tag>
         
         <content><![CDATA[<p>做网站，尤其是做多个网站的，文件的统一管理，备份是很重要的。本站用<a href="http://encode-explorer.siineiolekala.net/" target="_blank" rel="external">Encode Explorer</a>来管理本站图片、上传附件等。<br>去Encode Explorer在sourceforge的<a href="http://sourceforge.net/projects/encode-explorer/files/encode-explorer/" target="_blank" rel="external">项目官网</a>下载程序，其代码不过3k多行。只要将index.php上传到网站根目录，然后把nginx设置好用<a href="http://upload.tinyxd.me/" target="_blank" rel="external">2级域名</a>指向此根目录，就可以了。<br>其中index.php需要改几个地方：<br>1.<code>$_CONFIG[&#39;lang&#39;] = &quot;zh_CN&quot;;</code> 支持中文<br>2.<code>$_CONFIG[&#39;users&#39;] = array(array(&#39;username&#39;, &#39;password&#39;, &#39;admin&#39;));</code>  建立admin用户<br>其中index.php介绍比较详细了。语法格式：array(username, password, status)    status为user可以查看目录但不可以修改，admin能够上传文件和删除文件。<br>3.<code>$_CONFIG[&#39;new_dir_mode&#39;] = 0755;</code><br><code>$_CONFIG[&#39;upload_file_mode&#39;] = 0644;</code><br>修改新建文件夹和上传文件的默认权限。<br>这就是最终完成的，用二级域名（只要将该域名dns解析到vps服务器地址就可以了）<a href="http://upload.tinyxd.me/" target="_blank" rel="external">http://upload.tinyxd.me/</a>来上传/浏览/删除文件。<br>本文参考了<a href="http://log4d.com/" target="_blank" rel="external">log4d</a>的<a href="http://log4d.com/2012/05/image-host/" target="_blank" rel="external">使用独立图床子域名</a>。<br><br></p>
]]></content>
         
         
           
             
              <breadCrumb title="vps" url="http://blog.tinyxd.me/categories/vps/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/08/27/use-dropbox-backup-vps-and-database/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>用Dropbox备份VPS网站及数据库 </title>
        <pubTime>2012-08-27T15:28:00.000Z</pubTime>
        
        <tag>vps </tag>
         
        <tag>dropbox </tag>
         
         <content><![CDATA[<p>用SSH客户端（PuTTY）登陆，进入root目录：<br>    cd ~<br>linux下用ssh登录：<br>    ssh (ip) -l (用户名) -p (端口号)<br>    或者<br>    ssh username@ip<br>    或者<br>    ssh username@domain<br>下载dropbox程序：<br>32位版本：<br>    wget -O dropbox.tar.gz <a href="http://www.dropbox.com/download/?plat=lnx.x86" target="_blank" rel="external">http://www.dropbox.com/download/?plat=lnx.x86</a><br>64位版本：<br>    wget -O - “<a href="https://www.dropbox.com/download?plat=lnx.x86_64" target="_blank" rel="external">https://www.dropbox.com/download?plat=lnx.x86_64</a><br><a id="more"></a><br>解压缩：<br>        tar -zxof dropbox.tar.gz<br>然后第一次运行dropbox：<br>        ~/.dropbox-dist/dropboxd &amp;<br>运行后会出现一串URL地址，把这个复制到流量器上，跟你的dropbox账户进行绑定。<br>绑定好之后就可以开始同步了。<br>首先进入dropbox，<br>       cd ~/Dropbox<br>备份整个wwwroot目录，建立一个软连接：<br>        ln -s /home/wwwroot<br>由于dropbox耗费的内存确实够大，建议不要开太长时间<br><img src="http://upload.tinyxd.me/2012/08/dropboxload.jpg" alt="dropboxload" width="778" height="200"><br>如果上面操作没有错误的话，在dropbox就可以看到同步的文件了。<br>附别人写的一个脚本：</p>
<figure class="highlight bash"><figcaption><span>dropboxbak.sh </span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="shebang">#!/bin/sh</span></div><div class="line"> BACKUP_SRC=<span class="string">"/root/Dropbox"</span>  <span class="comment">#用于同步的本地目录</span></div><div class="line"> BACKUP_WWW=<span class="string">"/home/wwwroot"</span>     <span class="comment">#你的网站目录</span></div><div class="line"> NOW=$(date +<span class="string">"%Y.%m.%d"</span>)</div><div class="line"> MYSQL_SERVER=<span class="string">"127.0.0.1"</span></div><div class="line"> MYSQL_USER=<span class="string">"user"</span></div><div class="line"> MYSQL_PASS=<span class="string">"password"</span></div><div class="line"> DAY=$(date +<span class="string">"%u"</span>)             <span class="comment">#取当前星期，1表示周一</span></div><div class="line"> <span class="function"><span class="title">start</span></span>() {</div><div class="line"><span class="built_in">echo</span> starting bak SQL</div><div class="line"> <span class="comment">#dump数据库数据，以及备份网站整站文件</span></div><div class="line"> mysqldump -u <span class="variable">$MYSQL_USER</span> -h <span class="variable">$MYSQL_SERVER</span> -p<span class="variable">$MYSQL_PASS</span> 需要备份的数据库名称 &gt; <span class="string">"<span class="variable">$BACKUP_SRC</span>/<span class="variable">$NOW</span>-Databases.sql"</span></div><div class="line"> <span class="built_in">echo</span> starting dropbox</div><div class="line"> /root/.dropbox-dist/dropboxd &</div><div class="line"> }</div><div class="line"> <span class="function"><span class="title">stop</span></span>() {</div><div class="line"> <span class="built_in">echo</span> stoping dropbox</div><div class="line"> pkill dropbox</div><div class="line"> }</div><div class="line"> <span class="keyword">case</span> <span class="string">"<span class="variable">$1</span>"</span> <span class="keyword">in</span></div><div class="line"> start)</div><div class="line"> start</div><div class="line"> ;;</div><div class="line"> stop)</div><div class="line"> stop</div><div class="line"> ;;</div><div class="line"> <span class="keyword">esac</span></div></pre></td></tr></table></figure>

<p>将脚本放到~/.dropbox下，修改脚本权限：<br>            chmod 755 ~/.dropbox/dropboxbak.sh<br>添加计划任务：<br>            crontab –e<br>添加两条内容：<br>                0   3 <em> </em> * sh /root/.dropbox/dropboxbak.sh start</p>
<pre><code>            <span class="number">30</span> <span class="number">3</span> * * * <span class="keyword">sh</span> /root/.dropbox/dropboxbak.<span class="keyword">sh</span> <span class="keyword">stop</span>
</code></pre><p>具体参数参照文档。<br>删除dropbox的方法：   </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># sh /root/.dropbox/dropboxbak.sh stop</span></div><div class="line"><span class="comment"># su - root</span></div><div class="line"><span class="comment"># cd</span></div><div class="line"><span class="comment"># rm -rf .dropbox .dropbox-dist  Dropbox dropbox.tar.gz dbmakefakelib.py dbreadconfig.py</span></div></pre></td></tr></table></figure>


<p>更多内容请参考相关网站。<br><br></p>
]]></content>
         
         
           
             
              <breadCrumb title="vps" url="http://blog.tinyxd.me/categories/vps/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/08/30/debian-ubuntu-setup-openvpn/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>VPS安装openVPN</title>
        <pubTime>2012-08-30T04:24:00.000Z</pubTime>
        
        <tag>vps </tag>
         
        <tag>vpn </tag>
         
         <content><![CDATA[<p>首先，你得有VPS或者独立服务器。<br>因为我的VPS是openVZ的，查资料发现新的openVZ的VPS是支持PPTP的。不过鉴于安全性的考虑我还是使用openVPN。<br>本文后面会介绍在debian 6下面安装openvpn的一些注意事项以及在xp下面安装openVPN。   </p>
<h2 id="使用一键安装包来安装openVPN_">使用一键安装包来安装openVPN   </h2>
<p>1.检查你的VPS是否支持Tun/Tap/nat/ppp，登录VPS检查<br>    cat /dev/net/tun<br>如果返回 <code>cat: /dev/net/tun: File descriptor in bad state</code> 说明tun是可用的。<br>    iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -o venet0 -j MASQUERADE<br>如果返回<code>iptables: No chain/target/match by that name</code>说明nat也是可以用的。<br><a id="more"></a><br>如果返回结果不是以上描述的，那么说明你的VPS服务商默认没有开通。你可以发ticket要求VPS提供商提供这个，我的VPS就没有提供这个，就发了ticket，不过很快就解决了。<br>2.检查服务器的DNS<br>    vi /etc/resolv.conf<br>可以使用<br>OpenDNS提供的DNS服务器地址<br>　　208.67.222.222<br>　　208.67.220.220<br>Google提供的DNS服务<br>    8.8.8.8<br>    8.8.4.4<br>3.下载John Malkowski的Debian OpenVPN脚本。<br>    wget <a href="http://vpsnoc.com/scripts/debian-openvpn.sh" target="_blank" rel="external">http://vpsnoc.com/scripts/debian-openvpn.sh</a><br>    chmod +x debian-openvpn.sh<br>    ./debian-openvpn.sh<br>连续填写server和client的信息，出现y/n的时候都选择y。<br>然后把生成的<code>keys.tgz</code>下载自本地。   </p>
<h2 id="不使用一键安装包，一步步自己安装">不使用一键安装包，一步步自己安装</h2>
<p>以下内容参考了：<a href="http://www.vpser.net/build/linode-install-openvpn.html" target="_blank" rel="external">VPS侦探 Linode VPS OpenVPN安装配置教程(基于Debian/Ubuntu)</a><br>1.安装<br>    apt-get install openvpn udev lzop<br>2.OpenVPN提供了”easy-rsa”这套加密方面的工具openvpn安装好之后easy-rsa在/usr/share/doc/openvpn/examples/easy-rsa/文件夹中为了使OpenVPN正常工作需要把easy-rsa复制到/etc/openvpn中.运行下列命令:     </p>
<pre><code>#cp -R <span class="regexp">/usr/</span>share<span class="regexp">/doc/</span>openvpn<span class="regexp">/examples/</span>easy-rsa<span class="regexp">/ /</span>etc<span class="regexp">/openvpn</span>
</code></pre><p>在<code>/etc/openvpn/easy-rsa/2.0/</code>中设置，基本所有的OpenVPN配置都在这。<br>生产CA证书：   </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">cd</span> /etc/openvpn/easy-rsa/<span class="number">2.0</span></div><div class="line"><span class="keyword">source</span> vars</div><div class="line">./clean-<span class="keyword">all</span></div><div class="line">./build-<span class="keyword">ca</span></div></pre></td></tr></table></figure>

<p><code>./build-ca</code>时会提示输入一些信息，可以都直接回车按默认信息。<br>3.生成服务器端证书和密钥：<br>    ./build-key-server server<br>有两次需要输入y。<br>4.生产客户端证书和密钥：<br>    ./build-key client<br>生成的证书和密钥在<code>/etc/openvpn/easy-rsa/2.0/keys/</code>下面。<br>5.生成Diffie Hellman参数：<br>    ./build-dh<br>6.安装配置openVPN客户端    详情见参考。   </p>
<h2 id="windows客户端下载">windows客户端下载</h2>
<p>1.下载OpenVPN：<a href="http://www.openvpn.net/index.php/open-source/downloads.html" target="_blank" rel="external">http://www.openvpn.net/index.php/open-source/downloads.html</a>下载最新版本安装包。<br>2.安装，建议win7/vista用户安装到非系统分区。<br>3.修改虚拟网卡DNS，Google DNS :8.8.8.8和 8.8.4.4；OpenDNS的208.67.222.222 和208.67.220.220。<br>4.将keys.tgz解压至openVPN安装目录下的config目录。<br>5.运行openVPN。<br>6.如果没有什么差错的话至此安装成功。<br>可以进<a href="http://www.dnsstuff.com" target="_blank" rel="external">http://www.dnsstuff.com</a> 或者facebook/twitter等测试下。惊喜等着你哦！<br>如果需要和你的朋友分享这个，可以新建个用户，重新生成客户端证书。   </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /etc/openvpn/easy-rsa/<span class="number">2.0</span></div><div class="line"> ./vars</div><div class="line">./build-key user1</div></pre></td></tr></table></figure>

<p>将新生成的user1.crt,user1.key,user1.csr三个文件和<em>.ovpn和ca.crt、ca.key三个文件一起下载到本地，编辑下载下来的`</em>.ovpn<code>文件将其中的</code>cert client1.crt<code>和</code>key client1.key<code>修改为：</code>cert user1.crt<code>和</code>key user1.key`。<br>把以上文件，打包发送给你的朋友。并将其解压到config目录下。<br><br></p>
]]></content>
         
         
           
             
              <breadCrumb title="vps" url="http://blog.tinyxd.me/categories/vps/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/09/02/nginx-ssl/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>个人网站上安装SSL证书</title>
        <pubTime>2012-09-02T14:45:00.000Z</pubTime>
        
        <tag>vps </tag>
         
        <tag>nginx </tag>
         
        <tag>ssl </tag>
         
         <content><![CDATA[<p>SSL(Secure Sockets Layer 安全套接层),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密。<br>HTTPS（Secure Hypertext Transfer Protocol）安全超文本传输协议，HTTPS应用了Netscape的完全套接字层（SSL）作为HTTP应用层的子层。（HTTPS使用端口443，而不是象HTTP那样使用端口80来和TCP/IP进行通信。）<br>建个网站不容易，各种都要收费，那么有免费的当然就更好了！免费的SSL证书：<a href="https://www.startssl.com/" target="_blank" rel="external">StartSSL</a>来了！<br>1.进入StartSSL<a href="https://www.startssl.com/" target="_blank" rel="external">官网</a>，点击左上角<code>Sign-up For Free</code>（这个很容易找，就不截图了<code>^_^</code>）。按要求填写注册信息，<code>First, Last Name</code>这一栏填写自己的中文名字的拼音，地址精确到房间号或者街道号（要不然客服发来邮件会索要地址的）。<br>2.注册成功后，StartSSL会发送一个链接给你，还有验证码。因为StartSSL使用证书验证的，所以，要把验证证书好好保管好，丢了就没法登陆了。<br>3.进入<code>Control Panel</code>之后，点击<code>Validations Wizard</code>，域名验证<code>Domain Name Validation</code>,填入你需要添加SSL的域名，还有你的个人邮箱（会给你发封邮件，里面有验证码，注意接收）。<br>4.验证完域名后，点击<code>Certificates Wizard</code>—<code>Web Server SSL/TLS Certificate</code>。<br><a id="more"></a><br><strong>生成私钥（Generate Private Key）</strong><br>如果你已经在VPS上生成了私钥，这一步可以跳过，没有的话，可以在这里生成，填入私钥的密码，将文本框中的内容复制，保存为<code>ssl.key</code>。<br><strong>生成证书</strong><br>选择你需要绑定的二级域名，比如<code>www.tinyxd.me</code>,<code>Tool Box</code>—<code>Retrieve Certificate</code>,同样将文本框中的内容复制另存为<code>ssl.crt</code>。<br><strong>登录VPS，生成服务器密钥/证书</strong><br>生成<code>server.key</code><br>    openssl rsa -in ssl.key -out server.key<br>生成<code>server.crt</code>    </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cp ssl.crt server.crt</div><div class="line">wget http://cert.startssl.com/certs/ca.pem</div><div class="line">wget http://cert.startssl.com/certs/sub.class1.server.ca.pem</div><div class="line">cat ca.pem sub.class1.server.ca.pem &gt;&gt; ca-certs.crt</div><div class="line">cat ca-certs.crt &gt;&gt; server.crt</div></pre></td></tr></table></figure>

<p><strong>修改nginx配置文件</strong><br>将<code>server.key</code>和<code>server.crt</code>放到<code>/usr/local/nginx/certs/</code>目录下，修改<code>/usr/local/nginx/conf/vhost/</code>对应域名虚拟机的配置文件，添加如下内容：   </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="title">server</span> {</div><div class="line"><span class="title">listen</span> <span class="number">80</span>;</div><div class="line"><span class="title">server_name</span> www.域名.com;</div><div class="line"><span class="title">rewrite</span><span class="regexp"> ^(.*)</span> <span class="url">https://$server_name$1</span> <span class="built_in">permanent</span>;</div><div class="line">}</div><div class="line"><span class="title">server</span> {</div><div class="line"><span class="title">listen</span> <span class="number">443</span>;</div><div class="line"><span class="title">server_name</span> www.域名.com;</div><div class="line"><span class="title">root</span> /home/www;</div><div class="line"><span class="title">ssl</span> <span class="built_in">on</span>;</div><div class="line"><span class="title">ssl_certificate</span> /usr/local/nginx/certs/server.crt;</div><div class="line"><span class="title">ssl_certificate_key</span> /usr/local/nginx/certs/server.key;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面脚本的<code>rewrite ^(.*) https://$server_name$1 permanent;</code>如果不填加的话，你的网站将可以进行http和https的两种访问。<br>最后重启Nginx，<code>/usr/local/nginx restart</code> 。访问你的网站，看是不是支持https访问了！<br>本文参考：<a href="http://ichon.me/2012/5/29/nginx-ssl.html" target="_blank" rel="external">http://ichon.me/2012/5/29/nginx-ssl.html</a>和<a href="http://baike.baidu.com/view/16147.htm" target="_blank" rel="external">http://baike.baidu.com/view/16147.htm</a><br><br></p>
]]></content>
         
         
           
             
              <breadCrumb title="vps" url="http://blog.tinyxd.me/categories/vps/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/09/10/job-hunting-2012/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>开始找工作了</title>
        <pubTime>2012-09-09T16:24:00.000Z</pubTime>
        
        <tag>job </tag>
         
         <content><![CDATA[<p>今天，航天二院专场招聘，正式拉开了招聘的序幕。人好多！<br><img src="http://upload.tinyxd.me/2012/09/job.JPG" alt="Job Hunting" width="970" height="660">   </p>
]]></content>
         
         
           
             
              <breadCrumb title="essay" url="http://blog.tinyxd.me/categories/essay/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2013/01/02/the-blog-stated/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>新的一年</title>
        <pubTime>2013-01-02T04:22:00.000Z</pubTime>
        
        <tag>job </tag>
         
         <content><![CDATA[<p>好久没有写博客了，上篇博客是找工作之前，现在工作已经尘埃落定了。工作找完后，就开始忙着写论文，考驾照。<br>回首2012，感觉运气不佳，希望2013年能够运气好好。<br>2013愿望List：<br>1.手机（至于买什么还没有想好）<br>2.笔记本（Acer用了5年了。。。该换了，不出意外的话应该是Thinkpad）<br>3.单反<br>4.旅行（身体和灵魂.总有一个要在路上）<br>5.结束单身（这个感觉好难啊，Anyway还是列出来吧）<br>最后，说一句，关于本博客的主题，得到大家的肯定，我非常高兴，博友可以修改后发布，源码在我的github项目：<code>https://github.com/tinyxd/tinyxd.github.com</code>。如果有需要可以发Email（admin#tinyxd.me）交流。<br>本站所有作品采用知识共享署名-非商业性使用-相同方式共享 2.5 中国大陆许可协议进行许可。<br>附上最近很火的航母style，希望自己的工作能一飞冲天：   </p>
<img src="http://upload.tinyxd.me/2013/01/2013style.gif" title="[2013style [2013style]]">
]]></content>
         
         
           
             
              <breadCrumb title="essay" url="http://blog.tinyxd.me/categories/essay/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2013/01/16/add-article-info-footer/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>文章末尾自动添加本文地址</title>
        <pubTime>2013-01-16T05:23:00.000Z</pubTime>
        
        <tag>octopress </tag>
         
         <content><![CDATA[<p>为每篇post添加本文地址和keywords信息。<br>Ruby脚本如下，添加到plugins文件夹中。    </p>
<p><script src="https://gist.github.com/4545472.js?file=post_footer_filter.rb"></script><br>本人已将插件上传到<a href="https://github.com/tinyxd/post_footer。" target="_blank" rel="external">https://github.com/tinyxd/post_footer。</a><br><a id="more"></a><br>在_config.yml中添加origional_url_pre，本文配置为”本站文章如果没有特别说明，均为原创，转载请以链接方式注明本文地址：”。   </p>
<p>本文参考：<code>http://codemacro.com/2012/07/26/post-footer-plugin-for-octopress/</code>。 </p>
]]></content>
         
         
           
             
              <breadCrumb title="octopress" url="http://blog.tinyxd.me/categories/octopress/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2013/01/17/vim-config/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>vim的一些配置</title>
        <pubTime>2013-01-17T09:44:00.000Z</pubTime>
        
        <tag>vim </tag>
         
        <tag>linux </tag>
         
         <content><![CDATA[<p>一直很想系统的学习vim，因为各种原因把，一直把这个计划搁置到了现在，现在凑着学习vimwiki，再次把这个提上日程。<br>vim配置：<br>使用了<a href="https://github.com/vingel/vim/blob/master/vimrc" target="_blank" rel="external">vingel</a>的配置文件。<br>由于我还要学习vimwiki，所以添加了vimwiki的一些配置。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">"</span></div><div class="line">"vimwiki设置</div><div class="line"><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">"</span></div><div class="line">" 打开语法高亮</div><div class="line"><span class="string">"syntax enable</span></div><div class="line">syntax on</div><div class="line"></div><div class="line">" 打开对文件类型插件的支持</div><div class="line">filetype indent on</div><div class="line">filetype plugin on</div><div class="line"><span class="string">"filetype plugin indent on</span></div><div class="line"></div><div class="line">" <span class="comment">######### VimWiki 写作助手 ######### "</span></div><div class="line"></div><div class="line"><span class="string">" 使用鼠标映射</span></div><div class="line">let g:vimwiki_use_mouse = 1</div><div class="line"></div><div class="line">" 不要将驼峰式词组作为 Wiki 词条</div><div class="line"><span class="built_in">let</span> g:vimwiki_camel_<span class="keyword">case</span> = <span class="number">0</span></div><div class="line"></div><div class="line"><span class="built_in">let</span> g:vimwiki_list = [{</div><div class="line">\ <span class="string">'path'</span>: <span class="string">'/media/software/Dropbox/my_vimwiki_site/wiki'</span>,</div><div class="line">\ <span class="string">'path_html'</span>: <span class="string">'/media/software/Dropbox/my_vimwiki_site/html/'</span>,</div><div class="line"> \<span class="string">'template_path'</span> : <span class="string">'d:/vimwiki/template/'</span>,</div><div class="line">            \<span class="string">'template_default'</span> : <span class="string">'default_template'</span>,</div><div class="line">            \<span class="string">'template_ext'</span> : <span class="string">'.html'</span>,</div><div class="line">\ <span class="string">'auto_export'</span>: <span class="number">1</span>,}]</div></pre></td></tr></table></figure>

]]></content>
         
         
           
             
              <breadCrumb title="linux" url="http://blog.tinyxd.me/categories/linux/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2013/01/23/github-hosts/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>恢复访问Github</title>
        <pubTime>2013-01-23T02:55:00.000Z</pubTime>
        
        <tag>hosts </tag>
         
        <tag>git </tag>
         
         <content><![CDATA[<p>12306订票助手拖慢Github，最近Github被屏蔽。具体是不是这个原因导致被屏蔽还不得而知。因为使用DNS污染来屏蔽Github，所以可以通过修改Hosts来解决这一问题。<br>因为本博客源码，还有一些非常优秀的开源项目在Github上，不得以才出此下策。<br>windows下修改<code>C:\WINDOWS\system32\drivers\etc</code>，Archlinux下修改<code>/etc/hosts</code> ,在其中添加：    </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="number">207.97</span>.<span class="number">227.239</span> github.<span class="keyword">com</span> </div><div class="line"><span class="number">65.74</span>.<span class="number">177.129</span> www.github.<span class="keyword">com</span> </div><div class="line"><span class="number">207.97</span>.<span class="number">227.252</span> nodeload.github.<span class="keyword">com</span> </div><div class="line"><span class="number">207.97</span>.<span class="number">227.243</span> raw.github.<span class="keyword">com</span> </div><div class="line"><span class="number">204.232</span>.<span class="number">175.78</span> documentcloud.github.<span class="keyword">com</span> </div><div class="line"><span class="number">204.232</span>.<span class="number">175.78</span> pages.github.<span class="keyword">com</span></div></pre></td></tr></table></figure>


<p>希望此次事件能够尽快过去。<br>小贴士：<br>Github—-全球最大的社交编程及代码托管网站。    </p>
]]></content>
         
         
           
             
              <breadCrumb title="git" url="http://blog.tinyxd.me/categories/git/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2013/09/09/update-now/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>终于可以更新博客啦</title>
        <pubTime>2013-09-09T15:28:00.000Z</pubTime>
        
         <content><![CDATA[<p>之前一直因为电信的光猫还需要拨号，Linux上不了网，所以一直没有更新博客。最近终于有时间把光猫设置了下，支持自动拨号了，现在终于可以更新博客了。筒子们，我来了！</p>
]]></content>
         
         
           
             
              <breadCrumb title="essay" url="http://blog.tinyxd.me/categories/essay/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2013/09/20/ios-7-hide-app/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>IOS 7隐藏APP或者文件夹</title>
        <pubTime>2013-09-20T05:11:00.000Z</pubTime>
        
         <content><![CDATA[<p>老罗的锤子rom有个奇葩的功能隐藏APP，现在IOS7也有这个功能了，不知道是bug还是新功能。<br>操作步骤：<br>1.拖动任意一个文件夹到主屏幕，然后确保主屏幕为满屏状态。   </p>
<p>2.按住刚文件夹或者文件夹中的APP，并迅速双击Home按钮，这时iOS会弹出多任务管理选择窗口，这时你需要点击第一个页面返回到主屏幕，这是你会发现你想隐藏的应用颜色已经便暗。    </p>
<p>3.打开你刚才在第一步拖到主屏幕上的文件夹，然后按下HOME，想要隐藏的应用或者文件夹已经消失了。    </p>
<p>注意：如果需要重新显示被隐藏的文件夹或者应用，你需要重新启动系统。    </p>
<p>参考：<a href="http://www.cnbeta.com/articles/253387.htm" target="_blank" rel="external">http://www.cnbeta.com/articles/253387.htm</a></p>
]]></content>
         
         
           
             
              <breadCrumb title="ios" url="http://blog.tinyxd.me/categories/ios/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/05/23/octopresstian-jia-tu-pian/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>Octopress添加图片</title>
        <pubTime>2012-05-23T12:49:00.000Z</pubTime>
        
        <tag>octopress </tag>
         
         <content><![CDATA[<p>If you like Markdown’s syntax for images, you’ll love the simplicity of the Octopress image tag.</p>
<p>Syntax</p>
<blockquote>
<p>img [class names] /path/to/image [width] [height] [title text [alt text]]</p>
</blockquote>
<p>Don’t forget brace and percent couple.</p>
<a id="more"></a>

<p>Examples</p>
<blockquote>
<p>img <a href="http://placekitten.com/890/280" target="_blank" rel="external">http://placekitten.com/890/280</a><br>img left <a href="http://placekitten.com/320/250" target="_blank" rel="external">http://placekitten.com/320/250</a> Place Kitten #2<br>img right <a href="http://placekitten.com/300/500" target="_blank" rel="external">http://placekitten.com/300/500</a> 150 250 Place Kitten #3<br>img right <a href="http://placekitten.com/300/500" target="_blank" rel="external">http://placekitten.com/300/500</a> 150 250 ‘Place Kitten #4’ ‘An image of a very cute kitten’    </p>
</blockquote>
]]></content>
         
         
           
             
              <breadCrumb title="octopress" url="http://blog.tinyxd.me/categories/octopress/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/05/23/wei-yi-jing-cun-zai-de-github-octopresspei-zhi-ben-di-huan-jing/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>为已经存在的github Octopress配置本地环境</title>
        <pubTime>2012-05-23T12:59:00.000Z</pubTime>
        
        <tag>github </tag>
         
        <tag>octopress </tag>
         
         <content><![CDATA[<p><strong>转自：</strong><br><a href="http://www.360doc.com/content/12/0520/19/3565338_212362686.shtml" target="_blank" rel="external">http://www.360doc.com/content/12/0520/19/3565338_212362686.shtml</a>  </p>
<p>本文介绍如何为已经存在于github上的octopress配置本地环境。<br>在本地安装RVM(Ruby Version Manager)和Ruby 1.9.2；  </p>
<p>从你的github得到你的octopress内容：      </p>
<pre><code>git clone -b <span class="keyword">source</span> git<span class="variable">@github</span>.com:username/username.github.com.git octopress # get the <span class="keyword">source</span> code from your <span class="string">"source"</span> branch of your octopress on github
＃ learn from: http:<span class="comment">//stackoverflow.com/questions/1911109/git-clone-a-specific-branch</span>
cd octopress
git clone git<span class="variable">@github</span>.com:username/username.github.com.git _deploy # get your static pages content from your <span class="string">"master"</span>branch of your cotopress on github
</code></pre><p><a id="more"></a><br>安装依赖gems: </p>
<pre><code>gem <span class="keyword">install</span> bundler <span class="comment"># Install dependencies   </span>
bundle <span class="keyword">install</span>   <span class="comment">#如果出现bundle命令没找到，还需要修改～/.bashrc</span>
vim ~/.bashrc
<span class="comment">#for ruby gem</span>
PATH=$PATH:~/.gem/ruby/<span class="number">1.9</span>.<span class="number">1</span>/bin
<span class="keyword">export</span> PATH
rake <span class="keyword">install</span> <span class="comment"># Install the default Octopress theme  不需要 因为我已经有了自己的主题   </span>
rake setup_github_pages <span class="comment">#需要这个 要不然rake deploy会出错   </span>
</code></pre><p>这就基本结束了。</p>
<p>编写文章，预览部署：  </p>
<pre><code><span class="keyword">cd</span> octopress
rake new_post[<span class="string">"Your Title of Your Article"</span>]
rake generate # generate your blog static pages content according <span class="keyword">to</span> your <span class="built_in">input</span>. 
rake preview # start <span class="keyword">a</span> web server <span class="keyword">on</span> <span class="string">"http://localhost:4000"</span>, you can preview your blog content.
rake deploy # push your static pages content <span class="keyword">to</span> your github pages repo (<span class="string">"master"</span> branch)
</code></pre><p>提交你的文本修改到github:       </p>
<pre><code><span class="keyword">cd</span> your_local_octopress_directory
git <span class="built_in">add</span> .
git commit -<span class="keyword">m</span> <span class="string">'your message'</span>
git push origin <span class="keyword">source</span>
</code></pre><p>注意：如果要从github得到最新的source内容，请运行以下命令：   </p>
<pre><code><span class="built_in">cd</span> your_local_octopress_directory
<span class="built_in">cd</span> _deploy
git pull origin master
<span class="built_in">cd</span> ..
git pull origin <span class="built_in">source</span>
</code></pre><p>原则很简单，只要记住“your_local_octopress_directory”对应的的remote source branch，而”_deploy”对应的是remote master branch即可。</p>
]]></content>
         
         
           
             
              <breadCrumb title="octopress" url="http://blog.tinyxd.me/categories/octopress/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/05/25/archbang-arch-linux-an-zhuang-inode/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>archbang arch linux 安装inode </title>
        <pubTime>2012-05-25T06:34:00.000Z</pubTime>
        
        <tag>linux </tag>
         
        <tag>archlinux </tag>
         
        <tag>archbang </tag>
         
        <tag>inode </tag>
         
         <content><![CDATA[<p>第一步：cp iNodeClient.tar.gz 到 /home/***** 目录下。进入~目录下<br>第二步：终端运行 tar -xvf iNodeClient.tar.gz。<br>第三步：修改/home//iNodeClient/下install.sh，把 OS_UBUNTU=`cat /etc/issue | grep ‘Ubuntu’`那一行及以下的脚本都删除，然后保存，执行sudo ./install.sh。<br>第四步：cp  home/*****/iNodeClient/ 目录下的iNodeAuthService到/etc/rc.d/目录下，并修改权限chmod 755 /etc/rc.d/iNodeAuthService。<br>第五步：打开/etc/rc.conf ，在DAEMONS处添加@iNodeAuthService。（让iNode认证服务开机自启动）<br>第六步：现在执行sudo /etc/rc.d/iNodeAuthService start，发现出错了。错误出现在enablecards.ps这个文件里，打开看，你会发现这个文件的作用只是用来up网卡。一般来说你的网卡都已经up了的啦。你可以把里面的内容改成：<br>#!/bin/sh<br>x=eth0（你所使用的网卡）<br>ifconfig $x up<br>再运行一次sudo /etc/rc.d/iNodeAuthService start，你应该会发现服务启动成功了。<br>第七步：命令行里面执行一下sudo ./iNodeClient 然后楼主发现出现了一些库的依赖问题。iNode需要一些比较旧的库，对于jpeg tiff等库 你可以用ln -s 来用新版本的库代替旧版本。而其中有一个是libpng12.so.0是必须需要旧版本的。见附件 或者可以去官网自己下载ftp://ftp.simplesystems.org/pub/libpng/png/src/<br>需要下载的文件是libpng-1.2.49.tar.bz2<br>安装方法如下：<br>1.解压，然后执行./configure —prefix=/usr/<br>2.编译及安装<br>#make<br>#make install<br>安装之前可以make check 以下 看看有没有什么错误，如果没错误 make install 那么libpng就安装好了。   </p>
<p>参考：<a href="http://ecnc.sysu.edu.cn/viewthread.php?tid=18558" target="_blank" rel="external">http://ecnc.sysu.edu.cn/viewthread.php?tid=18558</a></p>
]]></content>
         
         
           
             
              <breadCrumb title="linux" url="http://blog.tinyxd.me/categories/linux/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/05/26/arch-linux-xia-lxrde-an-zhuang/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>arch linux 下lxr的安装</title>
        <pubTime>2012-05-26T15:14:00.000Z</pubTime>
        
        <tag>linux </tag>
         
        <tag>archlinux </tag>
         
        <tag>lxr </tag>
         
         <content><![CDATA[<p>经过自己两天的折腾，参考了好几个资料终于搞定。<br>参考资料见文章末尾。<br>LXR是使用WEB方式下的源代码整理浏览工具，最大的用途在于清理出了代码中函数、变量的定义、说明、应用的关系，并用链接的形式表现在网页上。LXR整理出代码的结构和调用关系，存在数据库中，并在显示时与源代码树结合，从功能上说，包括代码浏览、标识符搜索、文本搜索和文件搜索，其中的文本搜索和文件搜索利用的是第三方工具（即glimpse或swish-e）（我使用的glimpse）。它的主要组成部分包括三个：Perl编写的网页/CGI部分，基于MySQL的索引数据管理（新版本才有）和通用的文本搜索工具。目前的版本，采用Glimpse或者Swish-e中的一种作为通用文本搜索工具。在安装上，基本上也按照这三个部分来配置。    </p>
<p>1.下载安装所需的工具。<br>a。glimpse（<a href="http://webglimpse.net/download.php）" target="_blank" rel="external">http://webglimpse.net/download.php）</a></p>
<p>安装glimpse:（其中会用到flex 安装下就行了）</p>
<pre><code><span class="variable">$ </span>./configure

<span class="variable">$ </span>make

<span class="variable">$ </span>sudo make install
</code></pre><p>b。pacman -S apache php php-apache mysql</p>
<p>c。pacman -s ctags perl-dbi perl-dbd-mysql</p>
<p>d。安装完mysql 以root用户身份运行设置脚本</p>
<pre><code><span class="preprocessor"># rc.d start mysqld &amp;&amp; mysql_secure_installation</span>
</code></pre><p>然后重启 Mysql</p>
<pre><code><span class="preprocessor"># rc.d restart mysqld</span>
</code></pre><p>本文需要设置密码为空（后面有说明）<br><a id="more"></a><br>用mysql -p -u root</p>
<p>登陆mysql,然后执行下面语句: set password for ‘root’@’localhost’ =password(‘’);flush privileges;e.安装Perl的Magic模块</p>
<p>下载地址<a href="http://search.cpan.org/~knok/File-MMagic-1.27/MMagic.pm" target="_blank" rel="external">http://search.cpan.org/~knok/File-MMagic-1.27/MMagic.pm</a></p>
<pre><code>[root@localhost <span class="keyword">File</span>-MMagic-<span class="number">1.27</span>]# ls ChangeLog COPYING      MANIFEST MMagic.pm README.ja contrib    Makefile.PL META.yml README.en t [root@localhost <span class="keyword">File</span>-MMagic-<span class="number">1.27</span>]# perl Makefile.PL Checking <span class="keyword">if</span> your kit <span class="keyword">is</span> complete... Looks good Writing Makefile <span class="keyword">for</span> <span class="keyword">File</span>::MMagic [root@localhost <span class="keyword">File</span>-MMagic-<span class="number">1.27</span>]# ls
ChangeLog COPYING   Makefile.PL META.yml   README.en t
contrib    Makefile MANIFEST     MMagic.pm README.ja

[root@localhost <span class="keyword">File</span>-MMagic-<span class="number">1.27</span>]# make
cp MMagic.pm blib/lib/<span class="keyword">File</span>/MMagic.pm
Manifying blib/man3/<span class="keyword">File</span>::MMagic<span class="number">.3</span>pm
[root@localhost <span class="keyword">File</span>-MMagic-<span class="number">1.27</span>]# make install
Installing /usr/lib/perl5/site_perl/<span class="number">5.8</span><span class="number">.8</span>/<span class="keyword">File</span>/MMagic.pm
Installing /usr/share/man/man3/<span class="keyword">File</span>::MMagic<span class="number">.3</span>pm Writing /usr/lib/perl5/site_perl/<span class="number">5.8</span><span class="number">.8</span>/i386-linux-thread-multi/auto/<span class="keyword">File</span>/MMagic/.packlist Appending installation info <span class="keyword">to</span> /usr/lib/perl5/<span class="number">5.8</span><span class="number">.8</span>/i386-linux-thread-multi/perllocal.pod
</code></pre><p>2.设置</p>
<p>尽管lxr源码里有一个INSTALL文件，但不详，这里写下来我自己配置的步骤。<br>1）位置规划<br>LXR除了数据库那一部分不需要考虑存放位置以外，还有CGI/HTML部分、索引生成工具部分和</p>
<p>所需要索引的源代码部分需要考虑，我的实践中使用的与INSTALL缺省的不同，最大的一点不同在于我</p>
<p>将WEB部分和工具部分分离开，只允许WEB部分暴露给浏览器——主要是基于也许会更安全一些的考虑。<br>另一个不同是用符号链接而不是真正的源代码目录作为源代码部分，因为LXR索引的Linux Kernel是最常用的，</p>
<p>而Kernel本身还被用来重编内核和升级，所以不适合完全拷贝过来。<br>本例中使用的是/usr/local/lxr目录作为LXR的根目录。 </p>
<pre><code><span class="preprocessor">#tar zxvf lxr-0.9.1.tar.gz -C /usr/local ；将lxr解压到/usr/local/lxr下 </span>
<span class="preprocessor">#cd /usr/local/</span>

<span class="preprocessor">#mv Local.pm diff ident search source templates  #将web相关部分移到templates下  </span>

<span class="preprocessor">#mv templates http                            #http目录，用于存放WEB部分  </span>

<span class="preprocessor">#ln -s /usr/local/lxr/http/Local.pm /usr/lib/perl5/site_perl/ </span>

<span class="preprocessor">#ln -s http/lxr.conf         #为web部分和工具部分都需要用的文件建符号连接 </span>
<span class="preprocessor">#mv lib /usr/lib/perl5/site_perl/LXR  #将自定义的perl库文件拷贝</span>
</code></pre><p>到perl/mod_perl使用的缺省库文件目录中 </p>
<pre><code>#ln -s <span class="regexp">/usr/</span>lib<span class="regexp">/perl5 /</span>usr<span class="regexp">/local/</span>lib  #否则在运行时会出现Can<span class="string">'t locate LXR/Files.pm等错误 </span>
</code></pre><p>建立源代码根目录,（当前在lxr目录）</p>
<pre><code><span class="preprocessor">#mkdir src ；源代码部分的根 </span>

并将 linux-<span class="number">2.6</span><span class="number">.39</span>的源码链接到此目录下。

<span class="preprocessor">#cd src </span>

mkdir glimpse 

ln -s ../../../../src/linux-<span class="number">2.6</span><span class="number">.39</span> <span class="number">2.6</span><span class="number">.39</span>

<span class="preprocessor">#vi versions ；编辑/usr/local/lxr/src/versions文件，内容为2.6.39，表示让lxr索引2.6.39</span>

<span class="preprocessor">#cd ../../ ；回到/usr/local/lxr </span>
</code></pre><p>2）修改lxr.conf<br>准备好了目录结构，下一步就是改写lxr.conf文件。缺省的lxr.conf已经从templates拷贝到/usr/local/lxr/http/下了，</p>
<p>并在/usr/local/lxr/下有个连接。 注释掉所有与swish-e相关的变量定义,其余设置如下</p>
<pre><code><span class="string">'glimpsebin'</span> =&gt; <span class="string">'/usr/local/bin/glimpse'</span>, 

<span class="string">'glimpseindex'</span> =&gt; <span class="string">'/usr/local/bin/glimpseindex'</span>, 

<span class="string">'ectagsbin'</span> =&gt; <span class="string">'/usr/bin/ctags'</span>, 

<span class="string">'genericconf'</span> =&gt; <span class="string">'/usr/lib/perl5/site_perl/LXR/Lang/generic.conf'</span> 

<span class="string">'ectagsconf'</span> =&gt; <span class="string">'/usr/lib/perl5/site_perl/LXR/Lang/ectags.conf'</span> 

<span class="string">'baseurl'</span> =&gt; <span class="string">'http://192.168.1.102/lxr'</span>                 <span class="comment">#主机的IP地址 </span>

<span class="string">'range'</span> =&gt; [ readfile(<span class="string">'/usr/local/lxr/src/versions'</span>) ]  

<span class="string">'default'</span> =&gt; <span class="string">'2.6.39'</span>                                  <span class="comment">#缺省的代码树名 </span>

<span class="comment"># Templates used for headers and footers 下所有路径均设置为绝对路径,如 </span>

<span class="string">'htmlhead'</span> =&gt; <span class="string">'/usr/local/lxr/http/html-head.html'</span> 



<span class="string">'sourceroot'</span> =&gt; <span class="string">'/usr/local/lxr/src'</span>       <span class="comment">#源码根目录    (注意，最后无/) </span>

<span class="string">'sourcerootname'</span> =&gt; <span class="string">'Linux-$v'</span>        <span class="comment">#它将显示在缺省的最高级源码目录上 </span>

<span class="string">'glimpsedir'</span> =&gt; <span class="string">'/usr/local/lxr/src/glimpse'</span>         <span class="comment">#(注意，最后无/) </span>
</code></pre><p>3）apache的httpd.conf (/etc/httpd/conf/httpd.conf)<br>保证装了mod_perl的时候，在httpd.conf中添加以下几行： </p>
<pre><code><span class="keyword">Alias</span> /lxr/ /usr/local/lxr/http/ 

<span class="tag">&lt;Directory /usr/local/lxr/http/&gt;</span>

<span class="keyword">AllowOverride</span> None

<span class="keyword"><span class="common">Options</span></span> FollowSymLinks

<span class="tag">&lt;Files ~  "(search|source|ident|diff|find)$"&gt;</span>

<span class="keyword"><span class="common">SetHandler</span></span> perl-script

<span class="keyword">PerlHandler</span> ModPerl::Registry       #注意这里不是Apache::Registry

<span class="keyword"><span class="common">Options</span></span> +ExecCGI

<span class="keyword">PerlOptions</span> +ParseHeaders

<span class="tag">&lt;/Files&gt;</span>

<span class="tag">&lt;/Directory&gt;</span> 
</code></pre><p>表示访问/lxr就相当于访问/usr/local/lxr/http，且用perl解释search、source、ident、diff和find几个脚本，</p>
<p>而其他的仍然当成html来使用。<br>如果没有mod_perl，可以用SetHandler cgi-script代替perl-script，一样可以用，PerlHandler就不用了。<br>4.initialize<br>1）初始化MySQL数据库 (mysql) :</p>
<p>进入lxr目录/usr/local/lxr</p>
<p># mysql   </p>
<p>(反斜杠). initdb-mysql</p>
<p>2).建glimpse索引<br>在/usr/local/lxr/src/2.6.39/下运行’find . -name “*.[chS]” -follow | glimpseindex -H . -o -F’，索引所有.c、.h、.S（汇编）文件。这个过程比较耗时，但比起下一个过程来，就小巫见大巫了。<br>3.)建identity索引 这是LXR精髓所在<br>在/usr/local/lxr/下运行’./genxref —version=2.6.39—url=<a href="http://192.168.1.102/lxr&#39;，这个过程时间比较长，其结果就是在MySQL中添东西。如果已经做过索引了，它就只关心那些修改过的或新的文件，速度就快多了。这个过程如果中断了，最好清空数据库重新来过，否则可能会有错误。" target="_blank" rel="external">http://192.168.1.102/lxr&#39;，这个过程时间比较长，其结果就是在MySQL中添东西。如果已经做过索引了，它就只关心那些修改过的或新的文件，速度就快多了。这个过程如果中断了，最好清空数据库重新来过，否则可能会有错误。</a><br>4).修改权限<br>最简单的办法就是把/usr/local/lxr/http下所有的文件都改成apache的属主。在/usr/local/lxr/下运行’chown -R apache.apache http ‘。<br>5.startup   (rc.d restart httpd;rc.d restart mysqld)<br>重启mysql和httpd，然后访问<a href="http://192.168.1.102/lxr/source/就可以了。比较奇怪的是，因为这个cgi允许用类似目录一样的形式（source/）来访问，所以，如果服务器端有更新，浏览器端仍会使用老的页面，refresh也没用。这时只有清空本地cache了。" target="_blank" rel="external">http://192.168.1.102/lxr/source/就可以了。比较奇怪的是，因为这个cgi允许用类似目录一样的形式（source/）来访问，所以，如果服务器端有更新，浏览器端仍会使用老的页面，refresh也没用。这时只有清空本地cache了。</a><br> 6.参考博客   </p>
<p>[内核分析]LXR安装心得(0.9.3版)—-RH8.0测试通过<a href="http://www.cnblogs.com/huqingyu/archive/2005/02/19/106080.html" target="_blank" rel="external">http://www.cnblogs.com/huqingyu/archive/2005/02/19/106080.html</a></p>
<p>利用LXR建立源代码交叉索引 【原】<a href="http://hi.baidu.com/kissdev/blog/item/6e493daf15cf33c77cd92af9.html" target="_blank" rel="external">http://hi.baidu.com/kissdev/blog/item/6e493daf15cf33c77cd92af9.html</a></p>
<p>LXR安装过程简介(0.3版) <a href="http://blog.chinaunix.net/u1/46901/showart_397299.html" target="_blank" rel="external">http://blog.chinaunix.net/u1/46901/showart_397299.html</a></p>
<p>高亮LXR的代码 <a href="http://mjxian.cn/wordpress/archives/lxr-syntax-highlighting.html" target="_blank" rel="external">http://mjxian.cn/wordpress/archives/lxr-syntax-highlighting.html</a></p>
<p>mysql wiki：<a href="https://wiki.archlinux.org/index.php/MySQL_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="external">https://wiki.archlinux.org/index.php/MySQL_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87</a></p>
<p>附：部分软件版本</p>
<p>File-MMagic-1.27.tar.gz</p>
<p>perl-dbi-1.616-2-i686.pkg.tar.xz</p>
<p>perl-dbd-mysql-4.020-1-i686.pkg.tar.xz</p>
<p>lxr-0.9.10.tgz</p>
<p>glimpse-4.18.6</p>
]]></content>
         
         
           
             
              <breadCrumb title="linux" url="http://blog.tinyxd.me/categories/linux/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://blog.tinyxd.me/2012/07/11/linux-workqueue/</loc>
    <lastmod>2014-10-26T03:02:09.000Z</lastmod>
    <data>
        <display>
        <title>linux工作队列</title>
        <pubTime>2012-07-11T15:08:00.000Z</pubTime>
        
        <tag>linux </tag>
         
        <tag>kernel </tag>
         
         <content><![CDATA[<h2 id="工作队列(workqueue)">工作队列(workqueue)</h2>
<p>Linux中的Workqueue机制就是为了简化内核线程的创建。通过调用workqueue的接口就能创建内核线程。并且可以根据当前系统CPU的个数创建线程的数量，使得线程处理的事务能够并行化。 </p>
<p>workqueue是内核中实现简单而有效的机制，他显然简化了内核daemon的创建，方便了用户的编程， </p>
<p>尽管可延迟函数和工作队列非常相似，但是它们的区别还是很大的。主要区别在于：可延迟函数运行在中断上下文中，而工作队列中的函数运行在进程上下文中。执行可阻塞函数（例如：需要访问磁盘数据块的函数）的唯一方式是在进程上下文中运行。因为在中断上下文中不可能发生进程切换。可延迟函数和工作队列中的函数都不能访问进程的用户态地址空间。事实上，可延迟函数被执行时不可能有任何正在运行的进程。另一方面，工作队列中的函数是由内核线程来执行的，因此，根本不存在它要访问的用户态地址空间。 </p>
<h2 id="工作队列的数据结构">工作队列的数据结构</h2>
<p></p><p style="text-indent:2em">与工作队列相关的主要数据结构有两个：cpu_workqueue_struct和work_struct。名为workqueue_struct的描述符，包括一个有NR_CPUS个元素的数组，NR_CPUS是系统中CPU的最大数量（双核是有两个工作队列）。每个元素都是cpu_workqueue_struct类型的描述符。 </p>
<p></p><br><a id="more"></a><p></p>
<p>work_struct结构是对任务的抽象。在该结构中需要维护具体的任务方法，需要处理的数据，以及任务处理的时间。该结构定义如下： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> work_struct { </div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> pending;                <span class="comment">/*如果函数已经在工作队列链表中，该字段值设为1，否则设为0*/</span> </div><div class="line">        <span class="keyword">struct</span> list_head entry;                  <span class="comment">/* 将任务挂载到queue的挂载点 */</span> </div><div class="line">        <span class="keyword">void</span> (*func)(<span class="keyword">void</span> *);                   <span class="comment">/* 任务方法 */</span> </div><div class="line">        <span class="keyword">void</span> *data;                                  <span class="comment">/* 任务处理的数据*/</span> </div><div class="line">       <span class="keyword">void</span> *wq_data;                           <span class="comment">/* work的属主（通常是指向cpu_workqueue_struct描述符的父结点的指针） */</span> </div><div class="line">       strut timer_list timer;                   <span class="comment">/* 任务延时处理定时器 */</span> </div><div class="line">};</div></pre></td></tr></table></figure>

<h2 id="工作队列函数">工作队列函数</h2>
<p>当用户调用workqueue的初始化接口create_workqueue或者create_singlethread_workqueue对workqueue队列进行初始化时，内核就开始为用户分配一个workqueue对象，并且将其链到一个全局的workqueue队列中。然后Linux根据当前CPU的情况，为workqueue对象分配与CPU个数相同的cpu_workqueue_struct对象，每个cpu_workqueue_struct对象都会存在一条任务队列。紧接着，Linux为每个cpu_workqueue_struct对象分配一个内核thread，即内核daemon去处理每个队列中的任务。至此，用户调用初始化接口将workqueue初始化完毕，返回workqueue的指针。    </p>
<p>在初始化workqueue过程中，内核需要初始化内核线程，注册的内核线程工作比较简单，就是不断的扫描对应cpu_workqueue_struct中的任务队列，从中获取一个有效任务，然后执行该任务。所以如果任务队列为空，那么内核daemon就在cpu_workqueue_struct中的等待队列上睡眠，直到有人唤醒daemon去处理任务队列.    </p>
<p>Workqueue初始化完毕之后，将任务运行的上下文环境构建起来了，但是具体还没有可执行的任务，所以，需要定义具体的work_struct对象。然后将work_struct加入到任务队列中，Linux会唤醒daemon去处理任务。    </p>
<p>queue_work()（封装在work_struct描述符中）把函数插入工作队列，它接收wq和work两个指针。wq指向workqueue_struct描述符，work指向work_struct描述符。queue_work（）主要执行下面的步骤：    </p>
<p>1.检查要插入的函数是否已经在工作队列中（work-&gt;pending字段等于1），如果是就结束。 </p>
<p>2.把work_struct描述符加到工作队列链表中，然后把work-&gt;pending置为1。 </p>
<p>3.如果工作者线程在本地CPU的cpu_workqueue_struct描述符的more_work等待队列上睡眠，该函数唤醒这个线程。 </p>
<h2 id="预定义工作队列">预定义工作队列</h2>
<p>在绝大多数情况下，为了运行一个函数而创建整个工作者线程开销太大了。因此，内核引入叫做events的预定义工作队列，所有的内核开发者都可以随便使用它。预定义工作队列只是一个包含不同内核层函数和IO驱动程序的标准工作队列，它的workququq_struct描述符存放在keventd_wq数组中。 </p>
<p>工作队列编程接口：   </p>
<table border="1"><br><tr><br>    <th>序号</th><br>    <th>接口函数</th><br>    <th>函数说明</th><br></tr><br><tr><br>    <td>1</td><br>    <td>create_workqueue</td><br>    <td>用于创建一个workqueue队列，为系统中的每个CPU都创建一个内核线程。输入参数：@name：workqueue的名称</td><br></tr><br><tr><br>    <td>2</td><br>    <td>create_singlethread_workqueue</td><br>    <td>用于创建一个workqueue队列，为系统中的每个CPU都创建一个内核线程。输入参数：@name：workqueue的名称</td><br></tr><br><tr><br>    <td>3</td><br>    <td>destroy_workqueue</td><br>    <td>释放workqueue队列。输入参数：@ workqueue_struct：需要释放的workqueue队列指针</td><br></tr><br><tr><br>    <td>4</td><br>    <td>schedule_work</td><br>    <td>调度执行一个具体的任务，执行的任务将会被挂入Linux系统提供的workqueue——keventd_wq输入参数：@ work_struct：具体任务对象指针<br></td><br></tr><br><tr><br>    <td>5</td><br>    <td>schedule_delayed_work</td><br>    <td>延迟一定时间去执行一个具体的任务，功能与schedule_work类似，多了一个延迟时间，输入参数：@work_struct：具体任务对象指针@delay：延迟时间</td><br></tr><br><tr><br>    <td>6</td><br>    <td>queue_work</td><br>    <td>调度执行一个指定workqueue中的任务。输入参数：@ workqueue_struct：指定的workqueue指针@work_struct：具体任务对象指针</td><br></tr><br><tr><br>    <td>7</td><br>    <td>queue_delayed_work</td><br>    <td>延迟调度执行一个指定workqueue中的任务，功能与queue_work类似，输入参数多了一个delay</td><br></tr><br></table> 

<p>预定义工作队列支持函数:    </p>
<table><br><tr><br>    <td>预定义工作队列函数</td><br>    <td>等价的标准工作队列函数</td><br></tr><br><tr><br>    <td>schedule_work(w)</td><br>    <td>queue_work( keventd_wq,w)</td><br></tr><br><tr><br>    <td>schedule_delayed_work(w,d)</td><br>    <td>queue_delayed_work(keventd_wq,w,d)在任何CPU上</td><br></tr><br><tr><br>    <td>schedule_delayed_work_on(cpu,w,d)</td><br>    <td>queue_delayed_work(keventd_wq,w,d)（在某个指定的CPU上）</td><br></tr><br><tr><br>    <td>flush_scheduled_work</td><br>    <td>flush_workqueue(keventd_wq)</td><br></tr><br></table>  

<p>除了一般的events队列，在linux2.6中你还会发现一些专用的工作队列。其中最重要的是快设备层使用的kblockd工作队列。 </p>
<p>本文章整理自网络和《深入理解linux内核》。    </p>
]]></content>
         
         
           
             
              <breadCrumb title="linux" url="http://blog.tinyxd.me/categories/linux/"/>
          
        </display>
    </data>
    </url>

</urlset>
