<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Keen on Art of Tech]]></title>
  <subtitle><![CDATA[Stay Hungry,Stay Foolish,Stay Patient.]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.tinyxd.me/"/>
  <updated>2014-10-28T15:03:10.500Z</updated>
  <id>http://blog.tinyxd.me/</id>
  
  <author>
    <name><![CDATA[Will]]></name>
    <email><![CDATA[admin@tinyxd.me]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[octopress迁移Hexo]]></title>
    <link href="http://blog.tinyxd.me/2014/10/26/octopress%E8%BF%81%E7%A7%BBhexo/"/>
    <id>http://blog.tinyxd.me/2014/10/26/octopress迁移hexo/</id>
    <published>2014-10-26T13:22:03.000Z</published>
    <updated>2014-10-28T14:25:57.000Z</updated>
    <content type="html"><![CDATA[<p>Octopress generate太慢，配置环境依赖得花费好长时间搞定，加之老机器太旧；趁着最近更新了机器，无奈把博客迁移到Hexo，继续码博客吧。<br>Hexo官网:<a href="http://hexo.io" target="_blank" rel="external">Link</a></p>
<h2 id="安装">安装</h2>
<ol>
<li>Mac下首先安装Node.js，直接到<a href="http://nodejs.org/" target="_blank" rel="external">这里</a>下载安装即可，安装完毕后在.bash_profile中添加:</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> PATH=<span class="string">"/usr/local/bin/:<span class="variable">$PATH</span>"</span></div></pre></td></tr></table></figure>

<p><a id="more"></a></p>
<ol>
<li>Mac自带git，不过得先安装好xCode才可以使用git</li>
<li>新建文件夹hexo执行命令，安装hexo：</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>npm install -g hexo</div></pre></td></tr></table></figure>

<ol>
<li>执行如下命令，初始化hexo</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>hexo init &lt;folder&gt;</div><div class="line"><span class="variable">$ </span>cd &lt;folder&gt;</div><div class="line"><span class="variable">$ </span>npm install</div></pre></td></tr></table></figure>

<ol>
<li>如果是从octopress迁移的可以需要修改<code>_config.yml</code></li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ <span class="keyword">cp</span> &lt;octopress&gt;/<span class="keyword">source</span>/_post/* &lt;hexo&gt;/<span class="keyword">source</span>/_post/</div></pre></td></tr></table></figure>



<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">new_post_name:</span> <span class="symbol">:year-</span><span class="symbol">:month-</span><span class="symbol">:day-</span><span class="symbol">:title</span>.md</div></pre></td></tr></table></figure>

<p>如果想要保留RSS，可以安装<code>hexo-migrator-rss</code>插件</p>
<h2 id="主题和插件">主题和插件</h2>
<p>Hexo提供了丰富的<a href="https://github.com/tommy351/hexo/wiki/Plugins" target="_blank" rel="external">插件</a>和<a href="https://github.com/tommy351/hexo/wiki/Themes" target="_blank" rel="external">主题</a>:<br>安装方法：</p>
<ol>
<li>插件</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="input"><span class="prompt">$ npm install &lt;plugin-name&gt;</span> --save</span></div></pre></td></tr></table></figure>

<ol>
<li>主题</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="input"><span class="prompt">$ git clone &lt;repository&gt;</span> themes/&lt;theme-name&gt;</span></div></pre></td></tr></table></figure>

<p>注意需要在<code>_config.yml</code>中修改<code>plugins</code>和<code>theme</code>的值来启用。</p>
<h2 id="调试">调试</h2>
<p>执行下面命令实时查看<code>http://localhost:4000</code>：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>hexo server</div></pre></td></tr></table></figure>

<h2 id="部署git_pages">部署git pages</h2>
<p>修改<code>_config.yml</code>:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  type: github</div><div class="line">  repository: git@<span class="filename">github.com</span>:XXX/<span class="filename">XXX.github.com.git</span></div><div class="line">  branch: master</div></pre></td></tr></table></figure>

<p>注意：为项目制作网页需要讲<code>branch</code>改为<code>gh-pages</code>,如果需要自定义域名需要添加CNAME文件，参考<a href="http://zespia.tw/hexo/docs/deployment.html" target="_blank" rel="external">Hexo</a><br>之后deploy：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>hexo clean</div><div class="line"><span class="variable">$ </span>hexo generate</div><div class="line"><span class="variable">$ </span>hexo deploy</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[Octopress generate太慢，加之老机器太旧；趁着最近更新了机器，把博客迁移到Hexo，继续码博客吧。]]>
    
    </summary>
    
      <category term="hexo" scheme="http://blog.tinyxd.me/tags/hexo/"/>
    
      <category term="octopress" scheme="http://blog.tinyxd.me/tags/octopress/"/>
    
      <category term="hexo" scheme="http://blog.tinyxd.me/categories/hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[IOS 7隐藏APP或者文件夹]]></title>
    <link href="http://blog.tinyxd.me/2013/09/20/ios-7-hide-app/"/>
    <id>http://blog.tinyxd.me/2013/09/20/ios-7-hide-app/</id>
    <published>2013-09-20T05:11:00.000Z</published>
    <updated>2014-10-26T03:02:09.000Z</updated>
    <content type="html"><![CDATA[<p>老罗的锤子rom有个奇葩的功能隐藏APP，现在IOS7也有这个功能了，不知道是bug还是新功能。<br>操作步骤：<br>1.拖动任意一个文件夹到主屏幕，然后确保主屏幕为满屏状态。   </p>
<p>2.按住刚文件夹或者文件夹中的APP，并迅速双击Home按钮，这时iOS会弹出多任务管理选择窗口，这时你需要点击第一个页面返回到主屏幕，这是你会发现你想隐藏的应用颜色已经便暗。    </p>
<p>3.打开你刚才在第一步拖到主屏幕上的文件夹，然后按下HOME，想要隐藏的应用或者文件夹已经消失了。    </p>
<p>注意：如果需要重新显示被隐藏的文件夹或者应用，你需要重新启动系统。    </p>
<p>参考：<a href="http://www.cnbeta.com/articles/253387.htm" target="_blank" rel="external">http://www.cnbeta.com/articles/253387.htm</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>老罗的锤子rom有个奇葩的功能隐藏APP，现在IOS7也有这个功能了，不知道是bug还是新功能。<br>操作步骤：<br>1.拖动任意一个文件夹到主屏幕，然后确保主屏幕为满屏状态。   </p>
<p>2.按住刚文件夹或者文件夹中的APP，并迅速双击Home按钮，这时iOS]]>
    </summary>
    
      <category term="ios" scheme="http://blog.tinyxd.me/categories/ios/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[终于可以更新博客啦]]></title>
    <link href="http://blog.tinyxd.me/2013/09/09/update-now/"/>
    <id>http://blog.tinyxd.me/2013/09/09/update-now/</id>
    <published>2013-09-09T15:28:00.000Z</published>
    <updated>2014-10-26T03:02:09.000Z</updated>
    <content type="html"><![CDATA[<p>之前一直因为电信的光猫还需要拨号，Linux上不了网，所以一直没有更新博客。最近终于有时间把光猫设置了下，支持自动拨号了，现在终于可以更新博客了。筒子们，我来了！</p>
]]></content>
    <summary type="html">
    <![CDATA[从今天开始更新博客！]]>
    
    </summary>
    
      <category term="essay" scheme="http://blog.tinyxd.me/categories/essay/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[恢复访问Github]]></title>
    <link href="http://blog.tinyxd.me/2013/01/23/github-hosts/"/>
    <id>http://blog.tinyxd.me/2013/01/23/github-hosts/</id>
    <published>2013-01-23T02:55:00.000Z</published>
    <updated>2014-10-26T03:02:09.000Z</updated>
    <content type="html"><![CDATA[<p>12306订票助手拖慢Github，最近Github被屏蔽。具体是不是这个原因导致被屏蔽还不得而知。因为使用DNS污染来屏蔽Github，所以可以通过修改Hosts来解决这一问题。<br>因为本博客源码，还有一些非常优秀的开源项目在Github上，不得以才出此下策。<br>windows下修改<code>C:\WINDOWS\system32\drivers\etc</code>，Archlinux下修改<code>/etc/hosts</code> ,在其中添加：    </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="number">207.97</span>.<span class="number">227.239</span> github.<span class="keyword">com</span> </div><div class="line"><span class="number">65.74</span>.<span class="number">177.129</span> www.github.<span class="keyword">com</span> </div><div class="line"><span class="number">207.97</span>.<span class="number">227.252</span> nodeload.github.<span class="keyword">com</span> </div><div class="line"><span class="number">207.97</span>.<span class="number">227.243</span> raw.github.<span class="keyword">com</span> </div><div class="line"><span class="number">204.232</span>.<span class="number">175.78</span> documentcloud.github.<span class="keyword">com</span> </div><div class="line"><span class="number">204.232</span>.<span class="number">175.78</span> pages.github.<span class="keyword">com</span></div></pre></td></tr></table></figure>


<p>希望此次事件能够尽快过去。<br>小贴士：<br>Github—-全球最大的社交编程及代码托管网站。    </p>
]]></content>
    <summary type="html">
    <![CDATA[12306订票助手拖慢Github，致使Github被屏蔽。因为使用DNS污染来屏蔽Github，所以可以修改Hosts来解决这一问题。]]>
    
    </summary>
    
      <category term="hosts" scheme="http://blog.tinyxd.me/tags/hosts/"/>
    
      <category term="git" scheme="http://blog.tinyxd.me/tags/git/"/>
    
      <category term="git" scheme="http://blog.tinyxd.me/categories/git/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[vim的一些配置]]></title>
    <link href="http://blog.tinyxd.me/2013/01/17/vim-config/"/>
    <id>http://blog.tinyxd.me/2013/01/17/vim-config/</id>
    <published>2013-01-17T09:44:00.000Z</published>
    <updated>2014-10-26T03:02:09.000Z</updated>
    <content type="html"><![CDATA[<p>一直很想系统的学习vim，因为各种原因把，一直把这个计划搁置到了现在，现在凑着学习vimwiki，再次把这个提上日程。<br>vim配置：<br>使用了<a href="https://github.com/vingel/vim/blob/master/vimrc" target="_blank" rel="external">vingel</a>的配置文件。<br>由于我还要学习vimwiki，所以添加了vimwiki的一些配置。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">"</span></div><div class="line">"vimwiki设置</div><div class="line"><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">"</span></div><div class="line">" 打开语法高亮</div><div class="line"><span class="string">"syntax enable</span></div><div class="line">syntax on</div><div class="line"></div><div class="line">" 打开对文件类型插件的支持</div><div class="line">filetype indent on</div><div class="line">filetype plugin on</div><div class="line"><span class="string">"filetype plugin indent on</span></div><div class="line"></div><div class="line">" <span class="comment">######### VimWiki 写作助手 ######### "</span></div><div class="line"></div><div class="line"><span class="string">" 使用鼠标映射</span></div><div class="line">let g:vimwiki_use_mouse = 1</div><div class="line"></div><div class="line">" 不要将驼峰式词组作为 Wiki 词条</div><div class="line"><span class="built_in">let</span> g:vimwiki_camel_<span class="keyword">case</span> = <span class="number">0</span></div><div class="line"></div><div class="line"><span class="built_in">let</span> g:vimwiki_list = [{</div><div class="line">\ <span class="string">'path'</span>: <span class="string">'/media/software/Dropbox/my_vimwiki_site/wiki'</span>,</div><div class="line">\ <span class="string">'path_html'</span>: <span class="string">'/media/software/Dropbox/my_vimwiki_site/html/'</span>,</div><div class="line"> \<span class="string">'template_path'</span> : <span class="string">'d:/vimwiki/template/'</span>,</div><div class="line">            \<span class="string">'template_default'</span> : <span class="string">'default_template'</span>,</div><div class="line">            \<span class="string">'template_ext'</span> : <span class="string">'.html'</span>,</div><div class="line">\ <span class="string">'auto_export'</span>: <span class="number">1</span>,}]</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[vim的一些配置方法]]>
    
    </summary>
    
      <category term="vim" scheme="http://blog.tinyxd.me/tags/vim/"/>
    
      <category term="linux" scheme="http://blog.tinyxd.me/tags/linux/"/>
    
      <category term="linux" scheme="http://blog.tinyxd.me/categories/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[文章末尾自动添加本文地址]]></title>
    <link href="http://blog.tinyxd.me/2013/01/16/add-article-info-footer/"/>
    <id>http://blog.tinyxd.me/2013/01/16/add-article-info-footer/</id>
    <published>2013-01-16T05:23:00.000Z</published>
    <updated>2014-10-26T03:02:09.000Z</updated>
    <content type="html"><![CDATA[<p>为每篇post添加本文地址和keywords信息。<br>Ruby脚本如下，添加到plugins文件夹中。    </p>
<p><script src="https://gist.github.com/4545472.js?file=post_footer_filter.rb"></script><br>本人已将插件上传到<a href="https://github.com/tinyxd/post_footer。" target="_blank" rel="external">https://github.com/tinyxd/post_footer。</a><br><a id="more"></a><br>在_config.yml中添加origional_url_pre，本文配置为”本站文章如果没有特别说明，均为原创，转载请以链接方式注明本文地址：”。   </p>
<p>本文参考：<code>http://codemacro.com/2012/07/26/post-footer-plugin-for-octopress/</code>。 </p>
]]></content>
    <summary type="html">
    <![CDATA[文章末尾自动添加本文地址]]>
    
    </summary>
    
      <category term="octopress" scheme="http://blog.tinyxd.me/tags/octopress/"/>
    
      <category term="octopress" scheme="http://blog.tinyxd.me/categories/octopress/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[新的一年]]></title>
    <link href="http://blog.tinyxd.me/2013/01/02/the-blog-stated/"/>
    <id>http://blog.tinyxd.me/2013/01/02/the-blog-stated/</id>
    <published>2013-01-02T04:22:00.000Z</published>
    <updated>2014-10-26T03:02:09.000Z</updated>
    <content type="html"><![CDATA[<p>好久没有写博客了，上篇博客是找工作之前，现在工作已经尘埃落定了。工作找完后，就开始忙着写论文，考驾照。<br>回首2012，感觉运气不佳，希望2013年能够运气好好。<br>2013愿望List：<br>1.手机（至于买什么还没有想好）<br>2.笔记本（Acer用了5年了。。。该换了，不出意外的话应该是Thinkpad）<br>3.单反<br>4.旅行（身体和灵魂.总有一个要在路上）<br>5.结束单身（这个感觉好难啊，Anyway还是列出来吧）<br>最后，说一句，关于本博客的主题，得到大家的肯定，我非常高兴，博友可以修改后发布，源码在我的github项目：<code>https://github.com/tinyxd/tinyxd.github.com</code>。如果有需要可以发Email（admin#tinyxd.me）交流。<br>本站所有作品采用知识共享署名-非商业性使用-相同方式共享 2.5 中国大陆许可协议进行许可。<br>附上最近很火的航母style，希望自己的工作能一飞冲天：   </p>
<img src="http://upload.tinyxd.me/2013/01/2013style.gif" title="[2013style [2013style]]">
]]></content>
    <summary type="html">
    <![CDATA[<p>好久没有写博客了，上篇博客是找工作之前，现在工作已经尘埃落定了。工作找完后，就开始忙着写论文，考驾照。<br>回首2012，感觉运气不佳，希望2013年能够运气好好。<br>2013愿望List：<br>1.手机（至于买什么还没有想好）<br>2.笔记本（Acer用了5年了]]>
    </summary>
    
      <category term="job" scheme="http://blog.tinyxd.me/tags/job/"/>
    
      <category term="essay" scheme="http://blog.tinyxd.me/categories/essay/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[开始找工作了]]></title>
    <link href="http://blog.tinyxd.me/2012/09/10/job-hunting-2012/"/>
    <id>http://blog.tinyxd.me/2012/09/10/job-hunting-2012/</id>
    <published>2012-09-09T16:24:00.000Z</published>
    <updated>2014-10-26T03:02:09.000Z</updated>
    <content type="html"><![CDATA[<p>今天，航天二院专场招聘，正式拉开了招聘的序幕。人好多！<br><img src="http://upload.tinyxd.me/2012/09/job.JPG" alt="Job Hunting" width="970" height="660">   </p>
]]></content>
    <summary type="html">
    <![CDATA[今年的形势很严峻啊！]]>
    
    </summary>
    
      <category term="job" scheme="http://blog.tinyxd.me/tags/job/"/>
    
      <category term="essay" scheme="http://blog.tinyxd.me/categories/essay/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[个人网站上安装SSL证书]]></title>
    <link href="http://blog.tinyxd.me/2012/09/02/nginx-ssl/"/>
    <id>http://blog.tinyxd.me/2012/09/02/nginx-ssl/</id>
    <published>2012-09-02T14:45:00.000Z</published>
    <updated>2014-10-26T03:02:09.000Z</updated>
    <content type="html"><![CDATA[<p>SSL(Secure Sockets Layer 安全套接层),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密。<br>HTTPS（Secure Hypertext Transfer Protocol）安全超文本传输协议，HTTPS应用了Netscape的完全套接字层（SSL）作为HTTP应用层的子层。（HTTPS使用端口443，而不是象HTTP那样使用端口80来和TCP/IP进行通信。）<br>建个网站不容易，各种都要收费，那么有免费的当然就更好了！免费的SSL证书：<a href="https://www.startssl.com/" target="_blank" rel="external">StartSSL</a>来了！<br>1.进入StartSSL<a href="https://www.startssl.com/" target="_blank" rel="external">官网</a>，点击左上角<code>Sign-up For Free</code>（这个很容易找，就不截图了<code>^_^</code>）。按要求填写注册信息，<code>First, Last Name</code>这一栏填写自己的中文名字的拼音，地址精确到房间号或者街道号（要不然客服发来邮件会索要地址的）。<br>2.注册成功后，StartSSL会发送一个链接给你，还有验证码。因为StartSSL使用证书验证的，所以，要把验证证书好好保管好，丢了就没法登陆了。<br>3.进入<code>Control Panel</code>之后，点击<code>Validations Wizard</code>，域名验证<code>Domain Name Validation</code>,填入你需要添加SSL的域名，还有你的个人邮箱（会给你发封邮件，里面有验证码，注意接收）。<br>4.验证完域名后，点击<code>Certificates Wizard</code>—<code>Web Server SSL/TLS Certificate</code>。<br><a id="more"></a><br><strong>生成私钥（Generate Private Key）</strong><br>如果你已经在VPS上生成了私钥，这一步可以跳过，没有的话，可以在这里生成，填入私钥的密码，将文本框中的内容复制，保存为<code>ssl.key</code>。<br><strong>生成证书</strong><br>选择你需要绑定的二级域名，比如<code>www.tinyxd.me</code>,<code>Tool Box</code>—<code>Retrieve Certificate</code>,同样将文本框中的内容复制另存为<code>ssl.crt</code>。<br><strong>登录VPS，生成服务器密钥/证书</strong><br>生成<code>server.key</code><br>    openssl rsa -in ssl.key -out server.key<br>生成<code>server.crt</code>    </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cp ssl.crt server.crt</div><div class="line">wget http://cert.startssl.com/certs/ca.pem</div><div class="line">wget http://cert.startssl.com/certs/sub.class1.server.ca.pem</div><div class="line">cat ca.pem sub.class1.server.ca.pem &gt;&gt; ca-certs.crt</div><div class="line">cat ca-certs.crt &gt;&gt; server.crt</div></pre></td></tr></table></figure>

<p><strong>修改nginx配置文件</strong><br>将<code>server.key</code>和<code>server.crt</code>放到<code>/usr/local/nginx/certs/</code>目录下，修改<code>/usr/local/nginx/conf/vhost/</code>对应域名虚拟机的配置文件，添加如下内容：   </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="title">server</span> {</div><div class="line"><span class="title">listen</span> <span class="number">80</span>;</div><div class="line"><span class="title">server_name</span> www.域名.com;</div><div class="line"><span class="title">rewrite</span><span class="regexp"> ^(.*)</span> <span class="url">https://$server_name$1</span> <span class="built_in">permanent</span>;</div><div class="line">}</div><div class="line"><span class="title">server</span> {</div><div class="line"><span class="title">listen</span> <span class="number">443</span>;</div><div class="line"><span class="title">server_name</span> www.域名.com;</div><div class="line"><span class="title">root</span> /home/www;</div><div class="line"><span class="title">ssl</span> <span class="built_in">on</span>;</div><div class="line"><span class="title">ssl_certificate</span> /usr/local/nginx/certs/server.crt;</div><div class="line"><span class="title">ssl_certificate_key</span> /usr/local/nginx/certs/server.key;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面脚本的<code>rewrite ^(.*) https://$server_name$1 permanent;</code>如果不填加的话，你的网站将可以进行http和https的两种访问。<br>最后重启Nginx，<code>/usr/local/nginx restart</code> 。访问你的网站，看是不是支持https访问了！<br>本文参考：<a href="http://ichon.me/2012/5/29/nginx-ssl.html" target="_blank" rel="external">http://ichon.me/2012/5/29/nginx-ssl.html</a>和<a href="http://baike.baidu.com/view/16147.htm" target="_blank" rel="external">http://baike.baidu.com/view/16147.htm</a><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[为了保证网络通信安全，在个人博客网站上安装SSL。]]>
    
    </summary>
    
      <category term="vps" scheme="http://blog.tinyxd.me/tags/vps/"/>
    
      <category term="nginx" scheme="http://blog.tinyxd.me/tags/nginx/"/>
    
      <category term="ssl" scheme="http://blog.tinyxd.me/tags/ssl/"/>
    
      <category term="vps" scheme="http://blog.tinyxd.me/categories/vps/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[VPS安装openVPN]]></title>
    <link href="http://blog.tinyxd.me/2012/08/30/debian-ubuntu-setup-openvpn/"/>
    <id>http://blog.tinyxd.me/2012/08/30/debian-ubuntu-setup-openvpn/</id>
    <published>2012-08-30T04:24:00.000Z</published>
    <updated>2014-10-26T03:02:09.000Z</updated>
    <content type="html"><![CDATA[<p>首先，你得有VPS或者独立服务器。<br>因为我的VPS是openVZ的，查资料发现新的openVZ的VPS是支持PPTP的。不过鉴于安全性的考虑我还是使用openVPN。<br>本文后面会介绍在debian 6下面安装openvpn的一些注意事项以及在xp下面安装openVPN。   </p>
<h2 id="使用一键安装包来安装openVPN_">使用一键安装包来安装openVPN   </h2>
<p>1.检查你的VPS是否支持Tun/Tap/nat/ppp，登录VPS检查<br>    cat /dev/net/tun<br>如果返回 <code>cat: /dev/net/tun: File descriptor in bad state</code> 说明tun是可用的。<br>    iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -o venet0 -j MASQUERADE<br>如果返回<code>iptables: No chain/target/match by that name</code>说明nat也是可以用的。<br><a id="more"></a><br>如果返回结果不是以上描述的，那么说明你的VPS服务商默认没有开通。你可以发ticket要求VPS提供商提供这个，我的VPS就没有提供这个，就发了ticket，不过很快就解决了。<br>2.检查服务器的DNS<br>    vi /etc/resolv.conf<br>可以使用<br>OpenDNS提供的DNS服务器地址<br>　　208.67.222.222<br>　　208.67.220.220<br>Google提供的DNS服务<br>    8.8.8.8<br>    8.8.4.4<br>3.下载John Malkowski的Debian OpenVPN脚本。<br>    wget <a href="http://vpsnoc.com/scripts/debian-openvpn.sh" target="_blank" rel="external">http://vpsnoc.com/scripts/debian-openvpn.sh</a><br>    chmod +x debian-openvpn.sh<br>    ./debian-openvpn.sh<br>连续填写server和client的信息，出现y/n的时候都选择y。<br>然后把生成的<code>keys.tgz</code>下载自本地。   </p>
<h2 id="不使用一键安装包，一步步自己安装">不使用一键安装包，一步步自己安装</h2>
<p>以下内容参考了：<a href="http://www.vpser.net/build/linode-install-openvpn.html" target="_blank" rel="external">VPS侦探 Linode VPS OpenVPN安装配置教程(基于Debian/Ubuntu)</a><br>1.安装<br>    apt-get install openvpn udev lzop<br>2.OpenVPN提供了”easy-rsa”这套加密方面的工具openvpn安装好之后easy-rsa在/usr/share/doc/openvpn/examples/easy-rsa/文件夹中为了使OpenVPN正常工作需要把easy-rsa复制到/etc/openvpn中.运行下列命令:     </p>
<pre><code>#cp -R <span class="regexp">/usr/</span>share<span class="regexp">/doc/</span>openvpn<span class="regexp">/examples/</span>easy-rsa<span class="regexp">/ /</span>etc<span class="regexp">/openvpn</span>
</code></pre><p>在<code>/etc/openvpn/easy-rsa/2.0/</code>中设置，基本所有的OpenVPN配置都在这。<br>生产CA证书：   </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">cd</span> /etc/openvpn/easy-rsa/<span class="number">2.0</span></div><div class="line"><span class="keyword">source</span> vars</div><div class="line">./clean-<span class="keyword">all</span></div><div class="line">./build-<span class="keyword">ca</span></div></pre></td></tr></table></figure>

<p><code>./build-ca</code>时会提示输入一些信息，可以都直接回车按默认信息。<br>3.生成服务器端证书和密钥：<br>    ./build-key-server server<br>有两次需要输入y。<br>4.生产客户端证书和密钥：<br>    ./build-key client<br>生成的证书和密钥在<code>/etc/openvpn/easy-rsa/2.0/keys/</code>下面。<br>5.生成Diffie Hellman参数：<br>    ./build-dh<br>6.安装配置openVPN客户端    详情见参考。   </p>
<h2 id="windows客户端下载">windows客户端下载</h2>
<p>1.下载OpenVPN：<a href="http://www.openvpn.net/index.php/open-source/downloads.html" target="_blank" rel="external">http://www.openvpn.net/index.php/open-source/downloads.html</a>下载最新版本安装包。<br>2.安装，建议win7/vista用户安装到非系统分区。<br>3.修改虚拟网卡DNS，Google DNS :8.8.8.8和 8.8.4.4；OpenDNS的208.67.222.222 和208.67.220.220。<br>4.将keys.tgz解压至openVPN安装目录下的config目录。<br>5.运行openVPN。<br>6.如果没有什么差错的话至此安装成功。<br>可以进<a href="http://www.dnsstuff.com" target="_blank" rel="external">http://www.dnsstuff.com</a> 或者facebook/twitter等测试下。惊喜等着你哦！<br>如果需要和你的朋友分享这个，可以新建个用户，重新生成客户端证书。   </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /etc/openvpn/easy-rsa/<span class="number">2.0</span></div><div class="line"> ./vars</div><div class="line">./build-key user1</div></pre></td></tr></table></figure>

<p>将新生成的user1.crt,user1.key,user1.csr三个文件和<em>.ovpn和ca.crt、ca.key三个文件一起下载到本地，编辑下载下来的`</em>.ovpn<code>文件将其中的</code>cert client1.crt<code>和</code>key client1.key<code>修改为：</code>cert user1.crt<code>和</code>key user1.key`。<br>把以上文件，打包发送给你的朋友。并将其解压到config目录下。<br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[在vps(openvz架构)上安装openVPN，至于为什么要安装openVPN，我想大家都懂的。]]>
    
    </summary>
    
      <category term="vps" scheme="http://blog.tinyxd.me/tags/vps/"/>
    
      <category term="vpn" scheme="http://blog.tinyxd.me/tags/vpn/"/>
    
      <category term="vps" scheme="http://blog.tinyxd.me/categories/vps/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[用Dropbox备份VPS网站及数据库 ]]></title>
    <link href="http://blog.tinyxd.me/2012/08/27/use-dropbox-backup-vps-and-database/"/>
    <id>http://blog.tinyxd.me/2012/08/27/use-dropbox-backup-vps-and-database/</id>
    <published>2012-08-27T15:28:00.000Z</published>
    <updated>2014-10-26T03:02:09.000Z</updated>
    <content type="html"><![CDATA[<p>用SSH客户端（PuTTY）登陆，进入root目录：<br>    cd ~<br>linux下用ssh登录：<br>    ssh (ip) -l (用户名) -p (端口号)<br>    或者<br>    ssh username@ip<br>    或者<br>    ssh username@domain<br>下载dropbox程序：<br>32位版本：<br>    wget -O dropbox.tar.gz <a href="http://www.dropbox.com/download/?plat=lnx.x86" target="_blank" rel="external">http://www.dropbox.com/download/?plat=lnx.x86</a><br>64位版本：<br>    wget -O - “<a href="https://www.dropbox.com/download?plat=lnx.x86_64" target="_blank" rel="external">https://www.dropbox.com/download?plat=lnx.x86_64</a><br><a id="more"></a><br>解压缩：<br>        tar -zxof dropbox.tar.gz<br>然后第一次运行dropbox：<br>        ~/.dropbox-dist/dropboxd &amp;<br>运行后会出现一串URL地址，把这个复制到流量器上，跟你的dropbox账户进行绑定。<br>绑定好之后就可以开始同步了。<br>首先进入dropbox，<br>       cd ~/Dropbox<br>备份整个wwwroot目录，建立一个软连接：<br>        ln -s /home/wwwroot<br>由于dropbox耗费的内存确实够大，建议不要开太长时间<br><img src="http://upload.tinyxd.me/2012/08/dropboxload.jpg" alt="dropboxload" width="778" height="200"><br>如果上面操作没有错误的话，在dropbox就可以看到同步的文件了。<br>附别人写的一个脚本：</p>
<figure class="highlight bash"><figcaption><span>dropboxbak.sh </span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="shebang">#!/bin/sh</span></div><div class="line"> BACKUP_SRC=<span class="string">"/root/Dropbox"</span>  <span class="comment">#用于同步的本地目录</span></div><div class="line"> BACKUP_WWW=<span class="string">"/home/wwwroot"</span>     <span class="comment">#你的网站目录</span></div><div class="line"> NOW=$(date +<span class="string">"%Y.%m.%d"</span>)</div><div class="line"> MYSQL_SERVER=<span class="string">"127.0.0.1"</span></div><div class="line"> MYSQL_USER=<span class="string">"user"</span></div><div class="line"> MYSQL_PASS=<span class="string">"password"</span></div><div class="line"> DAY=$(date +<span class="string">"%u"</span>)             <span class="comment">#取当前星期，1表示周一</span></div><div class="line"> <span class="function"><span class="title">start</span></span>() {</div><div class="line"><span class="built_in">echo</span> starting bak SQL</div><div class="line"> <span class="comment">#dump数据库数据，以及备份网站整站文件</span></div><div class="line"> mysqldump -u <span class="variable">$MYSQL_USER</span> -h <span class="variable">$MYSQL_SERVER</span> -p<span class="variable">$MYSQL_PASS</span> 需要备份的数据库名称 &gt; <span class="string">"<span class="variable">$BACKUP_SRC</span>/<span class="variable">$NOW</span>-Databases.sql"</span></div><div class="line"> <span class="built_in">echo</span> starting dropbox</div><div class="line"> /root/.dropbox-dist/dropboxd &</div><div class="line"> }</div><div class="line"> <span class="function"><span class="title">stop</span></span>() {</div><div class="line"> <span class="built_in">echo</span> stoping dropbox</div><div class="line"> pkill dropbox</div><div class="line"> }</div><div class="line"> <span class="keyword">case</span> <span class="string">"<span class="variable">$1</span>"</span> <span class="keyword">in</span></div><div class="line"> start)</div><div class="line"> start</div><div class="line"> ;;</div><div class="line"> stop)</div><div class="line"> stop</div><div class="line"> ;;</div><div class="line"> <span class="keyword">esac</span></div></pre></td></tr></table></figure>

<p>将脚本放到~/.dropbox下，修改脚本权限：<br>            chmod 755 ~/.dropbox/dropboxbak.sh<br>添加计划任务：<br>            crontab –e<br>添加两条内容：<br>                0   3 <em> </em> * sh /root/.dropbox/dropboxbak.sh start</p>
<pre><code>            <span class="number">30</span> <span class="number">3</span> * * * <span class="keyword">sh</span> /root/.dropbox/dropboxbak.<span class="keyword">sh</span> <span class="keyword">stop</span>
</code></pre><p>具体参数参照文档。<br>删除dropbox的方法：   </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># sh /root/.dropbox/dropboxbak.sh stop</span></div><div class="line"><span class="comment"># su - root</span></div><div class="line"><span class="comment"># cd</span></div><div class="line"><span class="comment"># rm -rf .dropbox .dropbox-dist  Dropbox dropbox.tar.gz dbmakefakelib.py dbreadconfig.py</span></div></pre></td></tr></table></figure>


<p>更多内容请参考相关网站。<br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[用Dropbox自动备份同步VPS网站及数据库]]>
    
    </summary>
    
      <category term="vps" scheme="http://blog.tinyxd.me/tags/vps/"/>
    
      <category term="dropbox" scheme="http://blog.tinyxd.me/tags/dropbox/"/>
    
      <category term="vps" scheme="http://blog.tinyxd.me/categories/vps/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[图床管理]]></title>
    <link href="http://blog.tinyxd.me/2012/08/26/imag-file-explorer/"/>
    <id>http://blog.tinyxd.me/2012/08/26/imag-file-explorer/</id>
    <published>2012-08-25T16:08:00.000Z</published>
    <updated>2014-10-26T03:02:09.000Z</updated>
    <content type="html"><![CDATA[<p>做网站，尤其是做多个网站的，文件的统一管理，备份是很重要的。本站用<a href="http://encode-explorer.siineiolekala.net/" target="_blank" rel="external">Encode Explorer</a>来管理本站图片、上传附件等。<br>去Encode Explorer在sourceforge的<a href="http://sourceforge.net/projects/encode-explorer/files/encode-explorer/" target="_blank" rel="external">项目官网</a>下载程序，其代码不过3k多行。只要将index.php上传到网站根目录，然后把nginx设置好用<a href="http://upload.tinyxd.me/" target="_blank" rel="external">2级域名</a>指向此根目录，就可以了。<br>其中index.php需要改几个地方：<br>1.<code>$_CONFIG[&#39;lang&#39;] = &quot;zh_CN&quot;;</code> 支持中文<br>2.<code>$_CONFIG[&#39;users&#39;] = array(array(&#39;username&#39;, &#39;password&#39;, &#39;admin&#39;));</code>  建立admin用户<br>其中index.php介绍比较详细了。语法格式：array(username, password, status)    status为user可以查看目录但不可以修改，admin能够上传文件和删除文件。<br>3.<code>$_CONFIG[&#39;new_dir_mode&#39;] = 0755;</code><br><code>$_CONFIG[&#39;upload_file_mode&#39;] = 0644;</code><br>修改新建文件夹和上传文件的默认权限。<br>这就是最终完成的，用二级域名（只要将该域名dns解析到vps服务器地址就可以了）<a href="http://upload.tinyxd.me/" target="_blank" rel="external">http://upload.tinyxd.me/</a>来上传/浏览/删除文件。<br>本文参考了<a href="http://log4d.com/" target="_blank" rel="external">log4d</a>的<a href="http://log4d.com/2012/05/image-host/" target="_blank" rel="external">使用独立图床子域名</a>。<br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[做网站，尤其是做多个网站的，文件的统一管理，备份是很重要的。本文介绍Encode Explorer如何作为本站的文件管理程序的。]]>
    
    </summary>
    
      <category term="vps" scheme="http://blog.tinyxd.me/tags/vps/"/>
    
      <category term="explorer" scheme="http://blog.tinyxd.me/tags/explorer/"/>
    
      <category term="vps" scheme="http://blog.tinyxd.me/categories/vps/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[vps lnmp配置优化]]></title>
    <link href="http://blog.tinyxd.me/2012/08/25/vps-optimization/"/>
    <id>http://blog.tinyxd.me/2012/08/25/vps-optimization/</id>
    <published>2012-08-25T15:40:00.000Z</published>
    <updated>2014-10-26T03:02:09.000Z</updated>
    <content type="html"><![CDATA[<p>我选用了lnmp（linux + Nginx + PHP + MySQL ）来安装，方便快捷，安装后发现其实好多已经优化好了。<br>其中需要注意到的有以下几个：<br>一. 基于xen架构的可以增加swap分区大小<br>我的vps是openVZ的，swap分区是不能随意更改的。PS.主机商已经提供了128M的swap了。满足了！   </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cd <span class="regexp">/var/</span></div><div class="line">dd <span class="keyword">if</span>=<span class="regexp">/dev/</span>zero of=swapfile bs=<span class="number">1024</span> <span class="keyword">count</span>=<span class="number">262144</span></div><div class="line"><span class="regexp">/sbin/m</span>kswap swapfile</div><div class="line"><span class="regexp">/sbin/</span>swapon swapfile</div></pre></td></tr></table></figure>

<p>然后让自己做的swap分区在系统启动时自动加载：<br>    vi /etc/fstab<br>在适当位置添加以下内容：    </p>
<pre><code>/<span class="keyword">var</span>/swapfile <span class="built_in">swap</span> <span class="built_in">swap</span> defaults <span class="number">0</span> <span class="number">0</span>
</code></pre><p><a id="more"></a><br>二.Nginx主配置文件（nginx.conf）的优化<br>Nginx每个进程耗费10M~12M内存，只开启一个Nginx进程，节省内存。<br>    worker_processes 1;<br>对网页文件、CSS、JS、XML等启动gzip压缩，减少数据传输量，提高访问速度。<br>    gzip on;<br>    gzip_min_length  1k;<br>    gzip_buffers     4 16k;<br>    gzip_http_version 1.0;<br>    gzip_comp_level 2;<br>    gzip_types       text/plain application/x-javascript text/css application/xml;<br>    gzip_vary on;<br>还有：<br>    location ~ .*.(php|php5)?$<br>       {</p>
<pre><code>     <span class="comment">#将Nginx与FastCGI的通信方式由TCP改为Unix Socket。TCP在高并发访问下比Unix Socket稳定，但Unix Socket速度要比TCP快。</span>
     <span class="title">fastcgi_pass</span>  <span class="url">unix:/tmp/php-cgi.sock</span>;
     <span class="comment">#fastcgi_pass  127.0.0.1:9000;</span>
     <span class="title">fastcgi_index</span> index.php;
     <span class="title">include</span> fcgi.conf;
   }

   <span class="title">location</span> <span class="regexp">~ /read.php</span>
   {
     <span class="comment">#将Nginx与FastCGI的通信方式由TCP改为Unix Socket。TCP在高并发访问下比Unix Socket稳定，但Unix Socket速度要比TCP快。</span>
     <span class="title">fastcgi_pass</span>  <span class="url">unix:/tmp/php-cgi.sock</span>;
     <span class="comment">#fastcgi_pass  127.0.0.1:9000;</span>
     <span class="title">fastcgi_index</span> index.php;
     <span class="title">include</span> fcgi.conf;
   }

   <span class="comment">#博客的图片较多，更改较少，将它们在浏览器本地缓存15天，可以提高下次打开我博客的页面加载速度。</span>
   <span class="title">location</span> <span class="regexp">~ .*\.(gif|jpg|jpeg|png|bmp|swf)$</span>
   {
     <span class="title">expires</span>      <span class="number">15d</span>;
   } 

   <span class="comment">#博客会加载很多JavaScript、CSS，将它们在浏览器本地缓存1天，访问者在看完一篇文章或一页后，再看另一篇文件或另一页的内容，无需从服务器再次下载相同的JavaScript、CSS，提高了页面显示速度。</span>
   <span class="title">location</span> <span class="regexp">~ .*\.(js|css)?$</span>
   {
     <span class="title">expires</span>      <span class="number">1d</span>;
   }   
</code></pre><p>其实上面说的lnmp自动安装包已经做好了这些优化！<br>包括后面<a href="http://blog.s135.com/post/375/2/1/" target="_blank" rel="external">这篇文章</a>提到的，lnmp已经配置好了。   </p>
<p><br><br>对于新手的忠告，将配置改好后，记得reload，或者restart。<br>经过优化后的vps，有人做过测试一小时，1000+的pv量都是没有问题的。相同的价格可见买vps还是比较合算的。<br>PS.我的vps现在放了两个站：<a href="http://tinyxd.me/" target="_blank" rel="external">本站</a>、<a href="http://info.tinyxd.me/" target="_blank" rel="external">冰之竹语</a>。后期准备再弄个技术bbs之类的玩玩。<br>对了我还放了个文件管理器<a href="http://encode-explorer.siineiolekala.net/" target="_blank" rel="external">Encode Explorer</a>，专门用来存放上传的图片和文件的。地址在<a href="http://upload.tinyxd.me/" target="_blank" rel="external">这里</a>。其实这一招是从<a href="http://log4d.com/2012/05/image-host/" target="_blank" rel="external">这里</a>学来的。。。<br>我将在我的下一篇<a href="http://tinyxd.me/blog/2012/08/26/imag-file-explorer/" target="_blank" rel="external">文章</a>中详细说明。<br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[由于资金有限，多数朋友选用了内存比较小的vps，这样就需要进行一些优化。]]>
    
    </summary>
    
      <category term="vps" scheme="http://blog.tinyxd.me/tags/vps/"/>
    
      <category term="lnmp" scheme="http://blog.tinyxd.me/tags/lnmp/"/>
    
      <category term="vps" scheme="http://blog.tinyxd.me/categories/vps/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[archlinux修改mac地址]]></title>
    <link href="http://blog.tinyxd.me/2012/08/23/archlinux-change-mac/"/>
    <id>http://blog.tinyxd.me/2012/08/23/archlinux-change-mac/</id>
    <published>2012-08-22T16:03:00.000Z</published>
    <updated>2014-10-26T03:02:09.000Z</updated>
    <content type="html"><![CDATA[<p>快开学了，开学了紧接着就是找工作。由于今年的形势还不太好，所以最近一直在复习一些编程方面的东西，好久没更新文章了。<br>还没到月底，自己的流量都已经用完了，悲催啊！！！借用别人的，这就需要修改mac地址。学校流量3G真的伤不起阿！！！囧<br>查阅Archlinux Wiki可以看到有两种临时改变mac地址的方法：<br>1.使用macchanger或者使用ip命令：    </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">macchanger --mac=XX:XX:XX:XX:XX:XX</div></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ip link <span class="keyword">set</span> dev eth0 down</div><div class="line">ip link <span class="keyword">set</span> dev eth0 address XX:XX:XX:XX:XX:XX</div><div class="line">ip link <span class="keyword">set</span> dev eth0 up</div></pre></td></tr></table></figure>

<p>2.在每次启动时自动修改MAC地址。<br>创建文件<code>/etc/rc.d/functions.d/macspoof</code>     </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">spoof_mac() {</div><div class="line">	ip link set dev eth<span class="number">0</span> address <span class="constant">XX</span><span class="symbol">:XX</span><span class="symbol">:XX</span><span class="symbol">:XX</span><span class="symbol">:XX</span><span class="symbol">:XX</span></div><div class="line">}</div><div class="line"></div><div class="line">add_hook sysinit_end spoof_mac</div></pre></td></tr></table></figure>

<p>具体可参见Archlinux wiki。   </p>
<p>inode上网可参考我以前的一篇文章:<a href="http://blog.tinyxd.me/blog/2012/05/25/archbang-arch-linux-an-zhuang-inode/" target="_blank" rel="external">http://blog.tinyxd.me/blog/2012/05/25/archbang-arch-linux-an-zhuang-inode/</a>   </p>
]]></content>
    <summary type="html">
    <![CDATA[校园网需要mac地址验证，故需要在linux系统下修改mac地址。]]>
    
    </summary>
    
      <category term="mac" scheme="http://blog.tinyxd.me/tags/mac/"/>
    
      <category term="archlinux" scheme="http://blog.tinyxd.me/tags/archlinux/"/>
    
      <category term="linux" scheme="http://blog.tinyxd.me/tags/linux/"/>
    
      <category term="linux" scheme="http://blog.tinyxd.me/categories/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[VPS申请及博客搭建]]></title>
    <link href="http://blog.tinyxd.me/2012/08/14/vps-lnmp-setup-and-typecho-blog/"/>
    <id>http://blog.tinyxd.me/2012/08/14/vps-lnmp-setup-and-typecho-blog/</id>
    <published>2012-08-13T16:33:00.000Z</published>
    <updated>2014-10-26T03:02:09.000Z</updated>
    <content type="html"><![CDATA[<p>前些天，在网上溜达时，突然看到一款免费的vps。不错。。。免费的。。。哥当时是激动啊，对于像我这样的屌丝，有免费的当然不会放过的。<br>于是乎哥就开始折腾了。<br>一、Vps申请<br>Vps是host1free提供的（128MB,10G,无限流量），申请地址：<a href="http://www.host1free.com/free-vps/" target="_blank" rel="external">http://www.host1free.com/free-vps/</a> ，看网上说，这已经是第三次开放注册了，一共2万个。最好翻墙注册，注册时最好用Gmail邮箱，不要用qq邮箱，然后就是耐心的等待了。建议大家，真心做正规站的来申请，做采集站的（包括采集类影视、小说、淘客及黑客、成人等违反TOS和中美法律内容）绕道吧。这个免费的vps对于想学习vps搭建博客的人实属不易。<br>二、 安装lnmp<br><a id="more"></a><br>参考<a href="http://lnmp.org/install.html" target="_blank" rel="external">LNMP一键安装包</a>，其中会用到putty工具，可以到<a href="http://dl.pconline.com.cn/html_2/1/97/id=3978&amp;pn=0.html" target="_blank" rel="external">这里</a>下载。<br>按照上面的步骤进行操作。需要说明的是   </p>
<ol>
<li>第一条命令<code>screen –S lnmp</code>很重要，当网络突然掉线或者不小心putty被关掉时候，可以用<code>screen –r lnmp</code>看到之前lnmp所进行到的情况。对于没有screen的可以按照<a href="http://www.vpser.net/manage/run-screen-lnmp.html" target="_blank" rel="external">这里</a>进行安装。   </li>
<li>当需要将二级域名绑定到此空间时，我所用的博客工具是typecho，当添加了虚拟主机后，进入后台出现404错误，一般出现这样的情况是nginx设置伪静态的问题，这个情况lnmp已经帮我们解决了。但是，我的仍然出现了404问题，最后把<code>/usr/local/nginx/conf/nginx.conf</code>里面的server_name 和所绑定的域名重名了。只要随便改个名字就好了。<br>三、 安装typecho<br>安装过程，<a href="http://docs.typecho.org/install" target="_blank" rel="external">官方文档</a>已经说的够详细了，这里就不再多说了。<br>四、 数据库的备份问题<br>数据备份，这个始终是个大问题。可以到<a href="http://www.vpser.net/vps-howto" target="_blank" rel="external">这里</a>参考，也可以使用rsync来同步备份。<br>五、关于新建站点<br>至于这个新建的站点，其实想法还没有成熟，只是想分享一些互联网，linux方面的资讯，还有一些搞笑的轻松的话题。地址是：<a href="http://info.tinyxd.me" target="_blank" rel="external">http://info.tinyxd.me</a><br>ps：博客还没有取名，希望大家给点建议。<br><br><br>关于vps，lnmp比较好的文章：<br><a href="http://www.cnblogs.com/amityat/archive/2011/08/23/2150177.html" target="_blank" rel="external">LNMP一键安装升级nginx及php常用设置 SFTP管理指南</a><br><a href="http://www.vpser.net/vps-howto" target="_blank" rel="external">VPS新手指南/教程</a><br><br></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[vps申请，typecho博客安装方法，lnmp安装过程，及博客的数据备份过程。]]>
    
    </summary>
    
      <category term="vps" scheme="http://blog.tinyxd.me/tags/vps/"/>
    
      <category term="typecho" scheme="http://blog.tinyxd.me/tags/typecho/"/>
    
      <category term="vps" scheme="http://blog.tinyxd.me/categories/vps/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[linux堆的管理]]></title>
    <link href="http://blog.tinyxd.me/2012/08/09/linux-heap-management/"/>
    <id>http://blog.tinyxd.me/2012/08/09/linux-heap-management/</id>
    <published>2012-08-09T10:32:00.000Z</published>
    <updated>2014-10-26T03:02:09.000Z</updated>
    <content type="html"><![CDATA[<p>每个Unix进程都拥有一个特殊的线性区，这个线性区就是所谓的堆（heap），堆用于满足进程的动态内存请求。内存描述符的start_brk与brk字段分别限定了这个区的开始地址和结束地址。<br><a id="more"></a><br>进程可以使用下面的API来请求和释放动态内存： </p>
<p>malloc（size） </p>
<pre><code>请求<span class="keyword">size</span>个字节的动态内存。如果分配成功，就返回所分配内存单元第一个字节的线性地址。 
</code></pre><p>calloc（n，size） </p>
<pre><code>请求含有n个大小为<span class="keyword">size</span>的元素的一个数组。如果分配成功，就把数组元素初始化为<span class="number">0</span>，并返回第一个元素的线性地址。 
</code></pre><p>realloc（ptr，size） </p>
<pre><code>改变由前面的<span class="function">malloc</span>()或<span class="function">calloc</span>()分配的内存区字段的大小。 
</code></pre><p>free（addr） </p>
<pre><code>释放由<span class="function">malloc</span>()或<span class="function">calloc</span>()分配的起始地址为addr的线性区。 
</code></pre><p>brk(addr) </p>
<pre><code>直接修改堆的大小。<span class="keyword">addr</span>参数指定current-&gt;mm-&gt;brk的新值，返回值是线性区新的结束地址（进程必须检查这个地址和所请求的地址值<span class="keyword">addr</span>是否一致）。  
</code></pre><p>sbrk(incr) </p>
<pre><code>类似于<span class="function">brk</span>()，不过其中的incr参数指定是增加还是减少以字节为单位的堆大小。 
</code></pre><p>brk()函数和以上列出的函数有所不同，因为它是唯一以系统调用的方式实现的函数，而其他所有的函数都是使用brk()和mmap()系统调用实现的C语言库函数。  </p>
<p>当用户态的进程调用brk()系统调用时，内核执行sys_brk(addr)函数。该函数首先验证addr参数是否位干进程代码所在的线性区。如 果 是，则立即返回，因为堆不能与进程代码所在的线性区重叠：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">mm = current-&gt;mm; </div><div class="line"></div><div class="line">down_write(&mm-&gt;mmap_sem); </div><div class="line"></div><div class="line"><span class="keyword">if</span> (addr &lt; mm-&gt;end_code) { </div><div class="line"></div><div class="line">out: </div><div class="line"></div><div class="line">    up_write(&mm-&gt;mmap_sem); </div><div class="line"></div><div class="line">    <span class="keyword">return</span> mm-&gt;brk; </div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>



<p>由于brk()系统调用作用于某一个非代码的线性区，它分配和释放完整的页 。因此，该函数把addr的值调整为PAGE_SIZE的倍数，然后把调整的结果与内存描述符的brk字段的值进行比较： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">newbrk = (addr + <span class="number">0xfff</span>) & <span class="number">0xfffff000</span>; </div><div class="line"></div><div class="line">oldbrk = (mm-&gt;brk + <span class="number">0xfff</span>) & <span class="number">0xfffff000</span>; </div><div class="line"></div><div class="line"><span class="keyword">if</span> (oldbrk == newbrk) { </div><div class="line"></div><div class="line">    mm-&gt;brk = addr; </div><div class="line"></div><div class="line">    <span class="keyword">goto</span> out; </div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>



<p>如果进程请求缩小堆，则sys_brk()调用do_munmap()函数完成这项任务，然后返回： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (addr &lt;= mm-&gt;brk) { </div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!do_munmap(mm, newbrk, oldbrk-newbrk)) </div><div class="line"></div><div class="line">        mm-&gt;brk = addr; </div><div class="line"></div><div class="line">    <span class="keyword">goto</span> out; </div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>



<p>如果进程请求扩大堆，则sys_brk()首先检查是否允许进程这样做。如果进程企图分配在其跟制范围之外的内存，函数并不多分配内存，只简单地返回mm-&gt;brk的原有值： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">rlim = current-&gt;signal-&gt;rlim[RLIMIT_DATA].rlim_cur; </div><div class="line"></div><div class="line"><span class="keyword">if</span> (rlim &lt; RLIM_INFINITY && addr - mm-&gt;start_data &gt; rlim) </div><div class="line"></div><div class="line">    <span class="keyword">goto</span> out;</div></pre></td></tr></table></figure>



<p>然后，函数检查扩大后的堆是否和进程的其他线性区相重叠，如果是，不做任何事情就返回： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (find_vma_intersection(mm, oldbrk, newbrk+PAGE_SIZE)) </div><div class="line"></div><div class="line">    <span class="keyword">goto</span> out;</div></pre></td></tr></table></figure>



<p>如果一切都顺利，则调用do_brk()函数。如果它返回oldbrk,则分配成功且sys_brt()函数返回addr的值；否则，返回旧的mm-&gt;brk值： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (do_brk(oldbrk, newbrk-oldbrk) == oldbrk) </div><div class="line"></div><div class="line">    mm-&gt;brk = addr; </div><div class="line"></div><div class="line"><span class="keyword">goto</span> out;</div></pre></td></tr></table></figure>



<p>do_brk()函数实际上是仅处理匿名线性区的do_mmap()的简化版。可以认为它的调用等价于： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">do_mmap(NULL, oldbrk, newbrk-oldbrk, PROT_READ|PROT_WRITE|PROT_EXEC, </div><div class="line"></div><div class="line">        MAP_FIXED|MAP_PRIVATE, <span class="number">0</span>)</div></pre></td></tr></table></figure>



<p>当然，do_brk()比do_mmap()稍快，因为前者假定线性区不映射磁盘上的文件，从而避免了检查线性区对象的几个字段。 </p>
<p>本文参考《深入理解linux内核》。   </p>
]]></content>
    <summary type="html">
    <![CDATA[每个Unix进程都拥有一个特殊的线性区，这个线性区就是所谓的堆，堆用于满足进程的动态内存请求。]]>
    
    </summary>
    
      <category term="linux" scheme="http://blog.tinyxd.me/tags/linux/"/>
    
      <category term="kernel" scheme="http://blog.tinyxd.me/tags/kernel/"/>
    
      <category term="linux" scheme="http://blog.tinyxd.me/categories/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[linux系统调用]]></title>
    <link href="http://blog.tinyxd.me/2012/08/08/linux-system-calls/"/>
    <id>http://blog.tinyxd.me/2012/08/08/linux-system-calls/</id>
    <published>2012-08-08T10:18:00.000Z</published>
    <updated>2014-10-26T03:02:09.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em>摘要</em></strong>：操作系统为在用户态运行的进程与硬件设备（如CPU、磁盘、打印机等等）进行交互提供了一组接口。在应用程序和硬件之间设置一个额外层具有很多优点。首先，这使得编程更加容易，那用户从学习硬件设备的低级编程特性中解放出来。其次，这极大地提高了系统的安全性，因为内核在试图满足某个请求之前在接口级就可以检查这种请求的正确性。最后，更重要的是这些接口使得程序更具有可移植性，因为只要内核所提供的一组接口相同，那么在任一内核上就可以正确地编译和执行程序。    </p>
<h2 id="简介_">简介     </h2>
<p>系统调用是在内核中实现的，再通过一定的方式把系统调用给用户，一般都通过门(gate)陷入(trap)实现。系统调用是用户程序和内核交互的接口。 <br><a id="more"></a><br>Linux系统在CPU的保护模式下提供了四个特权级别，目前内核都只用到了其中的两个特权级别，分别为“特权级0”和“特权级3”,[软间隔]级别0也就是我们通常所讲的内核模式，级别3也就是我们通常所讲的用户模式。划分这两个级别主要是对系统提供保护。内核模式可以执行一些特权指令和进入用[软间隔]户模式，而用户模式则不能。  </p>
<p>系统服务之所以需要通过系统调用提供给用户空间的根本原因是为了对系统“保护”，因为我们知道Linux的运行空间分为内核空间与用户空间，它们各自运行在不同的级别中，逻辑上相互隔离。所以用户进程在通常情况下不允许访问内核数据，也无法使用内核函数，它们只能在用户空间操作用户数据，调用户用空间函数。比如我们熟悉的“hello world”程序（执行时）就是标准的户空间进程，它使用的打印函数printf就属于用户空间函数，打印的字符“hello word”字符串也属于用户空间数据。 </p>
<p>但是很多情况下，用户进程需要获得系统服务（调用系统程序），这时就必须利用系统提供给用户的“特殊”接口——系统调用了，它的特殊性主要在于规定了用户进程进入内核的具体位置；换句话说用户访问内核的路径是事先规定好的，只能从规定位置进入内核，而不准许肆意跳入内核。有了这样的陷入内核的统一访问路径限制才能保证内核安全无虞。我们可以形象地描述这种机制：作为一个游客，你可以买票要求进入野生动物园，但你必须老老实实的坐在观光车上，按照规定的路线观光游览。当然，不准下车，因为那样太危险，不是让你丢掉小命，就是让你吓坏了野生动物。 </p>
<h2 id="API和系统调用_">API和系统调用 </h2>
<p>应用编程接口（API）与系统调用有所不同，前者只是一个函数定义，说明了如何获得一个给定的服务；而后者是通过软中断向内核态发出一个明确的请求。 </p>
<p>从编程者的观点看，API和系统调用之间的差别是没有关系的：唯一相关的事情就是函数名、参数类型及返回代码的含义。然而，从内核设计者的观点看，这种差别确实有关系，因为系统调用属于内核，而用户态的库函数不属于内核。 </p>
<h2 id="系统调用、用户编程接口（API）、系统命令、和内核函数的关系_">系统调用、用户编程接口（API）、系统命令、和内核函数的关系 </h2>
<p>系统调用并非直接和程序员或系统管理员打交道，它仅仅是一个通过软中断机制（我们后面讲述）向内核提交请求，获取内核服务的接口。而在实际使用中程序员调用的多是用户编程接口——API，而管理员使用的则多是系统命令。 </p>
<p>用户编程接口其实是一个函数定义，说明了如何获得一个给定的服务，比如read()、malloc()、free（）、abs()等。它有可能和系统调用形式上一致，比如read()接口就和read系统调用对应，但这种对应并非一一对应，往往会出现几种不同的API内部用到统一个系统调用，比如malloc()、free（）内部利用brk( )系统调用来扩大或缩小进程的堆；或一个API利用了好几个系统调用组合完成服务。更有些API甚至不需要任何系统调用——因为它不必需要内核服务，如计算整数绝对值的abs（）接口。 </p>
<p>另外要补充的是Linux的用户编程接口遵循了在Unix世界中最流行的应用编程界面标准——POSIX标准，这套标准定义了一系列API。在Linux中（Unix也如此）这些API主要是通过C库（libc）实现的，它除了定义的一些标准的C函数外，一个很重要的任务就是提供了一套封装例程（wrapper routine）将系统调用在用户空间包装后供用户编程使用。 </p>
<p>不过封装并非必须的，如果你愿意直接调用，Linux内核也提供了一个syscall()函数来实现调用，我们看个例子来对比一下通过C库调用和直接调用的区别。 </p>
<p>  </p>
<figure class="highlight c"><figcaption><span>例子</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;syscall.h&gt; </span></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;unistd.h&gt; </span></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt; </span></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;sys/types.h&gt; </span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">void</span>) { </div><div class="line"></div><div class="line"><span class="keyword">long</span> ID1, ID2; </div><div class="line"></div><div class="line"><span class="comment">/*-----------------------------*/</span> </div><div class="line"></div><div class="line"><span class="comment">/* 直接系统调用*/</span> </div><div class="line"></div><div class="line"><span class="comment">/* SYS_getpid (func no. is 20) */</span> </div><div class="line"></div><div class="line"><span class="comment">/*-----------------------------*/</span> </div><div class="line"></div><div class="line">ID1 = syscall(SYS_getpid); </div><div class="line"></div><div class="line"><span class="built_in">printf</span> (<span class="string">"syscall(SYS_getpid)=%ld\n"</span>, ID1); </div><div class="line"></div><div class="line"><span class="comment">/*-----------------------------*/</span> </div><div class="line"></div><div class="line"><span class="comment">/* 使用"libc"封装的系统调用 */</span> </div><div class="line"></div><div class="line"><span class="comment">/* SYS_getpid (Func No. is 20) */</span> </div><div class="line"></div><div class="line"><span class="comment">/*-----------------------------*/</span> </div><div class="line"></div><div class="line">ID2 = getpid(); </div><div class="line"></div><div class="line"><span class="built_in">printf</span> (<span class="string">"getpid()=%ld\n"</span>, ID2); </div><div class="line"></div><div class="line"><span class="keyword">return</span>(<span class="number">0</span>); </div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>  </p>
<p>系统命令相对编程接口更高了一层，它是内部引用API的可执行程序，比如我们常用的系统命令ls、hostname等。Linux的系统命令格式遵循系统V的传统，多数放在/bin和/sbin下（相关内容可看看shell等章节）。 </p>
<p>有兴趣的话可以通过strace ls或strace hostname 命令查看一下它们用到的系统调用，你会发现诸如open、brk、fstat、ioctl 等系统调用被用在系统命令中。 </p>
<p>下一个需要解释一下的问题是内核函数和系统调用的关系，内核函数大家不要想像的过于复杂，其实它们和普通函数很像，只不过在内核实现，因此要满足一些内核编程的要求[3]。系统调用是一层用户进入内核的接口，它本身并非内核函数，进入内核后，不同的系统调用会找到对应到各自的内核函数——换个专业说法就叫：系统调用服务服务例程。实际对请求服务的是内核函数而非调用接口。 </p>
<p>比如系统调用 getpid实际就是调用内核函数sys_getpid。 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">asmlinkage <span class="keyword">long</span> sys_getpid(<span class="keyword">void</span>) </div><div class="line"></div><div class="line">{ </div><div class="line"></div><div class="line">       <span class="keyword">return</span> current-&gt;tpid; </div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>Linux系统种存在许多的内核函数，有些是内核文件种自己使用的，有些则是可以export出来供内核其他部分共同使用的，具体情况自己决定。 </p>
<p>内核公开的内核函数——export出来的——可以使用命令ksyms 或 cat /proc/ksyms来查看。另外网上还有一本归纳分类内核函数的书叫作《The Linux Kernel API Book》，有兴趣的读者可以去看看。 </p>
<p>总而言之，从用户角度向内核看，依次是系统命令、编程接口、系统调用和内核函数。 </p>
<h2 id="系统调用处理程序及服务例程_">系统调用处理程序及服务例程 </h2>
<p>当用户态的进程调用一个系统调用时，CPU切换到内核态并开始执行一个内核函数，在80x86体系结构中，可以用两种不同的方式调用Linux的系统调用。两种方式的最终结果都是跳转到所谓系统调用处理程序（systerm call handler）的汇编语言函数。 </p>
<p>因为内核实现了很多不同的系统调用，因此进程必须传递一个名为系统调用号（systerm call number）的参数来识别所需的系统调用，eax寄存器就用作此目的。 </p>
<p>所有的系统调用都返回一个整数值。这些返回值与封装例程返回值的约定是不同的。在内核中，正数或0表示系统调用成功结束，而负数表示一个出错条件。在后一种情况下，这个值就是存放在errno变量中必须返回给应用程序的负出错码。内核没有设置或使用errno变量，而封装例程从系统调用返回之后设置这个变量。 </p>
<p>xyz()系统调用对应的服务例程的名字通常是sys_xyz()。不过也会有些例外。 </p>
<p>Linux中实现系统调用利用了0x86体系结构中的软件中断[4]。软件中断和我们常说的中断(硬件中断)不同之处在于——它是通过软件指令触发而并非外设，也就是说又编程人员出发的一种异常，具体的讲就是调用int $0x80汇编指令，这条汇编指令将产生向量为128的编程异常。 </p>
<p>之所以系统调用需要借助异常实现，是因为当用户态的进程调用一个系统调用时，CPU便被切换到内核态执行内核函数[5]，而我们在i386体系结构部分已经讲述过了进入内核——进入高特权级别——必须经过系统的门机制，这里异常实际上就是通过系统门陷入内核（除了int 0x80外用户空间还可以通过int3——向量3、into——向量4 、bound——向量5等异常指令进入内核，而其他异常用户空间程序无法利用，都是由系统使用的）。 </p>
<p>我们更详细的解释一下这个过程。int $0x80指令目的是产生一个编号为128的编程异常，这个编程异常对应的中断描述符表IDT中的第128项——也就是对应的系统门描述符。门描述符中含有一个预设的内核空间地址，它指向了系统调用处理程序：system_call()（别和系统调用服务程序混淆,这个程序在entry.S文件中用汇编语言编写）。 </p>
<p>很显然所有的系统调用都会统一的转到这个地址，但Linux一共有2、3百个系统调用都从这里进入内核后又该如何派发它们到各自的服务程序去呢？别发昏，解决这个问题的方法非常简单：首先Linux为每个系统调用都进行了编号（0—NR_syscall），同时在内核中保存了一张系统调用表，该表中保存了系统调用编号和其对应的服务例程，因此在系统调入通过系统门陷入内核前，需要把系统调用号一并传入内核，在x86上，这个传递动作是通过在执行int0x80前把调用号装入eax寄存器实现的。这样系统调用处理程序一旦运行，就可以从eax中得到数据，然后再去系统调用表中寻找相应服务例程了。 </p>
<p>除了需要传递系统调用号以外，许多系统调用还需要传递一些参数到内核，比如sys_write(unsigned int fd, const char * buf, size_t count)调用就需要传递文件描述符号fd和要写入的内容buf和写入字节数count等几个内容到内核。碰到这种情况，Linux会有6个寄存器使用来传递这些参数：eax (存放系统调用号)、 ebx、ecx、edx、esi及edi来存放这些额外的参数（以字母递增的顺序）。具体做法是在system_call( )中使用SAVE_ALL宏把这些寄存器的值保存在内核态堆栈中。 </p>
<p>有始便有终，当服务例程结束时，system_call( ) 从eax获得系统调用的返回值，并把这个返回值存放在曾保存用户态 eax寄存器栈单元的那个位置上。然后跳转到ret_from_sys_call( )，终止系统调用处理程序的执行。 </p>
<p>当进程恢复它在用户态的执行前，RESTORE_ALL宏会恢复用户进入内核前被保留到堆栈中的寄存器值。其中eax返回时会带回系统调用的返回码。（负数说明调用错误，0或正数说明正常完成） </p>
<h2 id="参数传递_">参数传递 </h2>
<p>与普通函数类似，系统调用通常也需要输入/输出参数，这些参数可能是实际的值，也可能是用户态进程地址空间的变量，甚至是指向用户态函数的指针的数据结构地址。 </p>
<p>普通C函数的参数传递是通过把参数值写入活动的程序栈（用户态栈或内核态栈）实现的。因为系统调用是一种横跨用户和内核两大陆地的特殊函数，所以既不能使用用户态栈也不能使用内核态栈。更确切地说，在发怵系统调用之前，系统调用的参数被写入CPU寄存器，然后在调用系统调用服务例程之前，内核再把存放在CPU中的参数拷贝到内核态堆栈中，这是因为系统调用服务例程是普通的C函数。 </p>
<p><br><br>本文参考自《深入理解linux内核》和<a href="http://chriszeng87.iteye.com/blog/1204500" target="_blank" rel="external">linux系统调用</a> 。   </p>
]]></content>
    <summary type="html">
    <![CDATA[系统调用是在内核中实现的，再通过一定的方式把系统调用给用户，一般都通过门(gate)陷入(trap)实现。系统调用是用户程序和内核交互的接口。 ]]>
    
    </summary>
    
      <category term="linux" scheme="http://blog.tinyxd.me/tags/linux/"/>
    
      <category term="kernel" scheme="http://blog.tinyxd.me/tags/kernel/"/>
    
      <category term="linux" scheme="http://blog.tinyxd.me/categories/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[linux缺页异常处理程序]]></title>
    <link href="http://blog.tinyxd.me/2012/08/07/linux-page-fault-exception/"/>
    <id>http://blog.tinyxd.me/2012/08/07/linux-page-fault-exception/</id>
    <published>2012-08-07T04:54:00.000Z</published>
    <updated>2014-10-26T03:02:09.000Z</updated>
    <content type="html"><![CDATA[<p>Linux的缺页（Page Fault）异常处理程序必须区分以下两种情况：由编程错误所引起的异常，及由引用属于进程地址空间但还尚未分配物理页框的页所引起的异常。  </p>
<p>线性区描述符可以让缺页异常处理程序非常有效地完成它的工作。do_page_fault()函数是80x86上的缺页中断服务程序，它把引起缺页的线性地址和当前进程的线性区相比较，从而能够根据和下图所示的方案选择适当的方法处理这个异常。<br><a id="more"></a></p>
<iframe src="https://skydrive.live.com/embed?cid=1F260DE1061FCF3E&resid=1F260DE1061FCF3E%21159&authkey=ACvRvyPr-3BWicI" width="320" height="207" frameborder="0" scrolling="no"></iframe> 

<p>在实际中，情况更复杂一些，因为缺页处理程序必须处理多种分得更细的特殊情况，它们不宜在总体方案中列出来，还必须区分许多种合理的访问。处理程序的详细流程图如图所示： </p>
<iframe src="https://skydrive.live.com/embed?cid=1F260DE1061FCF3E&resid=1F260DE1061FCF3E%21160&authkey=AFYUnmLPL0RCxXM" width="299" height="319" frameborder="0" scrolling="no"></iframe> 





<p>本文参考自《深入理解linux内核》和<a href="http://blog.csdn.net/yunsongice/article/details/5637671" target="_blank" rel="external">缺页异常处理程序</a> 。    </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Linux的缺页（Page Fault）异常处理程序必须区分以下两种情况：由编程错误所引起的异常，及由引用属于进程地址空间但还尚未分配物理页框的页所引起的异常。  </p>
<p>线性区描述符可以让缺页异常处理程序非常有效地完成它的工作。do_page_fault()函数是80x86上的缺页中断服务程序，它把引起缺页的线性地址和当前进程的线性区相比较，从而能够根据和下图所示的方案选择适当的方法处理这个异常。<br>]]>
    
    </summary>
    
      <category term="linux" scheme="http://blog.tinyxd.me/tags/linux/"/>
    
      <category term="kernel" scheme="http://blog.tinyxd.me/tags/kernel/"/>
    
      <category term="linux" scheme="http://blog.tinyxd.me/categories/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[linux线性区]]></title>
    <link href="http://blog.tinyxd.me/2012/08/07/linux-linear-regions/"/>
    <id>http://blog.tinyxd.me/2012/08/07/linux-linear-regions/</id>
    <published>2012-08-07T04:43:00.000Z</published>
    <updated>2014-10-26T03:02:09.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em>摘要</em></strong>：内核使用一种新的资源成功实现了对进程动态内存的推迟分配。当用户态进程请求动态内存时，并没有获得请求的页框，而仅仅获得对一个新的线性地址区间的使用权，而这一线性地址区间就成为进程地址空间的一部分。这一区间叫做“线性区”（memory region）。<br><br><br>Linux通过类型为vm_area_struct的对象实现线性区。 </p>
<p>每次运行一个程序，该程序的内容必须被放到进程的虚拟地址空间，对于可执行程序的共享库也是如此。可执行程序并非真正读到物理内存中，而只是链接到进程的虚拟内存中。<br><a id="more"></a><br>不论我们运行某个程序多少次内存分配地址（bss、栈、堆、数据段、正文段）都是一样的。我们知道，linux操作系统每个进程的地址空间都是独立的，其实这里的独立说得是物理空间上得独立。即相同的虚拟地址，不同的物理地址。 </p>
<p>当一个可执行程序映射到进程虚拟地址空间时，一组vm_area_struct数据结构将被产生。每个vm_area_struct数据结构表示可执行印象的一部分;是可执行代码，或是初始化的数据，以及未初始化的数据等。 </p>
<p>　　linux操作系统是通过sys_exec对可执行文件进行映射以及读取的，有如下几步： </p>
<p>　　1.创建一组vm_area_struct </p>
<p>　　2.圈定一个虚拟用户空间，将其起始结束地址(elf段中已设置好)保存到vm_start和vm_end中。 </p>
<p>　　3.将磁盘file句柄保存在vm_file中 </p>
<p>　　4.将对应段在磁盘file中的偏移值(elf段中已设置好)保存在vm_pgoff中; </p>
<p>　　5.将操作该磁盘file的磁盘操作函数保存在vm_ops中 </p>
<p>　　注意：这里没有对应 的页目录表项创建页表，更不存在设置页表项了。 </p>
<p>每个线性区描述符表示一个线性地址区间。vm_start字段包含区间的第一个线性地址，而vm_end字段包含区间之外的第一个线性地址。vm_end - vm_start表示线性区的长度。vm_mm字段指向拥有这个区间的进程的mm_struct内存描述符。我们稍后将描述vm_area_struct的其他字段。 </p>
<p>进程所拥有的线性区从来不重叠，并且内核尽力把新分配的线性区与紧邻的现有线性区进行合并。两个相邻区的访问权限如果相匹配，就能把它们合并在一起。 </p>
<p>当一个新的线性地址区间加入到进程的地址空间时，内核检查一个已经存在的线性区是否可以扩大。如果不能，就创建一个新的线性区。类似地，如果从进程的地址空间删除一个线性地址区间，内核就要调整受影响的线性区大小。有些情况下，调整大小迫使一个线性区被分成两个更小的部分（从理论上说，如果没有空闲的内存给新的内存描述符使用，删除一个线性地址区间可能会失败，不过这种情况出现的概率太小太小）。 </p>
<h2 id="线性区的数据结构_">线性区的数据结构 </h2>
<p>进程所拥有的所有线性区是通过一个简单的链表链接在一起的。出现在链表中的线性区是按内存地址的升序排列的；不过，每两个线性区可以由未用的内存地址区隔开。每个vm_area_struct元素的vm_next字段指向链表的下一个元素。内核通过进程的内存描述符的mmap字段来查找线性区，其中mmap字段指向链表中的第一个线性区描述符。 </p>
<p>内存描述符的map_count字段存放进程所拥有的线性区数目。默认情况下，一个进程可以最多拥有65536个不同的线性区，系统管理员可以通过写/proc/sys/vm/max_map_count文件来修改这个限定值。 </p>
<p>内核频繁执行的一个操作就是查找包含指定线性地址的线性区。由于链表是经过排序的，因此，只要在指定线性地址之后找到一个线性区，搜索就可以结束。 </p>
<p>然而，仅当进程的线性区非常少时使用这种链表才是很方便的，比如说只有一二十个线性区。在链表中查找元素、插入元素、删除元素涉及许多操作，这些操作所花费的时间与链表的长度成线性比例。 </p>
<p>尽管多数的Linux进程使用的线性区的数量非常少，但是诸如面向对象的数据库，或malloc()的专用调试器那样过于庞大的大型应用程序可能会有成百上千的线性区。在这种情况下，线性区链表的管理变得非常低效，因此，与内存相关的系统调用的性能就降低到令人无法忍受的程度。 </p>
<p>Linux2.6实现了两种一种是线性的链表结构方便顺序索引，而红黑树的数据结构方便查找。 </p>
<h2 id="红黑树_">红黑树    </h2>
<p>二叉排序树：每个元素（或说节点）通常有两个孩子：左孩子和右孩子。树中的元素被排序。对关键字为N的节点，它的左子树上的所有元素的关键字都比N小；相反，它的右子树上的所有元素的关键字都比N大。节点的关键字被写入节点内部。而除了具有基本的二叉排序树的特点以外，红-黑树必须满足下列5条规则： </p>
<p>1、每个节点必须或为黑或为红。 </p>
<p>2、树的根必须为黑。 </p>
<p>3、新插入的节点必须为红色。 </p>
<p>4、红节点的孩子必须为黑。 </p>
<p>5、从一个节点到后代叶子节点的每个路径都包含相同数量的黑节点。当统计黑节点个数时，空指针也算作黑节点。 </p>
<p>这5条规则确保具有n个内部节点的任何红一黑树其高度最多为2 × log（n+l）。 </p>
<p>在红-黑树中搜索一个元素因此而变得非常高效，因为其操作的执行时间与树大小的对数成线性比例。换句话说，双倍的线性区个数只多增加一次循环。 </p>
<p>在红黑树中插入和删除一个元素也是高效的，因为算法能很快地遍历树以确定插入元素的位置或删除元素的位置。任何新节点必须作为一个叶子插入并着成红色。如果操作违背了上述规则，就必须移动或重新着色树的几个节点。 </p>
<p>为了存放进程的线性区，Linux既使用了链表，也使用了红-黑树。这两种数据结构包含指向同一线性区描述符的指针，当插入或删除一个线性区描述符时，内核通过红-黑树搜索前后元素，并用搜索结果快速更新链表而不用扫描链表。 </p>
<p>链表的头由内存描述符的mmap字段所指向。任何线性区对象都在vm_next字段存放指向链表下一个元素的指针。红-黑树的首部由内存描述符的mm_rb字段所指向。任和线性区对象都在类型为rb_node的vm_rb字段中存放节点颜色以及指向双亲、左孩子和右孩子的指针。 </p>
<p>一般来说，红-黑树用来确定含有指定地址的线性区，而链表通常在扫描整个线性区集合时来使用。 </p>
<h2 id="线性区访问权限_">线性区访问权限 </h2>
<p>页与线性区的关系：我们使用“页”这个术语既表示一组线性地址和其物理地址对应的关系。尤其是，我们把介于0-4095之间的线性地址区间称为第0页，介于4096-8191之间的线性地址区间称为第1页，依此类推。因此每个线性区都由一组号码连续的页所构成。 </p>
<p>与页相关的两种标志： </p>
<ul>
<li><p>在每个页表项中存放的几个标志，如：Read/Write、Present等（参见“常规分页”）。 </p>
</li>
<li><p>存放在每个页描述符flags字段中的一组标志（参见的“页框管理”）。 </p>
</li>
</ul>
<p>第一种标志由80x86硬件用来检查能否执行所请求的寻址类型；第二种标志由Linux用于许多不同的目的。 </p>
<p>现在介绍第三种标志，即与线性区的页相关的那些标志。它们存放在vm_area_struct描述符的vm_flags字段中。一些标志给内核提供有关这个线性区全部页的信息，例如它们包含有什么内容，进程访问每个页的权限是什么。另外的标志描述线性区自身，例如它应该如何增长（这些标志位于include/linux/Mm.h）。 </p>
<p>VM_READ：页是可读的 </p>
<p>VM_WRITE：页是可写的 </p>
<p>VM_EXEC：页是可执行的 </p>
<p>VM_SHARED：页可以由几个进程共享 </p>
<p>VM_MAYREAD：可以设置VM_READ标志 </p>
<p>VM_MAYWRITE：可以设置VM_WRITE标志 </p>
<p>VM_MAYEXEC：可以设置VM_EXEC标志 </p>
<p>VM_MAYSHARE：可以设置VM_SHARE标志 </p>
<p>VM_GROWSDOWN：线性区可以向低地址扩展 </p>
<p>VM_GROWSUP：线性区可以向高地址扩展 </p>
<p>VM_SHM：线性区用于IPC的共享内存 </p>
<p>VM_DENYWRITE：线性区映射一个不能打开用于写的文件 </p>
<p>VM_EXECUTABLE：线性区映射一个可执行文件 </p>
<p>VM_LOCKED：线性区中的页被锁住，且不能换出 </p>
<p>VM_IO：线性区映射设备的I/O地址空间 </p>
<p>VM_SEQ_READ：应用程序顺序地访问页 </p>
<p>VM_RAND_READ：应用程序以真正的随机顺序访问页 </p>
<p>VM_DONTCOPY：当创建一个新进程时不拷贝线性区 </p>
<p>VM_DONTEXPAND：通过mremap()系统调用禁止线性区扩展 </p>
<p>VM_RESERVED：线性区是特殊的（如：它映射某个设备的I/O地址空间），因此它的页不能被交换出去 </p>
<p>VM_ACCOUNT：创建IPC共享线性区时检查是否有足够的空闲内存用干映射 </p>
<p>VM_HUGETLB：通过扩展分页机制处理线性区中的页 </p>
<p>VM_NONLINEAR：线性区实现非线性文件映射 </p>
<p>线性区描述符所包含的页访问权限可以任意组合。例如，存在这样一种可能性，允许一个线性区中的页可以执行但是不可以读取。为了有效地实现这种保护方案，与线性区的页相关的访问权限（读、写及执行）必须被复制到相应的所有表项中，以便由分页单元直接执行检查。换句话说，页访问权限表示何种类型的访问应该产生一个缺页异常。Linux委派缺页处理程序查找导致缺页的原因，因为缺页处理程序实现了许多页处理策略。 </p>
<p>页表标志的初值（注意，同一线性区所有页标志的初值必须一样）存放在vm_area_struct描述符的vm_page_prot字段中。当增加一个页时，内核根据vm_page_prot字段的值设置相应页表项中的标志。 </p>
<pre><code><span class="keyword">typedef</span> <span class="keyword">struct</span> { <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> pgprot; } pgprot_t;   <span class="comment">/* include/asm-i386/Page.h */</span> 
</code></pre><p>然而，不能把线性区的访问权限直接转换成页保护位，这是因为： </p>
<ul>
<li><p>在某些情况下，即使由相应线性区描述符的vm flags字段所指定的某个页的访问权限允许对该页进行访问，但是，对该页的访问还是应当产生一个缺页异常。例如“写时复制”的情况，内核可能决定把属于两个不同进程的两个完全一样的可写私有页（它的VM_SHARE标志被清0）存入同一个页框中；在这种情况下，无论哪一个进程试图改动这个页都应当产生一个异常。 </p>
</li>
<li><p>80x86处理器的页表仅有两个保护位，即Read/Write和User/Supervisor标志。此外，一个线性区所包含的任何一个页的User/Supervisor标志必须总置为1，因为用户态进程必须总能够访问其中的页。 </p>
</li>
<li><p>启用PAE的新近Intel Pentium 4微处理器，在所有64位页表项中支持NX（No eXecute）标志。 </p>
</li>
</ul>
<p>如果内核没有被编译成支持PAE，那么Linux采取以下规则以克服80x86微处理器的硬件限制： </p>
<ul>
<li><p>读访问权限总是隐含着执行访问权限，反之亦然。 </p>
</li>
<li><p>写访问权限总是隐含着读访问权限。 </p>
</li>
</ul>
<p>反之，如果内核被编译成支持PAE，而且CPU有NX标志，Linux就采取不同的规则： </p>
<ul>
<li><p>行访问权限总是隐含着读访问权限。 </p>
</li>
<li><p>访问权限总是隐含着读访问权限。 </p>
</li>
</ul>
<p>因此，要根据以下规则精简由读、写、执行和共享访问权限的16种可能组合： </p>
<ul>
<li><p>如果页具有写和共享两种访问权限，那么，Read/Write位被设置为1。 </p>
</li>
<li><p>如果页具有读或执行访问权限，但是既没有写也没有共享访问权限，那么，Read/Write位被清0。 </p>
</li>
<li><p>如果支持NX位，而且页没有执行访问权限，那么，把NX位设置为1。 </p>
</li>
<li><p>如果页没有任何访问权限，那么，Presen七位被清0，以便每次访问都产生一个缺页异常。然而，为了把这种情况与真正的页框不存在的情况相区分，Linux还把Page size位置为1（你可能认为Page size位的这种用法并不正当，因为这个位本来是表示实际页的大小。但是，Linux可以侥幸逃脱这种骗局，因为80 x 86芯片在页目录项中检查Page size位，而不是在页表的表项中检查该位。） </p>
</li>
</ul>
<p>访问权限的每种组合所对应的精简后的保护位存放在protection_map数组的16个元素中（mm/Mmap.c）： </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">pgprot_t protection_map[<span class="number">16</span>] = { </div><div class="line"></div><div class="line">__P000, __P001, __P010, __P011, __P100, __P101, __P110, __P111, </div><div class="line"></div><div class="line">__S000, __S001, __S010, __S011, __S100, __S101, __S110, __S111 </div><div class="line"></div><div class="line">}; </div><div class="line"></div><div class="line"><span class="comment">//include/asm-i386/Pgtable.h </span></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> __P000 PAGE_NONE </span></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> __P001 PAGE_READONLY </span></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> __P010 PAGE_COPY </span></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> __P011 PAGE_COPY </span></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> __P100 PAGE_READONLY_EXEC </span></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> __P101 PAGE_READONLY_EXEC </span></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> __P110 PAGE_COPY_EXEC </span></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> __P111 PAGE_COPY_EXEC </span></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> __S000 PAGE_NONE </span></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> __S001 PAGE_READONLY </span></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> __S010 PAGE_SHARED </span></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> __S011 PAGE_SHARED </span></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> __S100 PAGE_READONLY_EXEC </span></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> __S101 PAGE_READONLY_EXEC </span></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> __S110 PAGE_SHARED_EXEC </span></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> __S111 PAGE_SHARED_EXEC</span></div></pre></td></tr></table></figure>

<p>例如： </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> COPY_EXEC / </span></div><div class="line"></div><div class="line">__pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_ACCESSED)</div></pre></td></tr></table></figure>

<p><br><br>本文章参考自《深入理解linux内核》 。   </p>
]]></content>
    <summary type="html">
    <![CDATA[内核使用一种新的资源成功实现了对进程动态内存的推迟分配。当用户态进程请求动态内存时，并没有获得请求的页框，而仅仅获得对一个新的线性地址区间的使用权，而这一线性地址区间就成为进程地址空间的一部分。这一区间叫做“线性区”（memory region）.]]>
    
    </summary>
    
      <category term="linux" scheme="http://blog.tinyxd.me/tags/linux/"/>
    
      <category term="kernel" scheme="http://blog.tinyxd.me/tags/kernel/"/>
    
      <category term="linux" scheme="http://blog.tinyxd.me/categories/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[linux进程地址空间]]></title>
    <link href="http://blog.tinyxd.me/2012/08/05/linux-process-address-space/"/>
    <id>http://blog.tinyxd.me/2012/08/05/linux-process-address-space/</id>
    <published>2012-08-05T04:51:00.000Z</published>
    <updated>2014-10-26T03:02:09.000Z</updated>
    <content type="html"><![CDATA[<h2 id="简介_">简介   </h2>
<p>内核中获得动态内存的方式：<code>__get_free_pages()</code>或alloc_pages()从分区页框分配器中获得页框，kmem_cache_alloc()或kmalloc()使用slab分配器为专用或通用对象分配块，vmalloc()或vmalloc_32()获得一块非连续的内存区。如果所请求的内存区得以满足，这些函数都返回一个页描述符地址或线性地址（即所分配动态内存区的起始地址）。 </p>
<p>使用以上简单方法的原因： </p>
<pre><code>内核是操作系统中优先级最高的成分 

内核信任自己。 
</code></pre><p><a id="more"></a><br>当给用户态进程分配内存时： </p>
<pre><code>进程对动态内存的请求被认为是不紧迫的，内核总是尽量推迟给用户态进程分配动态内存。 

由于用户进程是不可信任的，因此 ，内核必须能随时准备捕获用户态进程引起的所有寻址错误。 
</code></pre><p>进程的地址空间（address space）由允许进程使用的全部线性地址组成。每个进程所看到的线性地址集合是不同的，一个进程所使用的地址与另外一个进程所使用的地址之间没有什么关系。后面我们会看到，内核可以通过增加或删除某些线性地址区间来动态修改进程的地址空间。 </p>
<p>内核通过所谓线性区的资源来表示线性地址区间，线性区是由起始线性地址、长度和一些访问权限来描述的。为了效率起见，起始地址和线性区的长度都必须是4096的倍数，以便每个线性区所识别的数据完全填满分配给它的页框。 </p>
<p>我们会在“缺页异常处理程序”博文中看到，确定一个进程当前所拥有的线性区（即进程的地址空间）是内核的基本任务，因为这可以让缺页异常处理程序有效地区分引发这个异常处理程序的两种不同类型的无效线性地址： </p>
<ul>
<li><p>由编程错误引发的无效线性地址。 </p>
</li>
<li><p>由缺页引发的无效线性地址；即使这个线性地址属于进程的地址空间，但是对应于这个地址的页框仍然有待分配。 </p>
</li>
</ul>
<p>从进程的观点来看，后一种地址不是无效的，内核要利用这种缺页以实现请求调页：内核通过提供页框来处理这种缺页，并让进程继续执行。 </p>
<h2 id="内存描述符_">内存描述符 </h2>
<p>与进程地址空间有关的全部信息都包含在一个叫做内存描述符（memory descriptor）的数据结构中，这个结构的类型为mm_struct，进程描述符的mm字段就指向这个结构。 </p>
<p>所有的内存描述符存放在一个双向链表中。每个描述符在mmlist段存放链表相邻元素的地址。链表的第一个元素是init_mm的mmlist字段，init_mm是初始化阶段进程0所使用的内存描述符。mmlist_lock自旋锁保护多处理器系统对链表的同时访问（同样是位于include/linux/Sched.h）： </p>
<p>extern spinlock_t mmlist_lock; </p>
<p>mm_users字段存放共享mm_struct数据结构的轻进程的个数。mm_count字段是内存描述符的主是使用计数器，在mm_users次使用计数器中的所有用户在mm_count中只作为一个单位。每当mm_count递减时，内核都要检查它是否变为0，如果是，就要解除这个内存描述符，因为不再有用户使用它。 </p>
<p>我们用一个例子来解释mm_users和mm_count之间的不同。如果一个内存描述符由两个轻量级进程共享。它的mm_users字段通常存放的值为2，而mm_count字段存放的值为1（两个所有者进程算作一个）。 </p>
<p>如果把内存描述符暂时借给一个内核线程，那么，内核就增加mm_count。这样，即使两个轻量级进程都死亡，且mm_users字段变为0，这个内存描述符也不被释放，直到内核线程使用完为止，因为mm_count字段仍然大于0。 </p>
<p>但是，如果内核想确保内存描述符在一个长操作的中间不被释放，那么，就应该增加mm_users字段而不是mm_coont字段的值。最终的结果是相同的，因为mm_users的增加确保了mm_count不变为0，即使拥有这个内存描述符的所有轻进程全部死亡。 </p>
<h2 id="内核线程的内存描述符_">内核线程的内存描述符 </h2>
<p>内核线程仅运行在内核态，因此，它们永远不会访问低于TASK_SIZE（等于PAGE_OFFSET，通常为0xc0000000，即768MB)的地址。与普通进程相反，内核线程不用线性区（vm_area_struct），因此，内存描述符的很多字段对内核线程是没有意义的。 </p>
<p>因为大于TASK_SIZE线性地址的相应页表项都应该总是相同的，因此，一个内核线程到底使用什么样的页表集根本就没有什么关系。为了避免无用的TLB和高速缓存刷新，内核线程使用一组最近运行的普通进程的页表。所以，我们在每个进程描述符中包含了两种内存描述符的指针：mm和active_mm。 </p>
<p>进程描述符中的mm字段指向进程所拥有的内存描述符，而active_mm字段指向进程运行时所使用的内存描述符。对于普通进程而言，这两个字段存放相同的指针。但是，内核线程不拥有任何内存描述符，因此，它们的mm字段总是为NULL。当内核线程得以运行时，他的active_mm字段被初始化为前一个运行进程的active_mm值。</p>
<p><br><br>本文章参考自《深入理解linux内核》 。   </p>
]]></content>
    <summary type="html">
    <![CDATA[本文介绍了linux进程地址空间的相关知识。]]>
    
    </summary>
    
      <category term="linux" scheme="http://blog.tinyxd.me/tags/linux/"/>
    
      <category term="kernel" scheme="http://blog.tinyxd.me/tags/kernel/"/>
    
      <category term="linux" scheme="http://blog.tinyxd.me/categories/linux/"/>
    
  </entry>
  
</feed>
